"
" This file was automatically generated by riml 0.3.5
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

if exists('g:portkey_app_loaded')
  finish
endif
" included: 'portkey_inc.riml'
" included: 'msg.riml'
function! s:echo_warn(...)
  call s:echo_with(a:000, 'WarningMsg')
endfunction

function! s:echo_error(...)
  call s:echo_with(a:000, 'ErrorMsg')
endfunction

function! s:echo_msg(...)
  if exists('g:speckle_mode')
    let logger = s:get_logger()
    let res = call(logger['info'], a:000, logger)
  else
    call s:echo_with(a:000, 'None')
  endif
endfunction

function! s:echo_with(args, style)
  if exists('g:speckle_mode')
    return
  endif
  let msg = join(a:args, ' ')
  execute ":echohl " . a:style
  echomsg msg
  echohl None
endfunction

" included: 'log_helpers.riml'
function! s:info(...)
  let logger = s:get_logger()
  return call(logger['info'], a:000, logger)
endfunction

function! s:warn(...)
  let logger = s:get_logger()
  return call(logger['warn'], a:000, logger)
endfunction

function! s:error(...)
  let logger = s:get_logger()
  return call(logger['error'], a:000, logger)
endfunction

function! s:fatal(...)
  let logger = s:get_logger()
  return call(logger['fatal'], a:000, logger)
endfunction

" included: 'string_helpers.riml'
function! s:str_to_lines(str)
  return split(a:str, "\n")
endfunction

" included: 'delegate.riml'
function! s:DelegateConstructor(scope, method)
  let delegateObj = {}
  let delegateObj.scope = a:scope
  let delegateObj.method = a:method
  let delegateObj.id = s:next_delegate_id()
  let delegateObj.unlinked = 0
  let delegateObj.invoke = function('<SNR>' . s:SID() . '_s:Delegate_invoke')
  let delegateObj.unlink = function('<SNR>' . s:SID() . '_s:Delegate_unlink')
  return delegateObj
endfunction

function! <SID>s:Delegate_invoke(...) dict
  if self.unlinked
    return
  endif
  return call(self.scope[self.method], a:000, self.scope)
endfunction

function! <SID>s:Delegate_unlink() dict
  let self.unlinked = 1
endfunction

let s:delegate_id_counter = 0
let s:delegate_instances = {}
function! s:next_delegate_id()
  let s:delegate_id_counter += 1
  return s:delegate_id_counter
endfunction

function! s:create_delegate(scope, method)
  let delegate = s:DelegateConstructor(a:scope, a:method)
  let id = delegate.id
  let s:delegate_instances[id] = delegate
  let delegate_name = "s:DelegateFunction" . id
  let delegate_func = "function! " . delegate_name . "(...)\n  let id = " . id . "\n  let NewDelegate = s:get_delegate_instance(id)\n  return call(NewDelegate.invoke, a:000, NewDelegate)\nendfunction"
  execute delegate_func
  let DelegateFuncRef = function(delegate_name)
  return DelegateFuncRef
endfunction

function! s:get_delegate_instance(id)
  return s:delegate_instances[a:id]
endfunction

function! s:remove_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  execute ":unlet s:delegate_instances[" . id . "]"
  execute ":delfunction " . func_name
endfunction

function! s:unlink_delegate(Func)
  let func_name = s:get_delegate_name(a:Func)
  let id = substitute(func_name, '\v^(.*)(DelegateFunction)(\d+).*', '\3', '')
  let delegate = s:get_delegate_instance(id)
  call delegate.unlink()
endfunction

function! s:get_delegate_name(Func)
  let func_def = string(a:Func)
  let sid = s:SID()
  let pattern = "\\v^function.{1}'(.*)'.{1}$"
  let result = substitute(func_def, pattern, '\1', '')
  let result = substitute(result, 's:', '<SNR>' . sid . '_', '')
  return result
endfunction

function! s:new_delegate(scope, method)
  return s:get_delegate_name(s:create_delegate(a:scope, a:method))
endfunction

" included: 'json_parser.riml'
function! s:JSONParserConstructor()
  let jSONParserObj = {}
  let jSONParserObj.parse = function('<SNR>' . s:SID() . '_s:JSONParser_parse')
  return jSONParserObj
endfunction

function! <SID>s:JSONParser_parse(str) dict
  try
    let result = eval(a:str)
    return result
  catch /.*/
    return 0
  endtry
endfunction

" included: 'object_cache.riml'
function! s:ObjectCacheConstructor()
  let objectCacheObj = {}
  let objectCacheObj.cache = {}
  let objectCacheObj.hits = 0
  let objectCacheObj.misses = 0
  let objectCacheObj.has = function('<SNR>' . s:SID() . '_s:ObjectCache_has')
  let objectCacheObj.add = function('<SNR>' . s:SID() . '_s:ObjectCache_add')
  let objectCacheObj.insert = function('<SNR>' . s:SID() . '_s:ObjectCache_insert')
  let objectCacheObj.put = function('<SNR>' . s:SID() . '_s:ObjectCache_put')
  let objectCacheObj.get = function('<SNR>' . s:SID() . '_s:ObjectCache_get')
  let objectCacheObj.remove = function('<SNR>' . s:SID() . '_s:ObjectCache_remove')
  let objectCacheObj.clear = function('<SNR>' . s:SID() . '_s:ObjectCache_clear')
  let objectCacheObj.clear_all = function('<SNR>' . s:SID() . '_s:ObjectCache_clear_all')
  let objectCacheObj.get_hits = function('<SNR>' . s:SID() . '_s:ObjectCache_get_hits')
  let objectCacheObj.get_misses = function('<SNR>' . s:SID() . '_s:ObjectCache_get_misses')
  return objectCacheObj
endfunction

function! <SID>s:ObjectCache_has(key) dict
  return has_key(self.cache, a:key)
endfunction

function! <SID>s:ObjectCache_add(key, value) dict
  if !(self.has(a:key))
    let self.cache[a:key] = []
  endif
  let list = self.cache[a:key]
  call add(list, a:value)
  let self.misses += 1
endfunction

function! <SID>s:ObjectCache_insert(key, value) dict
  if !(self.has(a:key))
    let self.cache[a:key] = []
  endif
  let list = self.cache[a:key]
  call insert(list, a:value)
  let self.misses += 1
endfunction

function! <SID>s:ObjectCache_put(key, value) dict
  let self.cache[a:key] = a:value
  let self.misses += 1
endfunction

function! <SID>s:ObjectCache_get(key) dict
  let self.hits += 1
  return self.cache[a:key]
endfunction

function! <SID>s:ObjectCache_remove(key) dict
  if self.has(a:key)
    unlet self.cache[a:key]
  endif
endfunction

function! <SID>s:ObjectCache_clear(...) dict
  if len(a:000) ==# 1
    let pattern = a:000[0]
  else
    return self.clear_all()
  endif
  for key in keys(self.cache)
    if key =~# pattern
      unlet self.cache[key]
    endif
  endfor
endfunction

function! <SID>s:ObjectCache_clear_all() dict
  unlet self.cache
  let self.cache = {}
  let self.hits = 0
  let self.misses = 0
endfunction

function! <SID>s:ObjectCache_get_hits() dict
  return self.hits
endfunction

function! <SID>s:ObjectCache_get_misses() dict
  return self.misses
endfunction

" included: 'memoizer.riml'
function! s:MemoizerDelegateConstructor(target, method, cache_store, memoizer)
  let memoizerDelegateObj = {}
  let memoizerDelegateObj.target = a:target
  let memoizerDelegateObj.method = a:method
  let memoizerDelegateObj.cache_store = a:cache_store
  let memoizerDelegateObj.memoizer = a:memoizer
  let memoizerDelegateObj.get_key = function('<SNR>' . s:SID() . '_s:MemoizerDelegate_get_key')
  let memoizerDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:MemoizerDelegate_invoke')
  return memoizerDelegateObj
endfunction

function! <SID>s:MemoizerDelegate_get_key(args) dict
  if len(a:args) ==# 0
    return 'memoizer-no-args'
  else
    return join(a:args, '_')
  endif
endfunction

function! <SID>s:MemoizerDelegate_invoke(...) dict
  let active = self.memoizer.memoizer_is_active()
  let key = self.get_key(a:000)
  if active && self.cache_store.has(key)
    return self.cache_store.get(key)
  endif
  let Result = call(self.target[self.method], a:000, self.target)
  if active
    call self.cache_store.put(key, Result)
  endif
  return Result
endfunction

function! s:MemoizerConstructor(target)
  let memoizerObj = {}
  let memoizerObj.memoizer_cache = {}
  let memoizerObj.memoizer_target = a:target
  let memoizerObj.memoizer_active = 0
  let memoizerObj.memoizer_get_target = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_get_target')
  let memoizerObj.memoizer_load_method = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_load_method')
  let memoizerObj.memoizer_load = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_load')
  let memoizerObj.memoizer_load_all = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_load_all')
  let memoizerObj.memoizer_start = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_start')
  let memoizerObj.memoizer_stop = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_stop')
  let memoizerObj.memoizer_is_active = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_is_active')
  let memoizerObj.memoizer_clear_cache = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_clear_cache')
  let memoizerObj.memoizer_clear_all = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_clear_all')
  let memoizerObj.memoizer_get_hits = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_get_hits')
  let memoizerObj.memoizer_get_misses = function('<SNR>' . s:SID() . '_s:Memoizer_memoizer_get_misses')
  return memoizerObj
endfunction

function! <SID>s:Memoizer_memoizer_get_target() dict
  return self.memoizer_target
endfunction

function! <SID>s:Memoizer_memoizer_load_method(Method) dict
  let cache_store = s:ObjectCacheConstructor()
  let memoizer_delegate = s:MemoizerDelegateConstructor(self.memoizer_target, a:Method, cache_store, self)
  let Method_delegate = s:create_delegate(memoizer_delegate, 'invoke')
  let self.memoizer_cache[a:Method] = cache_store
  let self[a:Method] = Method_delegate
endfunction

function! <SID>s:Memoizer_memoizer_load(...) dict
  if len(a:000) ==# 1 && type(a:000[0]) ==# type([])
    let params = a:000[0]
  else
    let params = a:000
  endif
  for param in params
    call self.memoizer_load_method(param)
  endfor
endfunction

function! <SID>s:Memoizer_memoizer_load_all() dict
  for Method in keys(self.memoizer_target)
    if type(self.memoizer_target[Method]) ==# 2
      call self.memoizer_load_method(Method)
    endif
  endfor
endfunction

function! <SID>s:Memoizer_memoizer_start() dict
  call self.memoizer_clear_all()
  let self.memoizer_active = 1
endfunction

function! <SID>s:Memoizer_memoizer_stop() dict
  let self.memoizer_active = 0
endfunction

function! <SID>s:Memoizer_memoizer_is_active() dict
  return self.memoizer_active
endfunction

function! <SID>s:Memoizer_memoizer_clear_cache(method) dict
  let cache_store = self.memoizer_cache[a:method]
  call cache_store.clear()
endfunction

function! <SID>s:Memoizer_memoizer_clear_all() dict
  for method in keys(self.memoizer_cache)
    call self.memoizer_clear_cache(method)
  endfor
endfunction

function! <SID>s:Memoizer_memoizer_get_hits() dict
  let hits = 0
  for cache_store in values(self.memoizer_cache)
    let hits += cache_store.get_hits()
  endfor
  return hits
endfunction

function! <SID>s:Memoizer_memoizer_get_misses() dict
  let misses = 0
  for cache_store in values(self.memoizer_cache)
    let misses += cache_store.get_misses()
  endfor
  return misses
endfunction

" included: 'file_opener.riml'
function! s:FileOpenerConstructor()
  let fileOpenerObj = {}
  let fileOpenerObj.is_file_opener = 1
  let fileOpenerObj.mkdir_mode = 1
  let fileOpenerObj.exec_mode = 1
  let fileOpenerObj.exec_cmd = ''
  let fileOpenerObj.exec_mkdir = ''
  let fileOpenerObj.set_mkdir_mode = function('<SNR>' . s:SID() . '_s:FileOpener_set_mkdir_mode')
  let fileOpenerObj.get_mkdir_mode = function('<SNR>' . s:SID() . '_s:FileOpener_get_mkdir_mode')
  let fileOpenerObj.set_exec_mode = function('<SNR>' . s:SID() . '_s:FileOpener_set_exec_mode')
  let fileOpenerObj.get_exec_mode = function('<SNR>' . s:SID() . '_s:FileOpener_get_exec_mode')
  let fileOpenerObj.open = function('<SNR>' . s:SID() . '_s:FileOpener_open')
  let fileOpenerObj.open_with = function('<SNR>' . s:SID() . '_s:FileOpener_open_with')
  let fileOpenerObj.mkdir = function('<SNR>' . s:SID() . '_s:FileOpener_mkdir')
  let fileOpenerObj.build_cmd = function('<SNR>' . s:SID() . '_s:FileOpener_build_cmd')
  return fileOpenerObj
endfunction

function! <SID>s:FileOpener_set_mkdir_mode(mkdir_mode) dict
  let self.mkdir_mode = a:mkdir_mode
endfunction

function! <SID>s:FileOpener_get_mkdir_mode() dict
  return self.mkdir_mode
endfunction

function! <SID>s:FileOpener_set_exec_mode(exec_mode) dict
  let self.exec_mode = a:exec_mode
endfunction

function! <SID>s:FileOpener_get_exec_mode() dict
  return self.exec_mode
endfunction

function! <SID>s:FileOpener_open(file, mode) dict
  let cmd = self.build_cmd(a:file, a:mode)
  call self.mkdir(a:file)
  call self.open_with(cmd)
endfunction

function! <SID>s:FileOpener_open_with(cmd) dict
  if self.exec_mode
    execute a:cmd
  else
    let self.exec_cmd = a:cmd
  endif
endfunction

function! <SID>s:FileOpener_mkdir(file) dict
  let parent_dir = fnamemodify(a:file, ':p:h')
  if !isdirectory(parent_dir) && self.mkdir_mode
    if self.exec_mode
      if exists('*mkdir')
        call mkdir(parent_dir, 'p')
      endif
    else
      let self.exec_mkdir = parent_dir
    endif
  endif
endfunction

function! <SID>s:FileOpener_build_cmd(file, mode) dict
  let cmd = ''
  if a:mode ==# 'e' || a:mode ==# 'edit'
    let cmd = 'edit'
  elseif a:mode ==# 's' || a:mode ==# 'h' || a:mode ==# 'split'
    let cmd = 'split'
  elseif a:mode ==# 'v' || a:mode ==# 'vsplit'
    let cmd = 'vsplit'
  elseif a:mode ==# 't' || a:mode ==# 'tab'
    let cmd = 'tabedit'
  elseif a:mode ==# 'd' || a:mode ==# 'read'
    let cmd = 'read'
  elseif a:mode ==# 'abo' || a:mode ==# 'aboveleft' || a:mode ==# 'lefta' || a:mode ==# 'leftabove'
    let cmd = 'leftabove'
  elseif a:mode ==# 'rightb' || a:mode ==# 'rightbelow' || a:mode ==# 'bel' || a:mode ==# 'belowright'
    let cmd = 'rightbelow'
  elseif a:mode ==# 'to' || a:mode ==# 'topleft'
    let cmd = 'topleft'
  elseif a:mode ==# 'bo' || a:mode ==# 'botright'
    let cmd = 'botright'
  else
    let cmd = 'edit'
  endif
  let cmd = ":" . cmd . " " . a:file
  return cmd
endfunction

" included: 'buffer_opener.riml'
function! s:BufferOpenerConstructor()
  let bufferOpenerObj = {}
  let bufferOpenerObj.is_buffer_opener = 1
  let bufferOpenerObj.needs = function('<SNR>' . s:SID() . '_s:BufferOpener_needs')
  let bufferOpenerObj.open = function('<SNR>' . s:SID() . '_s:BufferOpener_open')
  let bufferOpenerObj.get_abs_root = function('<SNR>' . s:SID() . '_s:BufferOpener_get_abs_root')
  let bufferOpenerObj.get_rel_path = function('<SNR>' . s:SID() . '_s:BufferOpener_get_rel_path')
  let bufferOpenerObj.get_abs_path = function('<SNR>' . s:SID() . '_s:BufferOpener_get_abs_path')
  return bufferOpenerObj
endfunction

function! <SID>s:BufferOpener_needs() dict
  return ['context', 'file_opener']
endfunction

function! <SID>s:BufferOpener_open(filepath, create_if_not_found, window_mode) dict
  let rel_path = self.get_rel_path(a:filepath)
  let file_exists = filereadable(rel_path)
  if file_exists || a:create_if_not_found
    call self.file_opener.open(rel_path, a:window_mode)
    return 1
  else
    return 0
  endif
endfunction

function! <SID>s:BufferOpener_get_abs_root() dict
  return self.context.get_root()
endfunction

function! <SID>s:BufferOpener_get_rel_path(filepath) dict
  return fnamemodify(self.get_abs_path(a:filepath), ':.')
endfunction

function! <SID>s:BufferOpener_get_abs_path(filepath) dict
  return self.get_abs_root() . a:filepath
endfunction

" included: 'inflector.riml'
function! s:InflectionRuleConstructor(from, to, ...)
  let inflectionRuleObj = {}
  let inflectionRuleObj.from = a:from
  let inflectionRuleObj.to = a:to
  if len(a:000) ==# 0
    let inflectionRuleObj.flags = 'gi'
  else
    let inflectionRuleObj.flags = a:000[0]
  endif
  return inflectionRuleObj
endfunction

function! s:InflectionExecuterConstructor()
  let inflectionExecuterObj = {}
  let inflectionExecuterObj.inflect = function('<SNR>' . s:SID() . '_s:InflectionExecuter_inflect')
  return inflectionExecuterObj
endfunction

function! <SID>s:InflectionExecuter_inflect(src, rules) dict
  for rule in a:rules
    if match(a:src, rule.from) >=# 0
      return substitute(a:src, rule.from, rule.to, rule.flags)
    endif
  endfor
  return a:src
endfunction

function! s:BaseInflectorConstructor()
  let baseInflectorObj = {}
  let baseInflectorObj.is_base_inflector = 1
  let baseInflectorObj.plural_rules = []
  let baseInflectorObj.singular_rules = []
  let baseInflectorObj.singular_irregulars = []
  let baseInflectorObj.plural_irregulars = []
  let baseInflectorObj.uncountable = {}
  let baseInflectorObj.executer = s:InflectionExecuterConstructor()
  let baseInflectorObj.acronyms = {}
  let baseInflectorObj.acronyms_regex = ''
  let baseInflectorObj.mode = 'prepend'
  let baseInflectorObj.add_rule = function('<SNR>' . s:SID() . '_s:BaseInflector_add_rule')
  let baseInflectorObj.set_mode = function('<SNR>' . s:SID() . '_s:BaseInflector_set_mode')
  let baseInflectorObj.get_mode = function('<SNR>' . s:SID() . '_s:BaseInflector_get_mode')
  let baseInflectorObj.add_plural_rule = function('<SNR>' . s:SID() . '_s:BaseInflector_add_plural_rule')
  let baseInflectorObj.add_singular_rule = function('<SNR>' . s:SID() . '_s:BaseInflector_add_singular_rule')
  let baseInflectorObj.add_uncountable = function('<SNR>' . s:SID() . '_s:BaseInflector_add_uncountable')
  let baseInflectorObj.add_plural_rules = function('<SNR>' . s:SID() . '_s:BaseInflector_add_plural_rules')
  let baseInflectorObj.add_singular_rules = function('<SNR>' . s:SID() . '_s:BaseInflector_add_singular_rules')
  let baseInflectorObj.add_uncountables = function('<SNR>' . s:SID() . '_s:BaseInflector_add_uncountables')
  let baseInflectorObj.add_irregular = function('<SNR>' . s:SID() . '_s:BaseInflector_add_irregular')
  let baseInflectorObj.add_irregulars = function('<SNR>' . s:SID() . '_s:BaseInflector_add_irregulars')
  let baseInflectorObj.add_acronym = function('<SNR>' . s:SID() . '_s:BaseInflector_add_acronym')
  let baseInflectorObj.add_acronyms = function('<SNR>' . s:SID() . '_s:BaseInflector_add_acronyms')
  let baseInflectorObj.pluralize = function('<SNR>' . s:SID() . '_s:BaseInflector_pluralize')
  let baseInflectorObj.singularize = function('<SNR>' . s:SID() . '_s:BaseInflector_singularize')
  let baseInflectorObj.capitalize = function('<SNR>' . s:SID() . '_s:BaseInflector_capitalize')
  let baseInflectorObj.camelize = function('<SNR>' . s:SID() . '_s:BaseInflector_camelize')
  let baseInflectorObj.lower_camelize = function('<SNR>' . s:SID() . '_s:BaseInflector_lower_camelize')
  let baseInflectorObj.underscorize = function('<SNR>' . s:SID() . '_s:BaseInflector_underscorize')
  let baseInflectorObj.dasherize = function('<SNR>' . s:SID() . '_s:BaseInflector_dasherize')
  let baseInflectorObj.humanize = function('<SNR>' . s:SID() . '_s:BaseInflector_humanize')
  let baseInflectorObj.titleize = function('<SNR>' . s:SID() . '_s:BaseInflector_titleize')
  let baseInflectorObj.tableize = function('<SNR>' . s:SID() . '_s:BaseInflector_tableize')
  let baseInflectorObj.classify = function('<SNR>' . s:SID() . '_s:BaseInflector_classify')
  let baseInflectorObj.affinize = function('<SNR>' . s:SID() . '_s:BaseInflector_affinize')
  let baseInflectorObj.clear = function('<SNR>' . s:SID() . '_s:BaseInflector_clear')
  let baseInflectorObj.is_uncountable = function('<SNR>' . s:SID() . '_s:BaseInflector_is_uncountable')
  let baseInflectorObj.is_irregular = function('<SNR>' . s:SID() . '_s:BaseInflector_is_irregular')
  let baseInflectorObj.update_acronyms_regex = function('<SNR>' . s:SID() . '_s:BaseInflector_update_acronyms_regex')
  let baseInflectorObj.replace_acronyms = function('<SNR>' . s:SID() . '_s:BaseInflector_replace_acronyms')
  let baseInflectorObj.has_acronym_at_start = function('<SNR>' . s:SID() . '_s:BaseInflector_has_acronym_at_start')
  let baseInflectorObj.acronym_for_match = function('<SNR>' . s:SID() . '_s:BaseInflector_acronym_for_match')
  return baseInflectorObj
endfunction

function! <SID>s:BaseInflector_add_rule(rules, from, to, ...) dict
  if self.is_uncountable(a:from)
    unlet self.uncountable[a:from]
  endif
  let from = '\v' . a:from
  if len(a:000) ==# 1
    let flags = a:000[0]
    let rule = s:InflectionRuleConstructor(from, a:to, flags)
  else
    let rule = s:InflectionRuleConstructor(from, a:to)
  endif
  if self.mode ==# 'prepend'
    call insert(a:rules, rule)
  else
    call add(a:rules, rule)
  endif
endfunction

function! <SID>s:BaseInflector_set_mode(mode) dict
  let self.mode = a:mode
endfunction

function! <SID>s:BaseInflector_get_mode() dict
  return self.mode
endfunction

function! <SID>s:BaseInflector_add_plural_rule(...) dict
  return call(self['add_rule'], [self.plural_rules] + a:000, self)
endfunction

function! <SID>s:BaseInflector_add_singular_rule(...) dict
  return call(self['add_rule'], [self.singular_rules] + a:000, self)
endfunction

function! <SID>s:BaseInflector_add_uncountable(word) dict
  let self.uncountable[a:word] = 1
endfunction

function! <SID>s:BaseInflector_add_plural_rules(rules) dict
  for rule in a:rules
    let res = call(self['add_plural_rule'], rule, self)
  endfor
endfunction

function! <SID>s:BaseInflector_add_singular_rules(rules) dict
  for rule in a:rules
    let res = call(self['add_singular_rule'], rule, self)
  endfor
endfunction

function! <SID>s:BaseInflector_add_uncountables(words) dict
  for word in a:words
    call self.add_uncountable(word)
  endfor
endfunction

function! <SID>s:BaseInflector_add_irregular(singular, plural) dict
  let singular_pattern = a:singular . '$'
  let plural_pattern = a:plural . '$'
  call self.add_rule(self.singular_irregulars, plural_pattern, a:singular)
  call self.add_rule(self.plural_irregulars, singular_pattern, a:plural)
endfunction

function! <SID>s:BaseInflector_add_irregulars(rules) dict
  for rule in a:rules
    let res = call(self['add_irregular'], rule, self)
  endfor
endfunction

function! <SID>s:BaseInflector_add_acronym(word) dict
  let acronym = tolower(a:word)
  let self.acronyms[acronym] = a:word
  call self.update_acronyms_regex()
endfunction

function! <SID>s:BaseInflector_add_acronyms(words) dict
  for word in a:words
    let acronym = tolower(word)
    let self.acronyms[acronym] = word
  endfor
  call self.update_acronyms_regex()
endfunction

function! <SID>s:BaseInflector_pluralize(word) dict
  if self.is_uncountable(a:word)
    return a:word
  else
    let result = self.executer.inflect(a:word, self.plural_irregulars)
    if result !=# a:word
      return result
    else
      return self.executer.inflect(a:word, self.plural_rules)
    endif
  endif
endfunction

function! <SID>s:BaseInflector_singularize(word) dict
  if self.is_uncountable(a:word)
    return a:word
  else
    let result = self.executer.inflect(a:word, self.singular_irregulars)
    if result !=# a:word
      return result
    else
      return self.executer.inflect(a:word, self.singular_rules)
    endif
  endif
endfunction

function! <SID>s:BaseInflector_capitalize(word) dict
  let pattern = '\v^(.)(.*)$'
  return substitute(a:word, pattern, '\u\1\L\2', '')
endfunction

function! <SID>s:BaseInflector_camelize(str) dict
  let camel_pattern = '\v%([_/|-]){1}(.)'
  let camel_replace = '\u\1'
  let str = self.capitalize(a:str)
  let str = substitute(str, camel_pattern, camel_replace, 'g')
  let str = self.replace_acronyms(str)
  return str
endfunction

function! <SID>s:BaseInflector_lower_camelize(str) dict
  let camel_pattern = '\v%([_/|-]){1}(.)'
  let camel_replace = '\u\1'
  let str = tolower(a:str)
  let str = substitute(str, camel_pattern, camel_replace, 'g')
  if !(self.has_acronym_at_start(str))
    let str = self.replace_acronyms(str)
  endif
  return str
endfunction

function! <SID>s:BaseInflector_underscorize(str) dict
  let str = substitute(a:str, '\v([:/|]+)', '_', 'g')
  let str = substitute(str, '\v(\u+)(\u\l)', '\1_\2', 'g')
  let str = substitute(str, '\v(\l|\d)(\u)', '\1_\2', 'g')
  let str = substitute(str, '-', '_', 'g')
  let str = tolower(str)
  return str
endfunction

function! <SID>s:BaseInflector_dasherize(str) dict
  let str = self.underscorize(a:str)
  let str = substitute(str, '_', '-', 'g')
  return str
endfunction

function! <SID>s:BaseInflector_humanize(str) dict
  let str = substitute(a:str, '\v_id', '', 'g')
  let str = substitute(str, '\v([-_/|])', ' ', 'g')
  let str = self.replace_acronyms(str)
  return str
endfunction

function! <SID>s:BaseInflector_titleize(str) dict
  let title_pattern = '\v(\s+|^)(\l)'
  let str = self.underscorize(a:str)
  let str = self.humanize(str)
  let str = substitute(str, title_pattern, '\1\u\2', 'g')
  return str
endfunction

function! <SID>s:BaseInflector_tableize(word) dict
  return self.pluralize(self.underscorize(a:word))
endfunction

function! <SID>s:BaseInflector_classify(table_name) dict
  let table_name = self.underscorize(a:table_name)
  let table_name = substitute(table_name, '.*\.', '', '')
  return self.camelize(self.singularize(table_name))
endfunction

function! <SID>s:BaseInflector_affinize(name, a) dict
  if a:a ==# 'model' || a:a ==# 'resource' || a:a ==# 'singular' || a:a ==# '' || a:a ==# 'null'
    return self.singularize(a:name)
  elseif a:a ==# 'controller' || a:a ==# 'collection' || a:a ==# 'plural'
    return self.pluralize(a:name)
  else
    return a:a
  endif
endfunction

function! <SID>s:BaseInflector_clear() dict
  let self.plural_rules = []
  let self.singular_rules = []
  let self.acronyms = {}
  let self.acronyms_regex = ''
  let self.uncountable = {}
endfunction

function! <SID>s:BaseInflector_is_uncountable(word) dict
  return has_key(self.uncountable, a:word)
endfunction

function! <SID>s:BaseInflector_is_irregular(quantity, word) dict
  return has_key(self["irregular_" . a:quantity], a:word)
endfunction

function! <SID>s:BaseInflector_update_acronyms_regex() dict
  let self.acronyms_regex = '(' . join(keys(self.acronyms), '|') . ')'
endfunction

function! <SID>s:BaseInflector_replace_acronyms(str) dict
  if len(self.acronyms) ># 0
    return substitute(a:str, '\v' . self.acronyms_regex, '\=self.acronym_for_match(submatch(0))', 'gi')
  else
    return a:str
  endif
endfunction

function! <SID>s:BaseInflector_has_acronym_at_start(str) dict
  let pattern = '\v^' . self.acronyms_regex
  let result = match(a:str, pattern)
  return result ==# 0
endfunction

function! <SID>s:BaseInflector_acronym_for_match(str) dict
  let key = tolower(a:str)
  if has_key(self.acronyms, key)
    return self.acronyms[key]
  else
    return ''
  endif
endfunction

function! s:InflectorConstructor()
  let inflectorObj = {}
  let baseInflectorObj = s:BaseInflectorConstructor()
  call extend(inflectorObj, baseInflectorObj)
  let inflectorObj.is_inflector = 1
  let inflectorObj.on_inject = function('<SNR>' . s:SID() . '_s:Inflector_on_inject')
  let inflectorObj.load_defaults = function('<SNR>' . s:SID() . '_s:Inflector_load_defaults')
  return inflectorObj
endfunction

function! <SID>s:Inflector_on_inject() dict
  call self.load_defaults()
endfunction

function! <SID>s:Inflector_load_defaults() dict
  call self.set_mode('append')
  call self.add_irregulars(s:get_default_irregular_rules())
  call self.add_plural_rules(s:get_default_plural_rules())
  call self.add_singular_rules(s:get_default_singular_rules())
  call self.add_acronyms(s:get_default_acronyms())
  call self.add_uncountables(s:get_default_uncountables())
  call self.set_mode('prepend')
endfunction

function! s:InflectionLoaderConstructor()
  let inflectionLoaderObj = {}
  let inflectionLoaderObj.load = function('<SNR>' . s:SID() . '_s:InflectionLoader_load')
  let inflectionLoaderObj.load_acronyms = function('<SNR>' . s:SID() . '_s:InflectionLoader_load_acronyms')
  let inflectionLoaderObj.load_uncountables = function('<SNR>' . s:SID() . '_s:InflectionLoader_load_uncountables')
  let inflectionLoaderObj.load_irregulars = function('<SNR>' . s:SID() . '_s:InflectionLoader_load_irregulars')
  let inflectionLoaderObj.load_singulars = function('<SNR>' . s:SID() . '_s:InflectionLoader_load_singulars')
  let inflectionLoaderObj.load_plurals = function('<SNR>' . s:SID() . '_s:InflectionLoader_load_plurals')
  return inflectionLoaderObj
endfunction

function! <SID>s:InflectionLoader_load(json, inflector) dict
  if has_key(a:json, 'mode')
    call a:inflector.set_mode(a:json.mode)
  endif
  for [key, value] in items(a:json)
    if key ==# 'acronyms'
      call self.load_acronyms(value, a:inflector)
    elseif key ==# 'uncountables'
      call self.load_uncountables(value, a:inflector)
    elseif key ==# 'irregulars'
      call self.load_irregulars(value, a:inflector)
    elseif key ==# 'singulars'
      call self.load_singulars(value, a:inflector)
    elseif key ==# 'plurals'
      call self.load_plurals(value, a:inflector)
    endif
    unlet value
  endfor
endfunction

function! <SID>s:InflectionLoader_load_acronyms(json, inflector) dict
  if type(a:json) ==# type('')
    let acronyms = [a:json]
  else
    let acronyms = a:json
  endif
  call a:inflector.add_acronyms(acronyms)
endfunction

function! <SID>s:InflectionLoader_load_uncountables(json, inflector) dict
  if type(a:json) ==# type('')
    let uncountables = [a:json]
  else
    let uncountables = a:json
  endif
  call a:inflector.add_uncountables(uncountables)
endfunction

function! <SID>s:InflectionLoader_load_irregulars(json, inflector) dict
  for [singular, plural] in items(a:json)
    call a:inflector.add_irregular(singular, plural)
  endfor
endfunction

function! <SID>s:InflectionLoader_load_singulars(json, inflector) dict
  for [from, to] in items(a:json)
    call a:inflector.add_singular_rule(from, to)
  endfor
endfunction

function! <SID>s:InflectionLoader_load_plurals(json, inflector) dict
  for [from, to] in items(a:json)
    call a:inflector.add_plural_rule(from, to)
  endfor
endfunction

" included: 'inflections.riml'
function! s:get_default_plural_rules()
  let rules = [['^(ox)$', '\1en'], ['(ax|test)is$', '\1es'], ['(octop|vir)us$', '\1i'], ['(alias|status)$', '\1es'], ['(bu)s$', '\1ses'], ['(buffal|tomat|potat)o$', '\1oes'], ['([ti])um$', '\1a'], ['sis$', 'ses'], ['%(([^f])fe|([lr])f)$', '\1\2ves'], ['(hive)$', '\1s'], ['([^aeiouy]|qu)y$', '\1ies'], ['(matr|vert|ind)(ix|ex)$', '\1ices'], ['(x|ch|ss|sh)$', '\1es'], ['([m|l])ouse$', '\1ice'], ['(quiz)$', '\1zes'], ['s$', 's'], ['$', 's']]
  return rules
endfunction

function! s:get_default_singular_rules()
  let rules = [['(quiz)zes$', '\1'], ['(matr)ices$', '\1ix'], ['(vert|ind)ices$', '\1ex'], ['^(ox)en', '\1'], ['(alias|status)es$', '\1'], ['(octop|vir)i$', '\1us'], ['(cris|ax|test)es$', '\1is'], ['(shoe)s$', '\1'], ['(o)es$', '\1'], ['(bus)es$', '\1'], ['([m|l])ice$', '\1ouse'], ['(x|ch|ss|sh)es$', '\1'], ['(m)ovies$', '\1ovie'], ['(s)eries$', '\1eries'], ['([^aeiouy]|qu)ies$', '\1y'], ['([lr])ves$', '\1f'], ['(tive)s$', '\1'], ['(hive)s$', '\1'], ['([^fo])ves$', '\1fe'], ['(^analy)ses$', '\1sis'], ['((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$', '\1\2sis'], ['([ti])a$', '\1um'], ['(curve)s$', '\1'], ['(n)ews$', '\1ews'], ['s$', '']]
  return rules
endfunction

function! s:get_default_acronyms()
  let acronyms = []
  return acronyms
endfunction

function! s:get_default_uncountables()
  let uncountables = ['equipment', 'information', 'rice', 'money', 'species', 'series', 'sheep', 'moose', 'deer', 'news']
  return uncountables
endfunction

function! s:get_default_irregular_rules()
  let irregulars = [['man', 'men'], ['woman', 'women'], ['child', 'children'], ['person', 'people'], ['sex', 'sexes'], ['move', 'moves'], ['safe', 'safes']]
  return irregulars
endfunction

" included: 'ctrlp_extension.riml'
function! s:CtrlPExtensionConstructor()
  let ctrlPExtensionObj = {}
  let ctrlPExtensionObj.id_counter = 0
  let ctrlPExtensionObj.enabled = 0
  let ctrlPExtensionObj.inited = 0
  let ctrlPExtensionObj.next_id = function('<SNR>' . s:SID() . '_s:CtrlPExtension_next_id')
  let ctrlPExtensionObj.set_options = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_options')
  let ctrlPExtensionObj.get_options = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_options')
  let ctrlPExtensionObj.set_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_name')
  let ctrlPExtensionObj.get_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_name')
  let ctrlPExtensionObj.set_agent = function('<SNR>' . s:SID() . '_s:CtrlPExtension_set_agent')
  let ctrlPExtensionObj.get_agent = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_agent')
  let ctrlPExtensionObj.get_ext_vars = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_ext_vars')
  let ctrlPExtensionObj.get_id = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_id')
  let ctrlPExtensionObj.get_ex_cmd_name = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_ex_cmd_name')
  let ctrlPExtensionObj.enable = function('<SNR>' . s:SID() . '_s:CtrlPExtension_enable')
  let ctrlPExtensionObj.disable = function('<SNR>' . s:SID() . '_s:CtrlPExtension_disable')
  let ctrlPExtensionObj.show = function('<SNR>' . s:SID() . '_s:CtrlPExtension_show')
  let ctrlPExtensionObj.do_init = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_init')
  let ctrlPExtensionObj.do_accept = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_accept')
  let ctrlPExtensionObj.do_enter = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_enter')
  let ctrlPExtensionObj.do_exit = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_exit')
  let ctrlPExtensionObj.do_opts = function('<SNR>' . s:SID() . '_s:CtrlPExtension_do_opts')
  let ctrlPExtensionObj.get_callback = function('<SNR>' . s:SID() . '_s:CtrlPExtension_get_callback')
  let ctrlPExtensionObj.new_callback = function('<SNR>' . s:SID() . '_s:CtrlPExtension_new_callback')
  return ctrlPExtensionObj
endfunction

function! <SID>s:CtrlPExtension_next_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! <SID>s:CtrlPExtension_set_options(options) dict
  let self.options = a:options
endfunction

function! <SID>s:CtrlPExtension_get_options() dict
  return self.options
endfunction

function! <SID>s:CtrlPExtension_set_name(name) dict
  let self.name = a:name
  if self.enabled
    let opts = self.get_options()
    let opts.sname = a:name
    let opts.lname = a:name
  endif
endfunction

function! <SID>s:CtrlPExtension_get_name() dict
  return self.name
endfunction

function! <SID>s:CtrlPExtension_set_agent(agent) dict
  let self.agent = a:agent
endfunction

function! <SID>s:CtrlPExtension_get_agent() dict
  return self.agent
endfunction

function! <SID>s:CtrlPExtension_get_ext_vars() dict
  let opts = self.get_options()
  let opts.sname = self.get_name()
  let opts.lname = self.get_name()
  let opts.init = self.get_callback('init')
  let opts.accept = self.get_callback('accept')
  let opts.enter = self.get_callback('enter')
  let opts.exit = self.get_callback('exit')
  let opts.opts = self.get_callback('opts')
  return opts
endfunction

function! <SID>s:CtrlPExtension_get_id() dict
  return self.id
endfunction

function! <SID>s:CtrlPExtension_get_ex_cmd_name() dict
  return "CtrlP" . self.name
endfunction

function! <SID>s:CtrlPExtension_enable() dict
  if !(exists('g:ctrlp_ext_vars'))
    return
  endif
  let ext_vars = self.get_ext_vars()
  call add(g:ctrlp_ext_vars, ext_vars)
  let self.id = g:ctrlp_builtins + len(g:ctrlp_ext_vars)
  let ex_cmd = "command! " . self.get_ex_cmd_name() . " :call ctrlp#init(" . self.id . ")"
  execute ex_cmd
  let self.enabled = 1
  return ext_vars
endfunction

function! <SID>s:CtrlPExtension_disable() dict
  let self.enabled = 0
  if exists(":" . self.get_ex_cmd_name())
    execute ":delcommand " . self.get_ex_cmd_name()
  endif
endfunction

function! <SID>s:CtrlPExtension_show() dict
  if !(exists('g:speckle_mode'))
    call ctrlp#init(self.get_id())
  endif
endfunction

function! <SID>s:CtrlPExtension_do_init(...) dict
  if !(self.enabled)
    return []
  endif
  let self.inited = 1
  return self.agent.init()
endfunction

function! <SID>s:CtrlPExtension_do_accept(mode, str) dict
  if self.inited && !exists('g:speckle_mode')
    call ctrlp#exit()
    let self.inited = 0
  endif
  let result = self.agent.accept(a:mode, a:str)
  return result
endfunction

function! <SID>s:CtrlPExtension_do_enter(...) dict
  return self.agent.enter()
endfunction

function! <SID>s:CtrlPExtension_do_exit(...) dict
  return self.agent.exit()
endfunction

function! <SID>s:CtrlPExtension_do_opts(...) dict
  return self.agent.opts()
endfunction

function! <SID>s:CtrlPExtension_get_callback(method) dict
  let callback = self.new_callback(a:method)
  if !(a:method ==# 'accept')
    let callback = callback . "()"
  endif
  return callback
endfunction

function! <SID>s:CtrlPExtension_new_callback(method) dict
  let Callback = s:create_delegate(self, "do_" . a:method)
  return s:get_delegate_name(Callback)
endfunction

function! s:has_ctrlp_plugin()
  return exists('g:ctrlp_ext_vars')
endfunction

" included: 'trie.riml'
function! s:TrieConstructor()
  let trieObj = {}
  let trieObj.root = s:TrieNodeConstructor('root', {})
  let trieObj.root.is_root = 1
  let trieObj.add_word = function('<SNR>' . s:SID() . '_s:Trie_add_word')
  let trieObj.size = function('<SNR>' . s:SID() . '_s:Trie_size')
  let trieObj.sizeof = function('<SNR>' . s:SID() . '_s:Trie_sizeof')
  let trieObj.keys = function('<SNR>' . s:SID() . '_s:Trie_keys')
  let trieObj.keys_with_prefix = function('<SNR>' . s:SID() . '_s:Trie_keys_with_prefix')
  let trieObj.collect = function('<SNR>' . s:SID() . '_s:Trie_collect')
  let trieObj.get = function('<SNR>' . s:SID() . '_s:Trie_get')
  let trieObj.find = function('<SNR>' . s:SID() . '_s:Trie_find')
  let trieObj.find_distinct_prefixes = function('<SNR>' . s:SID() . '_s:Trie_find_distinct_prefixes')
  let trieObj.collect_prefix = function('<SNR>' . s:SID() . '_s:Trie_collect_prefix')
  let trieObj.print = function('<SNR>' . s:SID() . '_s:Trie_print')
  return trieObj
endfunction

function! <SID>s:Trie_add_word(str, ...) dict
  if len(a:000) ==# 1
    let src = a:000[0]
  else
    let src = 0
  endif
  let node = self.root
  let n = strlen(a:str)
  let i = 0
  while i <# n
    let char = a:str[i]
    if node.contains(char)
      let node = node.get_child(char)
    else
      let new_node = s:TrieNodeConstructor(char, src)
      call node.add_child(new_node)
      let node = new_node
    endif
    let i += 1
  endwhile
endfunction

function! <SID>s:Trie_size() dict
  return self.sizeof(self.root)
endfunction

function! <SID>s:Trie_sizeof(node) dict
  if !has_key(a:node, 'is_node')
    return 0
  endif
  if has_key(a:node, 'is_root')
    let total = 0
  else
    let total = 1
  endif
  let children = a:node.get_children()
  let n = len(children)
  if n ># 0
    for node in children
      let total += self.sizeof(node)
    endfor
  endif
  return total
endfunction

function! <SID>s:Trie_keys() dict
  return self.keys_with_prefix('')
endfunction

function! <SID>s:Trie_keys_with_prefix(prefix) dict
  let queue = []
  call self.collect(self.get(a:prefix), a:prefix, queue)
  return queue
endfunction

function! <SID>s:Trie_collect(node, prefix, queue) dict
  if !(has_key(a:node, 'is_node') && a:node.is_node)
    return
  endif
  if !(has_key(a:node, 'is_root'))
    call add(a:queue, a:prefix)
  endif
  let children = a:node.get_children()
  for child in children
    call self.collect(child, a:prefix . child.get_char(), a:queue)
  endfor
endfunction

function! <SID>s:Trie_get(prefix) dict
  let node = self.root
  let n = strlen(a:prefix)
  let i = 0
  while i <# n
    let char = a:prefix[i]
    if node.contains(char)
      let node = node.get_child(char)
    else
      return {'is_node': 0}
    endif
    let i += 1
  endwhile
  return node
endfunction

function! <SID>s:Trie_find(prefix) dict
  let node = self.get(a:prefix)
  return node.is_node
endfunction

function! <SID>s:Trie_find_distinct_prefixes() dict
  let collector = s:PrefixCollectorConstructor()
  call collector.accept_start()
  call self.collect_prefix(collector)
  call collector.accept_end()
  return collector.get_prefixes()
endfunction

function! <SID>s:Trie_collect_prefix(collector) dict
  call a:collector.accept_start_frame()
  let children = values(self.root.children)
  for node in children
    call a:collector.accept_start_frame()
    call node.collect_prefix(a:collector)
    call a:collector.accept_end_frame()
  endfor
  call a:collector.accept_end_frame()
endfunction

function! <SID>s:Trie_print() dict
  call self.root.print(0, 0)
endfunction

function! s:TrieNodeConstructor(char, source)
  let trieNodeObj = {}
  let trieNodeObj.char = a:char
  let trieNodeObj.source = a:source
  let trieNodeObj.children = {}
  let trieNodeObj.terminal = 1
  let trieNodeObj.is_node = 1
  let trieNodeObj.add_child = function('<SNR>' . s:SID() . '_s:TrieNode_add_child')
  let trieNodeObj.remove_child = function('<SNR>' . s:SID() . '_s:TrieNode_remove_child')
  let trieNodeObj.collect_prefix = function('<SNR>' . s:SID() . '_s:TrieNode_collect_prefix')
  let trieNodeObj.get_children = function('<SNR>' . s:SID() . '_s:TrieNode_get_children')
  let trieNodeObj.contains = function('<SNR>' . s:SID() . '_s:TrieNode_contains')
  let trieNodeObj.get_char = function('<SNR>' . s:SID() . '_s:TrieNode_get_char')
  let trieNodeObj.set_char = function('<SNR>' . s:SID() . '_s:TrieNode_set_char')
  let trieNodeObj.get_child = function('<SNR>' . s:SID() . '_s:TrieNode_get_child')
  let trieNodeObj.get_source = function('<SNR>' . s:SID() . '_s:TrieNode_get_source')
  let trieNodeObj.get_total_children = function('<SNR>' . s:SID() . '_s:TrieNode_get_total_children')
  let trieNodeObj.has_child = function('<SNR>' . s:SID() . '_s:TrieNode_has_child')
  let trieNodeObj.has_fork = function('<SNR>' . s:SID() . '_s:TrieNode_has_fork')
  let trieNodeObj.print = function('<SNR>' . s:SID() . '_s:TrieNode_print')
  let trieNodeObj.print_str = function('<SNR>' . s:SID() . '_s:TrieNode_print_str')
  return trieNodeObj
endfunction

function! <SID>s:TrieNode_add_child(node) dict
  let char = a:node.get_char()
  if self.contains(char)
    return 0
  else
    let self.children[char] = a:node
    let self.terminal = 0
    return 1
  endif
endfunction

function! <SID>s:TrieNode_remove_child(char) dict
  unlet self.children[a:char]
  if len(self.children) ==# 0
    let self.terminal = 1
  endif
endfunction

function! <SID>s:TrieNode_collect_prefix(collector) dict
  call a:collector.accept_push(self.get_char(), self.source)
  let children = self.get_children()
  let n = len(children)
  if n >=# 2
    for node in children
      call a:collector.accept_start_frame()
      call node.collect_prefix(a:collector)
      call a:collector.accept_end_frame()
    endfor
  elseif n ==# 1
    let node = children[0]
    call node.collect_prefix(a:collector)
  endif
endfunction

function! <SID>s:TrieNode_get_children() dict
  return values(self.children)
endfunction

function! <SID>s:TrieNode_contains(char) dict
  return has_key(self.children, a:char)
endfunction

function! <SID>s:TrieNode_get_char() dict
  return self.char
endfunction

function! <SID>s:TrieNode_set_char(char) dict
  let self.char = a:char
endfunction

function! <SID>s:TrieNode_get_child(char) dict
  return self.children[a:char]
endfunction

function! <SID>s:TrieNode_get_source() dict
  return self.source
endfunction

function! <SID>s:TrieNode_get_total_children() dict
  return len(self.children)
endfunction

function! <SID>s:TrieNode_has_child() dict
  return self.terminal
endfunction

function! <SID>s:TrieNode_has_fork() dict
  return len(self.children) >=# 2
endfunction

function! <SID>s:TrieNode_print(indent, last) dict
  let indent_count = a:indent
  if a:last
    call self.print_str("\\-" . self.get_char(), indent_count)
  else
    call self.print_str("|-" . self.get_char(), indent_count)
    let indent_count += 1
  endif
  let i = 0
  let children = values(self.children)
  let n = len(self.children)
  let last_child = n - 1
  for child in children
    call child.print(indent_count + 1, i ==# last_child)
    let i += 1
  endfor
endfunction

function! <SID>s:TrieNode_print_str(str, indent) dict
  let indent_str = repeat(' ', a:indent)
  call s:info(indent_str . a:str)
endfunction

function! s:PrefixConstructor(value, source)
  let prefixObj = {}
  let prefixObj.value = a:value
  let prefixObj.source = a:source
  return prefixObj
endfunction

function! s:PrefixCollectorConstructor()
  let prefixCollectorObj = {}
  let prefixCollectorObj.stack = s:StackConstructor()
  let prefixCollectorObj.prefixes = []
  let prefixCollectorObj.current_frame = {'is_frame': 0}
  let prefixCollectorObj.accept_start = function('<SNR>' . s:SID() . '_s:PrefixCollector_accept_start')
  let prefixCollectorObj.accept_end = function('<SNR>' . s:SID() . '_s:PrefixCollector_accept_end')
  let prefixCollectorObj.accept_start_frame = function('<SNR>' . s:SID() . '_s:PrefixCollector_accept_start_frame')
  let prefixCollectorObj.accept_push = function('<SNR>' . s:SID() . '_s:PrefixCollector_accept_push')
  let prefixCollectorObj.accept_end_frame = function('<SNR>' . s:SID() . '_s:PrefixCollector_accept_end_frame')
  let prefixCollectorObj.improve_collection = function('<SNR>' . s:SID() . '_s:PrefixCollector_improve_collection')
  let prefixCollectorObj.get_prefixes = function('<SNR>' . s:SID() . '_s:PrefixCollector_get_prefixes')
  let prefixCollectorObj.add_prefix = function('<SNR>' . s:SID() . '_s:PrefixCollector_add_prefix')
  let prefixCollectorObj.print_prefixes = function('<SNR>' . s:SID() . '_s:PrefixCollector_print_prefixes')
  return prefixCollectorObj
endfunction

function! <SID>s:PrefixCollector_accept_start() dict
endfunction

function! <SID>s:PrefixCollector_accept_end() dict
  call self.improve_collection()
endfunction

function! <SID>s:PrefixCollector_accept_start_frame() dict
  if self.current_frame.is_frame
    call self.current_frame.set_nesting(1)
    let current_prefix = self.current_frame.get_chars()
    call self.stack.push(self.current_frame)
  else
    let current_prefix = ''
  endif
  let self.current_frame = s:StackFrameConstructor(current_prefix)
endfunction

function! <SID>s:PrefixCollector_accept_push(char, source) dict
  call self.current_frame.append(a:char)
  call self.current_frame.set_source(a:source)
endfunction

function! <SID>s:PrefixCollector_accept_end_frame() dict
  if !(self.current_frame.get_nesting())
    call self.add_prefix(self.current_frame.get_prefix(), self.current_frame.get_source())
  endif
  if !self.stack.is_empty()
    let self.current_frame = self.stack.pop()
  else
    let self.current_frame = {'is_frame': 0}
  endif
endfunction

function! <SID>s:PrefixCollector_improve_collection() dict
  let prefix_values = {}
  for prefix in self.prefixes
    let prefix_values[prefix.value] = 1
  endfor
  for prefix in self.prefixes
    let prefix_value = prefix.value
    let len_prefix_value = len(prefix_value)
    if len_prefix_value ># 2
      let last_char = prefix_value[len_prefix_value - 1]
      let new_prefix = prefix_value[0] . last_char
      if !(has_key(prefix_values, new_prefix))
        let prefix_values[new_prefix] = 1
        let prefix.value = new_prefix
      endif
    endif
  endfor
endfunction

function! <SID>s:PrefixCollector_get_prefixes() dict
  return self.prefixes
endfunction

function! <SID>s:PrefixCollector_add_prefix(value, source) dict
  let prefix = s:PrefixConstructor(a:value, a:source)
  call add(self.prefixes, prefix)
endfunction

function! <SID>s:PrefixCollector_print_prefixes() dict
  for prefix in self.prefixes
    call s:info(prefix.value . " - " . prefix.source)
  endfor
endfunction

function! s:StackConstructor()
  let stackObj = {}
  let stackObj.frames = []
  let stackObj.push = function('<SNR>' . s:SID() . '_s:Stack_push')
  let stackObj.pop = function('<SNR>' . s:SID() . '_s:Stack_pop')
  let stackObj.is_empty = function('<SNR>' . s:SID() . '_s:Stack_is_empty')
  return stackObj
endfunction

function! <SID>s:Stack_push(frame) dict
  call add(self.frames, a:frame)
endfunction

function! <SID>s:Stack_pop() dict
  return remove(self.frames, -1)
endfunction

function! <SID>s:Stack_is_empty() dict
  return len(self.frames) ==# 0
endfunction

function! s:StackFrameConstructor(start)
  let stackFrameObj = {}
  let stackFrameObj.start = a:start
  let stackFrameObj.chars = a:start
  let stackFrameObj.prefix = ''
  let stackFrameObj.is_frame = 1
  let stackFrameObj.nesting = 0
  let stackFrameObj.source = {'is_null': 1}
  let stackFrameObj.set_source = function('<SNR>' . s:SID() . '_s:StackFrame_set_source')
  let stackFrameObj.get_source = function('<SNR>' . s:SID() . '_s:StackFrame_get_source')
  let stackFrameObj.append = function('<SNR>' . s:SID() . '_s:StackFrame_append')
  let stackFrameObj.set_nesting = function('<SNR>' . s:SID() . '_s:StackFrame_set_nesting')
  let stackFrameObj.get_nesting = function('<SNR>' . s:SID() . '_s:StackFrame_get_nesting')
  let stackFrameObj.get_prefix = function('<SNR>' . s:SID() . '_s:StackFrame_get_prefix')
  let stackFrameObj.get_chars = function('<SNR>' . s:SID() . '_s:StackFrame_get_chars')
  return stackFrameObj
endfunction

function! <SID>s:StackFrame_set_source(source) dict
  let self.source = a:source
endfunction

function! <SID>s:StackFrame_get_source() dict
  return self.source
endfunction

function! <SID>s:StackFrame_append(chars) dict
  if self.prefix ==# ''
    let self.prefix = a:chars[0]
  endif
  let self.chars = self.chars . a:chars
endfunction

function! <SID>s:StackFrame_set_nesting(nesting) dict
  let self.nesting = a:nesting
endfunction

function! <SID>s:StackFrame_get_nesting() dict
  return self.nesting
endfunction

function! <SID>s:StackFrame_get_prefix() dict
  return self.start . self.prefix
endfunction

function! <SID>s:StackFrame_get_chars() dict
  return self.chars
endfunction

" included: 'container.riml'
function! s:ContainerConstructor(parent)
  let containerObj = {}
  let containerObj.is_container = 1
  let containerObj.parent = a:parent
  let containerObj.objects = {}
  let containerObj.register = function('<SNR>' . s:SID() . '_s:Container_register')
  let containerObj.unregister = function('<SNR>' . s:SID() . '_s:Container_unregister')
  let containerObj.lookup = function('<SNR>' . s:SID() . '_s:Container_lookup')
  let containerObj.has = function('<SNR>' . s:SID() . '_s:Container_has')
  let containerObj.has_parent = function('<SNR>' . s:SID() . '_s:Container_has_parent')
  let containerObj.inject = function('<SNR>' . s:SID() . '_s:Container_inject')
  let containerObj.child = function('<SNR>' . s:SID() . '_s:Container_child')
  let containerObj.get_parent = function('<SNR>' . s:SID() . '_s:Container_get_parent')
  return containerObj
endfunction

function! <SID>s:Container_register(name, classname, ...) dict
  if len(a:000) ==# 0
    let singleton = 0
  else
    let singleton = a:000[0]
  endif
  if type(a:classname) ==# type('')
    let object = s:ContainerObjectConstructor(a:classname, singleton)
  else
    let object = s:ContainerObjectConstructor('ExistingObject', 1)
    call object.set_instance(a:classname)
  endif
  let self.objects[a:name] = object
endfunction

function! <SID>s:Container_unregister(name, from_parent) dict
  if has_key(self.objects, a:name)
    unlet self.objects[a:name]
  endif
  if a:from_parent && self.has_parent()
    call self.parent.unregister(a:name, a:from_parent)
  endif
endfunction

function! <SID>s:Container_lookup(name) dict
  if has_key(self.objects, a:name)
    let object = self.objects[a:name]
    let instance = object.get_instance()
    call self.inject(instance)
    return instance
  elseif self.has_parent()
    return self.parent.lookup(a:name)
  else
    throw "Container object not found: " . a:name
  endif
endfunction

function! <SID>s:Container_has(name) dict
  return has_key(self.objects, a:name) || (self.has_parent() && self.parent.has(a:name))
endfunction

function! <SID>s:Container_has_parent() dict
  return has_key(self.parent, 'is_container')
endfunction

function! <SID>s:Container_inject(instance) dict
  if type(a:instance) !=# type({}) || has_key(a:instance, 'container')
    return
  endif
  if has_key(a:instance, 'needs')
    let needs = a:instance.needs()
    for need in needs
      let dependency = self.lookup(need)
      let a:instance[need] = dependency
    endfor
  endif
  let a:instance['container'] = self
  if has_key(a:instance, 'on_inject')
    call a:instance.on_inject()
  endif
endfunction

function! <SID>s:Container_child() dict
  return s:ContainerConstructor(self)
endfunction

function! <SID>s:Container_get_parent() dict
  return self.parent
endfunction

function! s:ContainerObjectConstructor(classname, singleton)
  let containerObjectObj = {}
  let containerObjectObj.classname = a:classname
  let containerObjectObj.singleton = a:singleton
  let containerObjectObj.is_container_object = 1
  let containerObjectObj.get_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_get_instance')
  let containerObjectObj.set_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_set_instance')
  let containerObjectObj.instantiated = function('<SNR>' . s:SID() . '_s:ContainerObject_instantiated')
  let containerObjectObj.needs_new_instance = function('<SNR>' . s:SID() . '_s:ContainerObject_needs_new_instance')
  let containerObjectObj.create = function('<SNR>' . s:SID() . '_s:ContainerObject_create')
  return containerObjectObj
endfunction

function! <SID>s:ContainerObject_get_instance() dict
  if self.needs_new_instance()
    let Klass = function("s:" . self.classname . "Constructor")
    let self.instance_object = self.create(Klass)
  endif
  return self.instance_object
endfunction

function! <SID>s:ContainerObject_set_instance(instance) dict
  let self.instance_object = a:instance
endfunction

function! <SID>s:ContainerObject_instantiated() dict
  return has_key(self, 'instance_object')
endfunction

function! <SID>s:ContainerObject_needs_new_instance() dict
  return !self.instantiated() || !self.singleton
endfunction

function! <SID>s:ContainerObject_create(Klass) dict
  return a:Klass()
endfunction

" included: 'token.riml'
function! s:TokenConstructor(type, value)
  let tokenObj = {}
  let tokenObj.type = a:type
  let tokenObj.value = a:value
  return tokenObj
endfunction

function! s:load_token_types()
  let token_types = []
  call add(token_types, 'itemError')
  call add(token_types, 'itemModifier')
  call add(token_types, 'itemPlaceholder')
  call add(token_types, 'itemWhitespace')
  call add(token_types, 'itemFilter')
  call add(token_types, 'itemText')
  call add(token_types, 'itemTab')
  call add(token_types, 'itemNewline')
  call add(token_types, 'itemEOF')
  let i = 0
  for token_type in token_types
    execute "let s:" . token_type . " = " . i
    let i += 1
  endfor
  let s:token_types = token_types
endfunction

function! s:get_token_name(index)
  return s:token_types[a:index]
endfunction

function! s:get_token_id(name)
  return index(s:token_types, a:name)
endfunction

call s:load_token_types()
" included: 'lexer_states.riml'
let s:charBackslash = '\'
let s:charsAlphaLower = 'abcdefghijklmnopqrstuvwxyz'
let s:charsAlphaUpper = toupper(s:charsAlphaLower)
let s:charsAlpha = s:charsAlphaLower . s:charsAlphaUpper
let s:charsWhitespace = " \t"
let s:charsKeyword = s:charsAlpha . "_"
function! s:LexNullConstructor()
  let lexNullObj = {}
  let lexNullObj.is_null = 1
  let lexNullObj.scan = function('<SNR>' . s:SID() . '_s:LexNull_scan')
  return lexNullObj
endfunction

function! <SID>s:LexNull_scan(lexer) dict
endfunction

function! s:LexTextConstructor()
  let lexTextObj = {}
  let lexTextObj.scan = function('<SNR>' . s:SID() . '_s:LexText_scan')
  return lexTextObj
endfunction

function! <SID>s:LexText_scan(lexer) dict
  while 1
    let rune = a:lexer.peek()
    if rune ==# '%'
      call a:lexer.emit_text()
      call a:lexer.next()
      return 'LexInsideModifier'
    elseif rune ==# s:charBackslash
      call a:lexer.emit_text()
      call a:lexer.next()
      return 'LexInsideEscape'
    endif
    if a:lexer.next() ==# 'EOF'
      break
    endif
  endwhile
  call a:lexer.emit_text()
  call a:lexer.emit(s:itemEOF)
  return 'LexNull'
endfunction

function! s:LexInsideModifierConstructor()
  let lexInsideModifierObj = {}
  let lexInsideModifierObj.scan = function('<SNR>' . s:SID() . '_s:LexInsideModifier_scan')
  return lexInsideModifierObj
endfunction

function! <SID>s:LexInsideModifier_scan(lexer) dict
  let rune = a:lexer.peek()
  if rune ==# '%'
    call a:lexer.emit_text()
    call a:lexer.advance()
    return 'LexText'
  elseif rune ==# ' ' || rune ==# 'EOF'
    call a:lexer.emit(s:itemModifier)
    return 'LexText'
  elseif rune ==# '{'
    call a:lexer.next()
    return 'LexLeftDelim'
  else
    call a:lexer.ignore()
    call a:lexer.accept(s:charsAlpha)
    call a:lexer.emit(s:itemModifier)
    return 'LexText'
  endif
endfunction

function! s:LexLeftDelimConstructor()
  let lexLeftDelimObj = {}
  let lexLeftDelimObj.scan = function('<SNR>' . s:SID() . '_s:LexLeftDelim_scan')
  return lexLeftDelimObj
endfunction

function! <SID>s:LexLeftDelim_scan(lexer) dict
  call a:lexer.ignore()
  call a:lexer.ignore_whitespace()
  return 'LexInsidePlaceholder'
endfunction

function! s:LexRightDelimConstructor()
  let lexRightDelimObj = {}
  let lexRightDelimObj.scan = function('<SNR>' . s:SID() . '_s:LexRightDelim_scan')
  return lexRightDelimObj
endfunction

function! <SID>s:LexRightDelim_scan(lexer) dict
  call a:lexer.ignore()
  return 'LexText'
endfunction

function! s:LexInsidePlaceholderConstructor()
  let lexInsidePlaceholderObj = {}
  let lexInsidePlaceholderObj.scan = function('<SNR>' . s:SID() . '_s:LexInsidePlaceholder_scan')
  return lexInsidePlaceholderObj
endfunction

function! <SID>s:LexInsidePlaceholder_scan(lexer) dict
  let rune = a:lexer.peek()
  if rune ==# '}'
    call a:lexer.backup()
    if a:lexer.peek() ==# '{'
      call a:lexer.error("Empty placeholder / filter name")
    else
      call a:lexer.next()
    endif
    call a:lexer.next()
    return 'LexRightDelim'
  else
    return "LexInsidePlaceholderName"
  endif
endfunction

function! s:LexInsidePlaceholderNameConstructor()
  let lexInsidePlaceholderNameObj = {}
  let lexInsidePlaceholderNameObj.scan = function('<SNR>' . s:SID() . '_s:LexInsidePlaceholderName_scan')
  return lexInsidePlaceholderNameObj
endfunction

function! <SID>s:LexInsidePlaceholderName_scan(lexer) dict
  call a:lexer.ignore_whitespace()
  call a:lexer.accept_keyword()
  if !(a:lexer.is_ahead())
    call a:lexer.error("Expected placeholder name after '{' ")
    return 'LexNull'
  endif
  call a:lexer.emit(s:itemPlaceholder)
  call a:lexer.ignore_whitespace()
  let rune = a:lexer.peek()
  if rune ==# '|'
    call a:lexer.next()
    return 'LexInsideFilter'
  elseif rune ==# 'EOF'
    call a:lexer.error("Expected a closing '}' before EOF ")
  else
    return 'LexInsidePlaceholder'
  endif
endfunction

function! s:LexInsideFilterConstructor()
  let lexInsideFilterObj = {}
  let lexInsideFilterObj.scan = function('<SNR>' . s:SID() . '_s:LexInsideFilter_scan')
  return lexInsideFilterObj
endfunction

function! <SID>s:LexInsideFilter_scan(lexer) dict
  let rune = a:lexer.peek()
  call a:lexer.ignore_whitespace()
  if rune ==# '}'
    call a:lexer.next()
    return 'LexRightDelim'
  else
    call a:lexer.ignore()
    return 'LexInsideFilterChain'
  endif
endfunction

function! s:LexInsideFilterChainConstructor()
  let lexInsideFilterChainObj = {}
  let lexInsideFilterChainObj.scan = function('<SNR>' . s:SID() . '_s:LexInsideFilterChain_scan')
  return lexInsideFilterChainObj
endfunction

function! <SID>s:LexInsideFilterChain_scan(lexer) dict
  call a:lexer.ignore_whitespace()
  call a:lexer.accept_keyword()
  if !(a:lexer.is_ahead())
    call a:lexer.error("Expected filter name after | ")
    return 'LexNull'
  endif
  call a:lexer.emit(s:itemFilter)
  call a:lexer.ignore_whitespace()
  let rune = a:lexer.peek()
  if rune ==# '|'
    call a:lexer.advance()
    return 'LexInsideFilterChain'
  else
    return 'LexInsideFilter'
  endif
endfunction

function! s:LexInsideEscapeConstructor()
  let lexInsideEscapeObj = {}
  let lexInsideEscapeObj.scan = function('<SNR>' . s:SID() . '_s:LexInsideEscape_scan')
  return lexInsideEscapeObj
endfunction

function! <SID>s:LexInsideEscape_scan(lexer) dict
  let rune = a:lexer.peek()
  if rune ==# 'n' || rune ==# 'r'
    call a:lexer.advance()
    call a:lexer.emit(s:itemNewline)
  elseif rune ==# 't'
    call a:lexer.advance()
    call a:lexer.emit(s:itemTab)
  elseif rune ==# s:charBackslash
    call a:lexer.advance()
  endif
  return 'LexText'
endfunction

function! s:LexStateFactoryConstructor()
  let lexStateFactoryObj = {}
  let s = {}
  let s.LexNull = s:LexNullConstructor()
  let s.LexText = s:LexTextConstructor()
  let s.LexLeftDelim = s:LexLeftDelimConstructor()
  let s.LexRightDelim = s:LexRightDelimConstructor()
  let s.LexInsideModifier = s:LexInsideModifierConstructor()
  let s.LexInsidePlaceholder = s:LexInsidePlaceholderConstructor()
  let s.LexInsidePlaceholderName = s:LexInsidePlaceholderNameConstructor()
  let s.LexInsideEscape = s:LexInsideEscapeConstructor()
  let s.LexInsideFilter = s:LexInsideFilterConstructor()
  let s.LexInsideFilterChain = s:LexInsideFilterChainConstructor()
  let lexStateFactoryObj.states = s
  let lexStateFactoryObj.get_state = function('<SNR>' . s:SID() . '_s:LexStateFactory_get_state')
  return lexStateFactoryObj
endfunction

function! <SID>s:LexStateFactory_get_state(name) dict
  return self.states[a:name]
endfunction

function! s:get_lex_state(name)
  if !(exists('s:lexStateFactory'))
    let s:lexStateFactory = s:LexStateFactoryConstructor()
  endif
  return s:lexStateFactory.get_state(a:name)
endfunction

" included: 'lexer.riml'
function! s:LexerConstructor()
  let lexerObj = {}
  let lexerObj.next = function('<SNR>' . s:SID() . '_s:Lexer_next')
  let lexerObj.backup = function('<SNR>' . s:SID() . '_s:Lexer_backup')
  let lexerObj.peek = function('<SNR>' . s:SID() . '_s:Lexer_peek')
  let lexerObj.ignore = function('<SNR>' . s:SID() . '_s:Lexer_ignore')
  let lexerObj.ignore_whitespace = function('<SNR>' . s:SID() . '_s:Lexer_ignore_whitespace')
  let lexerObj.advance = function('<SNR>' . s:SID() . '_s:Lexer_advance')
  let lexerObj.accept = function('<SNR>' . s:SID() . '_s:Lexer_accept')
  let lexerObj.accept_run = function('<SNR>' . s:SID() . '_s:Lexer_accept_run')
  let lexerObj.accept_keyword = function('<SNR>' . s:SID() . '_s:Lexer_accept_keyword')
  let lexerObj.emit = function('<SNR>' . s:SID() . '_s:Lexer_emit')
  let lexerObj.emit_text = function('<SNR>' . s:SID() . '_s:Lexer_emit_text')
  let lexerObj.was_text_last_emitted = function('<SNR>' . s:SID() . '_s:Lexer_was_text_last_emitted')
  let lexerObj.scan = function('<SNR>' . s:SID() . '_s:Lexer_scan')
  let lexerObj.run = function('<SNR>' . s:SID() . '_s:Lexer_run')
  let lexerObj.is_state = function('<SNR>' . s:SID() . '_s:Lexer_is_state')
  let lexerObj.is_ahead = function('<SNR>' . s:SID() . '_s:Lexer_is_ahead')
  let lexerObj.is_whitespace = function('<SNR>' . s:SID() . '_s:Lexer_is_whitespace')
  let lexerObj.error = function('<SNR>' . s:SID() . '_s:Lexer_error')
  let lexerObj.print_cursor = function('<SNR>' . s:SID() . '_s:Lexer_print_cursor')
  let lexerObj.print_stream = function('<SNR>' . s:SID() . '_s:Lexer_print_stream')
  return lexerObj
endfunction

function! <SID>s:Lexer_next() dict
  if self.pos >=# self.length
    let self.width = 0
    return 'EOF'
  endif
  let rune = self.input[self.pos]
  let self.width = 1
  let self.pos += self.width
  return rune
endfunction

function! <SID>s:Lexer_backup() dict
  let self.pos -= self.width
endfunction

function! <SID>s:Lexer_peek() dict
  let rune = self.next()
  call self.backup()
  return rune
endfunction

function! <SID>s:Lexer_ignore() dict
  let self.start = self.pos
endfunction

function! <SID>s:Lexer_ignore_whitespace() dict
  if self.is_whitespace(self.peek())
    call self.accept_run(s:charsWhitespace)
    if self.is_ahead()
      let self.start = self.pos
    endif
  endif
endfunction

function! <SID>s:Lexer_advance() dict
  call self.next()
  call self.ignore()
endfunction

function! <SID>s:Lexer_accept(valid) dict
  let rune = self.next()
  let index = stridx(a:valid, rune)
  if index >=# 0
    return 1
  else
    call self.backup()
    return 0
  endif
endfunction

function! <SID>s:Lexer_accept_run(valid) dict
  while self.accept(a:valid)
  endwhile
endfunction

function! <SID>s:Lexer_accept_keyword() dict
  call self.accept_run(s:charsKeyword)
endfunction

function! <SID>s:Lexer_emit(token_type) dict
  let token_value = strpart(self.input, self.start, self.pos - self.start)
  let token = s:TokenConstructor(a:token_type, token_value)
  call add(self.stream, token)
  let self.start = self.pos
endfunction

function! <SID>s:Lexer_emit_text() dict
  if self.is_ahead()
    if self.was_text_last_emitted()
      let token_value = strpart(self.input, self.start, self.pos - self.start)
      let last_token = self.stream[-1]
      let last_token.value = last_token.value . token_value
      let self.start = self.pos
    else
      call self.emit(s:itemText)
    endif
  endif
endfunction

function! <SID>s:Lexer_was_text_last_emitted() dict
  if len(self.stream) ># 0
    let last_token = self.stream[-1]
    return last_token.type ==# s:itemText
  else
    return 0
  endif
endfunction

function! <SID>s:Lexer_scan(input) dict
  let self.input = a:input
  let self.start = 0
  let self.pos = 0
  let self.width = 0
  let self.length = len(a:input)
  let self.stream = []
  let self.last_token = {'type': -1}
  call self.run()
  return self.stream
endfunction

function! <SID>s:Lexer_run() dict
  let state = s:get_lex_state('LexText')
  while self.is_state(state)
    let state_name = state.scan(self)
    let state = s:get_lex_state(state_name)
  endwhile
endfunction

function! <SID>s:Lexer_is_state(state) dict
  return !has_key(a:state, 'is_null')
endfunction

function! <SID>s:Lexer_is_ahead() dict
  return self.pos ># self.start
endfunction

function! <SID>s:Lexer_is_whitespace(char) dict
  return a:char ==# ' ' || a:char ==# "\t"
endfunction

function! <SID>s:Lexer_error(msg) dict
  let str = strpart(self.input, 0, self.pos + 5)
  let msg = "LexicalError: " . a:msg . " for input: '" . str . "'"
  throw msg
endfunction

function! <SID>s:Lexer_print_cursor() dict
  let cursors = ''
  let index = 0
  while index <# self.length
    if index ==# self.start && index ==# self.pos
      let cursors .= 'V'
    elseif self.start ==# index
      let cursors .= '|'
    elseif self.pos ==# index
      let cursors .= 'v'
    else
      let cursors .= ' '
    endif
    let index += 1
  endwhile
  if self.pos >=# self.length
    let cursors .= 'v'
  endif
  call s:info(cursors)
  call s:info(self.input)
endfunction

function! <SID>s:Lexer_print_stream() dict
  let i = 0
  for token in self.stream
    call s:info(i . ": Token(" . s:get_token_name(token.type) . ", '" . token.value . "')")
    let i += 1
  endfor
endfunction

" included: 'filters.riml'
function! s:UppercaseFilterConstructor()
  let uppercaseFilterObj = {}
  let uppercaseFilterObj.filter = function('<SNR>' . s:SID() . '_s:UppercaseFilter_filter')
  return uppercaseFilterObj
endfunction

function! <SID>s:UppercaseFilter_filter(str) dict
  return toupper(a:str)
endfunction

function! s:LowercaseFilterConstructor()
  let lowercaseFilterObj = {}
  let lowercaseFilterObj.filter = function('<SNR>' . s:SID() . '_s:LowercaseFilter_filter')
  return lowercaseFilterObj
endfunction

function! <SID>s:LowercaseFilter_filter(str) dict
  return tolower(a:str)
endfunction

function! s:InflectorFilterConstructor()
  let inflectorFilterObj = {}
  let inflectorFilterObj.set_inflector = function('<SNR>' . s:SID() . '_s:InflectorFilter_set_inflector')
  return inflectorFilterObj
endfunction

function! <SID>s:InflectorFilter_set_inflector(inflector) dict
  let self.inflector = a:inflector
endfunction

function! s:PluralFilterConstructor()
  let pluralFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(pluralFilterObj, inflectorFilterObj)
  let pluralFilterObj.filter = function('<SNR>' . s:SID() . '_s:PluralFilter_filter')
  return pluralFilterObj
endfunction

function! <SID>s:PluralFilter_filter(str) dict
  return self.inflector.pluralize(a:str)
endfunction

function! s:SingularFilterConstructor()
  let singularFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(singularFilterObj, inflectorFilterObj)
  let singularFilterObj.filter = function('<SNR>' . s:SID() . '_s:SingularFilter_filter')
  return singularFilterObj
endfunction

function! <SID>s:SingularFilter_filter(str) dict
  return self.inflector.singularize(a:str)
endfunction

function! s:CamelcaseFilterConstructor()
  let camelcaseFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(camelcaseFilterObj, inflectorFilterObj)
  let camelcaseFilterObj.filter = function('<SNR>' . s:SID() . '_s:CamelcaseFilter_filter')
  return camelcaseFilterObj
endfunction

function! <SID>s:CamelcaseFilter_filter(str) dict
  return self.inflector.camelize(a:str)
endfunction

function! s:LowerCamelcaseFilterConstructor()
  let lowerCamelcaseFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(lowerCamelcaseFilterObj, inflectorFilterObj)
  let lowerCamelcaseFilterObj.filter = function('<SNR>' . s:SID() . '_s:LowerCamelcaseFilter_filter')
  return lowerCamelcaseFilterObj
endfunction

function! <SID>s:LowerCamelcaseFilter_filter(str) dict
  return self.inflector.lower_camelize(a:str)
endfunction

function! s:UnderscoreFilterConstructor()
  let underscoreFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(underscoreFilterObj, inflectorFilterObj)
  let underscoreFilterObj.filter = function('<SNR>' . s:SID() . '_s:UnderscoreFilter_filter')
  return underscoreFilterObj
endfunction

function! <SID>s:UnderscoreFilter_filter(str) dict
  return self.inflector.underscorize(a:str)
endfunction

function! s:HumanFilterConstructor()
  let humanFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(humanFilterObj, inflectorFilterObj)
  let humanFilterObj.filter = function('<SNR>' . s:SID() . '_s:HumanFilter_filter')
  return humanFilterObj
endfunction

function! <SID>s:HumanFilter_filter(str) dict
  return self.inflector.humanize(a:str)
endfunction

function! s:DashFilterConstructor()
  let dashFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(dashFilterObj, inflectorFilterObj)
  let dashFilterObj.filter = function('<SNR>' . s:SID() . '_s:DashFilter_filter')
  return dashFilterObj
endfunction

function! <SID>s:DashFilter_filter(str) dict
  return self.inflector.dasherize(a:str)
endfunction

function! s:TitleFilterConstructor()
  let titleFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(titleFilterObj, inflectorFilterObj)
  let titleFilterObj.filter = function('<SNR>' . s:SID() . '_s:TitleFilter_filter')
  return titleFilterObj
endfunction

function! <SID>s:TitleFilter_filter(str) dict
  return self.inflector.titleize(a:str)
endfunction

function! s:TableFilterConstructor()
  let tableFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(tableFilterObj, inflectorFilterObj)
  let tableFilterObj.filter = function('<SNR>' . s:SID() . '_s:TableFilter_filter')
  return tableFilterObj
endfunction

function! <SID>s:TableFilter_filter(str) dict
  return self.inflector.tableize(a:str)
endfunction

function! s:ClassFilterConstructor()
  let classFilterObj = {}
  let inflectorFilterObj = s:InflectorFilterConstructor()
  call extend(classFilterObj, inflectorFilterObj)
  let classFilterObj.filter = function('<SNR>' . s:SID() . '_s:ClassFilter_filter')
  return classFilterObj
endfunction

function! <SID>s:ClassFilter_filter(str) dict
  return self.inflector.classify(a:str)
endfunction

" included: 'filter_factory.riml'
function! s:BaseFilterFactoryConstructor()
  let baseFilterFactoryObj = {}
  let baseFilterFactoryObj.filters = {}
  let baseFilterFactoryObj.needs = function('<SNR>' . s:SID() . '_s:BaseFilterFactory_needs')
  let baseFilterFactoryObj.has_filter = function('<SNR>' . s:SID() . '_s:BaseFilterFactory_has_filter')
  let baseFilterFactoryObj.add_filter = function('<SNR>' . s:SID() . '_s:BaseFilterFactory_add_filter')
  let baseFilterFactoryObj.get_filter = function('<SNR>' . s:SID() . '_s:BaseFilterFactory_get_filter')
  let baseFilterFactoryObj.configure_filter = function('<SNR>' . s:SID() . '_s:BaseFilterFactory_configure_filter')
  return baseFilterFactoryObj
endfunction

function! <SID>s:BaseFilterFactory_needs() dict
  return ['inflector']
endfunction

function! <SID>s:BaseFilterFactory_has_filter(name) dict
  return has_key(self.filters, a:name)
endfunction

function! <SID>s:BaseFilterFactory_add_filter(name, filter) dict
  let self.filters[a:name] = a:filter
  call self.configure_filter(a:filter)
endfunction

function! <SID>s:BaseFilterFactory_get_filter(name) dict
  return self.filters[a:name]
endfunction

function! <SID>s:BaseFilterFactory_configure_filter(filter) dict
  if has_key(self, 'inflector') && has_key(a:filter, 'set_inflector')
    call a:filter.set_inflector(self.inflector)
  endif
endfunction

function! s:FilterFactoryConstructor()
  let filterFactoryObj = {}
  let baseFilterFactoryObj = s:BaseFilterFactoryConstructor()
  call extend(filterFactoryObj, baseFilterFactoryObj)
  let filterFactoryObj.on_inject = function('<SNR>' . s:SID() . '_s:FilterFactory_on_inject')
  let filterFactoryObj.load_defaults = function('<SNR>' . s:SID() . '_s:FilterFactory_load_defaults')
  return filterFactoryObj
endfunction

function! <SID>s:FilterFactory_on_inject() dict
  call self.load_defaults()
endfunction

function! <SID>s:FilterFactory_load_defaults() dict
  call self.add_filter('upper', s:UppercaseFilterConstructor())
  call self.add_filter('lower', s:LowercaseFilterConstructor())
  call self.add_filter('plural', s:PluralFilterConstructor())
  call self.add_filter('singular', s:SingularFilterConstructor())
  call self.add_filter('camel', s:CamelcaseFilterConstructor())
  call self.add_filter('lcamel', s:LowerCamelcaseFilterConstructor())
  call self.add_filter('underscore', s:UnderscoreFilterConstructor())
  call self.add_filter('human', s:HumanFilterConstructor())
  call self.add_filter('dash', s:DashFilterConstructor())
  call self.add_filter('title', s:TitleFilterConstructor())
  call self.add_filter('table', s:TableFilterConstructor())
  call self.add_filter('class', s:ClassFilterConstructor())
endfunction

" included: 'objects.riml'
function! s:TemplateObjectConstructor()
  let templateObjectObj = {}
  let templateObjectObj.is_template = 1
  let templateObjectObj.objects = []
  let templateObjectObj.append = function('<SNR>' . s:SID() . '_s:TemplateObject_append')
  let templateObjectObj.render = function('<SNR>' . s:SID() . '_s:TemplateObject_render')
  return templateObjectObj
endfunction

function! <SID>s:TemplateObject_append(object) dict
  call add(self.objects, a:object)
endfunction

function! <SID>s:TemplateObject_render(context) dict
  let str = ''
  for object in self.objects
    let str .= object.render(a:context)
  endfor
  return str
endfunction

function! s:TextObjectConstructor(text)
  let textObjectObj = {}
  let textObjectObj.is_text = 1
  let textObjectObj.text = a:text
  let textObjectObj.render = function('<SNR>' . s:SID() . '_s:TextObject_render')
  return textObjectObj
endfunction

function! <SID>s:TextObject_render(context) dict
  return self.text
endfunction

function! s:PlaceholderObjectConstructor(name)
  let placeholderObjectObj = {}
  let placeholderObjectObj.is_placeholder = 1
  let placeholderObjectObj.name = a:name
  let placeholderObjectObj.filters = []
  let placeholderObjectObj.set_filter_factory = function('<SNR>' . s:SID() . '_s:PlaceholderObject_set_filter_factory')
  let placeholderObjectObj.add_filter = function('<SNR>' . s:SID() . '_s:PlaceholderObject_add_filter')
  let placeholderObjectObj.filter = function('<SNR>' . s:SID() . '_s:PlaceholderObject_filter')
  let placeholderObjectObj.render = function('<SNR>' . s:SID() . '_s:PlaceholderObject_render')
  return placeholderObjectObj
endfunction

function! <SID>s:PlaceholderObject_set_filter_factory(factory) dict
  let self.filter_factory = a:factory
endfunction

function! <SID>s:PlaceholderObject_add_filter(filter_name) dict
  call add(self.filters, a:filter_name)
endfunction

function! <SID>s:PlaceholderObject_filter(filter_name, str) dict
  if !(self.filter_factory.has_filter(a:filter_name))
    call s:echo_warn("Warning: Failed to find filter named '" . a:filter_name . "' for placeholder: '" . self.name . "'")
    return a:str
  endif
  let instance = self.filter_factory.get_filter(a:filter_name)
  return instance.filter(a:str)
endfunction

function! <SID>s:PlaceholderObject_render(context) dict
  let str = a:context.lookup(self.name)
  for filter_name in self.filters
    let str = self.filter(filter_name, str)
  endfor
  return str
endfunction

function! s:NewlineObjectConstructor()
  let newlineObjectObj = {}
  let newlineObjectObj.is_newline = 1
  let newlineObjectObj.render = function('<SNR>' . s:SID() . '_s:NewlineObject_render')
  return newlineObjectObj
endfunction

function! <SID>s:NewlineObject_render(context) dict
  return "\n"
endfunction

function! s:TabObjectConstructor()
  let tabObjectObj = {}
  let tabObjectObj.is_tab = 1
  let tabObjectObj.render = function('<SNR>' . s:SID() . '_s:TabObject_render')
  return tabObjectObj
endfunction

function! <SID>s:TabObject_render(context) dict
  if &expandtab
    return repeat(' ', &tabstop)
  else
    return "\t"
  endif
endfunction

" included: 'compiler.riml'
function! s:CompilerConstructor()
  let compilerObj = {}
  let compilerObj.newline_object = s:NewlineObjectConstructor()
  let compilerObj.tab_object = s:TabObjectConstructor()
  let compilerObj.needs = function('<SNR>' . s:SID() . '_s:Compiler_needs')
  let compilerObj.get_object = function('<SNR>' . s:SID() . '_s:Compiler_get_object')
  let compilerObj.get_key_name_for_modifier = function('<SNR>' . s:SID() . '_s:Compiler_get_key_name_for_modifier')
  let compilerObj.get_filter_for_modifier = function('<SNR>' . s:SID() . '_s:Compiler_get_filter_for_modifier')
  let compilerObj.is_placeholder = function('<SNR>' . s:SID() . '_s:Compiler_is_placeholder')
  let compilerObj.is_filter = function('<SNR>' . s:SID() . '_s:Compiler_is_filter')
  let compilerObj.is_eof = function('<SNR>' . s:SID() . '_s:Compiler_is_eof')
  let compilerObj.is_visible = function('<SNR>' . s:SID() . '_s:Compiler_is_visible')
  let compilerObj.compile = function('<SNR>' . s:SID() . '_s:Compiler_compile')
  return compilerObj
endfunction

function! <SID>s:Compiler_needs() dict
  return ['filter_factory']
endfunction

function! <SID>s:Compiler_get_object(token) dict
  let token_type = a:token.type
  if token_type ==# s:itemText
    return s:TextObjectConstructor(a:token.value)
  elseif token_type ==# s:itemPlaceholder
    let placeholder = s:PlaceholderObjectConstructor(a:token.value)
    call placeholder.set_filter_factory(self.filter_factory)
    return placeholder
  elseif token_type ==# s:itemModifier
    let key_name = self.get_key_name_for_modifier(a:token.value)
    let placeholder = s:PlaceholderObjectConstructor(key_name)
    let filter = self.get_filter_for_modifier(a:token.value)
    if filter !=# 'null'
      call placeholder.add_filter(filter)
    endif
    call placeholder.set_filter_factory(self.filter_factory)
    return placeholder
  elseif token_type ==# s:itemFilter
    return {'is_filter': 1}
  elseif token_type ==# s:itemNewline
    return self.newline_object
  elseif token_type ==# s:itemTab
    return self.tab_object
  elseif token_type ==# s:itemEOF
    return {'is_eof': 1}
  else
    throw "CompilerError: Unknown Token, type=" . a:token.type . ", value=" . a:token.value
  endif
endfunction

function! <SID>s:Compiler_get_key_name_for_modifier(modifier) dict
  if a:modifier ==# 's'
    return 'source'
  elseif a:modifier ==# '%'
    return 'source_path'
  elseif a:modifier ==# 'd'
    return 'tag'
  elseif a:modifier ==# 'l'
    return 'line'
  else
    return 'source'
  endif
endfunction

function! <SID>s:Compiler_get_filter_for_modifier(modifier) dict
  if a:modifier ==# 's' || a:modifier ==# '%'
    return 'null'
  elseif a:modifier ==# 'S'
    return 'camel'
  elseif a:modifier ==# 'p'
    return 'plural'
  elseif a:modifier ==# 'i'
    return 'singular'
  elseif a:modifier ==# 'h'
    return 'human'
  else
    return 'null'
  endif
endfunction

function! <SID>s:Compiler_is_placeholder(object) dict
  return has_key(a:object, 'is_placeholder')
endfunction

function! <SID>s:Compiler_is_filter(object) dict
  return has_key(a:object, 'is_filter')
endfunction

function! <SID>s:Compiler_is_eof(object) dict
  return has_key(a:object, 'is_eof')
endfunction

function! <SID>s:Compiler_is_visible(object) dict
  return !(self.is_filter(a:object) || self.is_eof(a:object))
endfunction

function! <SID>s:Compiler_compile(tokens) dict
  let template = s:TemplateObjectConstructor()
  let placeholder = {}
  for token in a:tokens
    let object = self.get_object(token)
    if self.is_placeholder(object)
      let placeholder = object
    endif
    if self.is_filter(object)
      call placeholder.add_filter(token.value)
    endif
    if self.is_visible(object)
      call template.append(object)
    endif
  endfor
  return template
endfunction

" included: 'template_context.riml'
function! s:TemplateContextConstructor(data)
  let templateContextObj = {}
  let templateContextObj.data = a:data
  let templateContextObj.lookup = function('<SNR>' . s:SID() . '_s:TemplateContext_lookup')
  return templateContextObj
endfunction

function! <SID>s:TemplateContext_lookup(key) dict
  if has_key(self, a:key)
    return self[a:key]
  elseif has_key(self.data, a:key)
    return self.data[a:key]
  elseif a:key ==# 'context'
    return self.data
  elseif has_key(self.data, 'lookup')
    return self.data.lookup(a:key)
  else
    return ''
  endif
endfunction

" included: 'base_command.riml'
function! s:BaseCommandConstructor()
  let baseCommandObj = {}
  let baseCommandObj.get_command_id = function('<SNR>' . s:SID() . '_s:BaseCommand_get_command_id')
  let baseCommandObj.get_auto_register = function('<SNR>' . s:SID() . '_s:BaseCommand_get_auto_register')
  let baseCommandObj.get_auto_unregister = function('<SNR>' . s:SID() . '_s:BaseCommand_get_auto_unregister')
  let baseCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:BaseCommand_has_ex_mode')
  let baseCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:BaseCommand_has_ctrlp_mode')
  let baseCommandObj.set_registered = function('<SNR>' . s:SID() . '_s:BaseCommand_set_registered')
  let baseCommandObj.has_registered = function('<SNR>' . s:SID() . '_s:BaseCommand_has_registered')
  let baseCommandObj.get_name = function('<SNR>' . s:SID() . '_s:BaseCommand_get_name')
  let baseCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:BaseCommand_get_aliases')
  let baseCommandObj.get_names = function('<SNR>' . s:SID() . '_s:BaseCommand_get_names')
  let baseCommandObj.get_ctrlp_aliases = function('<SNR>' . s:SID() . '_s:BaseCommand_get_ctrlp_aliases')
  let baseCommandObj.get_ctrlp_names = function('<SNR>' . s:SID() . '_s:BaseCommand_get_ctrlp_names')
  let baseCommandObj.get_display_name = function('<SNR>' . s:SID() . '_s:BaseCommand_get_display_name')
  let baseCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:BaseCommand_get_bang')
  let baseCommandObj.get_bar = function('<SNR>' . s:SID() . '_s:BaseCommand_get_bar')
  let baseCommandObj.get_nargs = function('<SNR>' . s:SID() . '_s:BaseCommand_get_nargs')
  let baseCommandObj.get_buffer = function('<SNR>' . s:SID() . '_s:BaseCommand_get_buffer')
  let baseCommandObj.get_register = function('<SNR>' . s:SID() . '_s:BaseCommand_get_register')
  let baseCommandObj.get_completer = function('<SNR>' . s:SID() . '_s:BaseCommand_get_completer')
  let baseCommandObj.get_range = function('<SNR>' . s:SID() . '_s:BaseCommand_get_range')
  let baseCommandObj.get_count = function('<SNR>' . s:SID() . '_s:BaseCommand_get_count')
  let baseCommandObj.get_options = function('<SNR>' . s:SID() . '_s:BaseCommand_get_options')
  let baseCommandObj.complete = function('<SNR>' . s:SID() . '_s:BaseCommand_complete')
  let baseCommandObj.run = function('<SNR>' . s:SID() . '_s:BaseCommand_run')
  return baseCommandObj
endfunction

function! <SID>s:BaseCommand_get_command_id() dict
  return self.command_id
endfunction

function! <SID>s:BaseCommand_get_auto_register() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_auto_unregister() dict
  return 1
endfunction

function! <SID>s:BaseCommand_has_ex_mode() dict
  return 0
endfunction

function! <SID>s:BaseCommand_has_ctrlp_mode() dict
  return 0
endfunction

function! <SID>s:BaseCommand_set_registered(registered) dict
  let self.registered = a:registered
endfunction

function! <SID>s:BaseCommand_has_registered() dict
  return has_key(self, 'registered') && self.registered
endfunction

function! <SID>s:BaseCommand_get_name() dict
  return 'BaseCommand'
endfunction

function! <SID>s:BaseCommand_get_aliases() dict
  return []
endfunction

function! <SID>s:BaseCommand_get_names() dict
  return [self.get_name()] + self.get_aliases()
endfunction

function! <SID>s:BaseCommand_get_ctrlp_aliases() dict
  return self.get_aliases()
endfunction

function! <SID>s:BaseCommand_get_ctrlp_names() dict
  return self.get_ctrlp_aliases()
endfunction

function! <SID>s:BaseCommand_get_display_name(cmd_name) dict
  return substitute(a:cmd_name, 'CtrlP', '', '')
endfunction

function! <SID>s:BaseCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_bar() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_nargs() dict
  return '*'
endfunction

function! <SID>s:BaseCommand_get_buffer() dict
  return 1
endfunction

function! <SID>s:BaseCommand_get_register() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_completer() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_range() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_count() dict
  return 0
endfunction

function! <SID>s:BaseCommand_get_options() dict
  let opts = {}
  let opts.bang = self.get_bang()
  let opts.bar = self.get_bar()
  let opts.nargs = self.get_nargs()
  let opts.buffer = self.get_buffer()
  let opts.register = self.get_register()
  let opts.complete = self.get_completer()
  let opts.range = self.get_range()
  let opts.count = self.get_count()
  return opts
endfunction

function! <SID>s:BaseCommand_complete(word, cmd_line, cursor) dict
  return []
endfunction

function! <SID>s:BaseCommand_run(...) dict
endfunction

" included: 'command_builder.riml'
function! s:CommandBuilderConstructor()
  let commandBuilderObj = {}
  let commandBuilderObj.cmd_options = ''
  let commandBuilderObj.cmd_params = ''
  let commandBuilderObj.cmd_name = ''
  let commandBuilderObj.cmd_repr = ''
  let commandBuilderObj.ex_cmd_name = 'command!'
  let commandBuilderObj.ex_cmd = function('<SNR>' . s:SID() . '_s:CommandBuilder_ex_cmd')
  let commandBuilderObj.append_to = function('<SNR>' . s:SID() . '_s:CommandBuilder_append_to')
  let commandBuilderObj.option = function('<SNR>' . s:SID() . '_s:CommandBuilder_option')
  let commandBuilderObj.options = function('<SNR>' . s:SID() . '_s:CommandBuilder_options')
  let commandBuilderObj.param = function('<SNR>' . s:SID() . '_s:CommandBuilder_param')
  let commandBuilderObj.name = function('<SNR>' . s:SID() . '_s:CommandBuilder_name')
  let commandBuilderObj.repr = function('<SNR>' . s:SID() . '_s:CommandBuilder_repr')
  let commandBuilderObj.build = function('<SNR>' . s:SID() . '_s:CommandBuilder_build')
  return commandBuilderObj
endfunction

function! <SID>s:CommandBuilder_ex_cmd(ex_cmd_name) dict
  let self.ex_cmd_name = a:ex_cmd_name
endfunction

function! <SID>s:CommandBuilder_append_to(key, str) dict
  let key = "cmd_" . a:key
  let self[key] = self[key] . " " . a:str
endfunction

function! <SID>s:CommandBuilder_option(name, value) dict
  if type(a:value) ==# type(1)
    if a:value ==# 1
      call self.append_to('options', "-" . a:name)
    endif
  else
    call self.append_to('options', "-" . a:name . "=" . a:value)
  endif
endfunction

function! <SID>s:CommandBuilder_options(options) dict
  for [name, value] in items(a:options)
    call self.option(name, value)
  endfor
endfunction

function! <SID>s:CommandBuilder_param(name, value) dict
  call self.append_to('params', a:name . " " . a:value)
endfunction

function! <SID>s:CommandBuilder_name(cmd_name) dict
  if a:cmd_name =~# '_'
    let self.cmd_name = substitute(a:cmd_name, '_', '', 'g')
  else
    let self.cmd_name = a:cmd_name
  endif
endfunction

function! <SID>s:CommandBuilder_repr(repr) dict
  let self.cmd_repr = a:repr
endfunction

function! <SID>s:CommandBuilder_build() dict
  let cmd = self.ex_cmd_name . ' '
  let cmd .= self.cmd_options . ' '
  let cmd .= self.cmd_params . ' '
  let cmd .= self.cmd_name . ' '
  let cmd .= self.cmd_repr
  return cmd
endfunction

" included: 'command_registry.riml'
function! s:CommandRegistryConstructor()
  let commandRegistryObj = {}
  let commandRegistryObj.commands = {}
  let commandRegistryObj.actions = {}
  let commandRegistryObj.id_counter = 0
  let commandRegistryObj.next_command_id = function('<SNR>' . s:SID() . '_s:CommandRegistry_next_command_id')
  let commandRegistryObj.add = function('<SNR>' . s:SID() . '_s:CommandRegistry_add')
  let commandRegistryObj.remove = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove')
  let commandRegistryObj.unregister = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister')
  let commandRegistryObj.remove_all = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_all')
  let commandRegistryObj.count = function('<SNR>' . s:SID() . '_s:CommandRegistry_count')
  let commandRegistryObj.auto_register = function('<SNR>' . s:SID() . '_s:CommandRegistry_auto_register')
  let commandRegistryObj.register = function('<SNR>' . s:SID() . '_s:CommandRegistry_register')
  let commandRegistryObj.register_ex_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ex_commands')
  let commandRegistryObj.register_ctrlp_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ctrlp_commands')
  let commandRegistryObj.remove_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_command')
  let commandRegistryObj.remove_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_remove_action')
  let commandRegistryObj.unregister_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister_command')
  let commandRegistryObj.unregister_ctrlp_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_unregister_ctrlp_command')
  let commandRegistryObj.find = function('<SNR>' . s:SID() . '_s:CommandRegistry_find')
  let commandRegistryObj.register_ex_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ex_command')
  let commandRegistryObj.command_has_name = function('<SNR>' . s:SID() . '_s:CommandRegistry_command_has_name')
  let commandRegistryObj.new_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_new_callback')
  let commandRegistryObj.get_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_callback')
  let commandRegistryObj.get_completer = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_completer')
  let commandRegistryObj.register_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_command')
  let commandRegistryObj.register_commands = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_commands')
  let commandRegistryObj.run_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_run_command')
  let commandRegistryObj.run_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_run_action')
  let commandRegistryObj.complete_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_complete_command')
  let commandRegistryObj.is_cmd = function('<SNR>' . s:SID() . '_s:CommandRegistry_is_cmd')
  let commandRegistryObj.has_bang = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_bang')
  let commandRegistryObj.has_range = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_range')
  let commandRegistryObj.has_count = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_count')
  let commandRegistryObj.get_display_name = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_display_name')
  let commandRegistryObj.find_by_id = function('<SNR>' . s:SID() . '_s:CommandRegistry_find_by_id')
  let commandRegistryObj.has_action = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_action')
  let commandRegistryObj.register_ctrlp_command = function('<SNR>' . s:SID() . '_s:CommandRegistry_register_ctrlp_command')
  let commandRegistryObj.has_ctrlp = function('<SNR>' . s:SID() . '_s:CommandRegistry_has_ctrlp')
  let commandRegistryObj.get_ctrlp_extension = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_extension')
  let commandRegistryObj.get_ctrlp_agent = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_agent')
  let commandRegistryObj.get_self_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_self_callback')
  let commandRegistryObj.get_ctrlp_callback = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_callback')
  let commandRegistryObj.get_ctrlp_repr = function('<SNR>' . s:SID() . '_s:CommandRegistry_get_ctrlp_repr')
  let commandRegistryObj.unlink = function('<SNR>' . s:SID() . '_s:CommandRegistry_unlink')
  return commandRegistryObj
endfunction

function! <SID>s:CommandRegistry_next_command_id() dict
  let self.id_counter = self.id_counter + 1
  return self.id_counter
endfunction

function! <SID>s:CommandRegistry_add(cmd) dict
  let id = self.next_command_id()
  let a:cmd.command_id = id
  let self.commands[id] = a:cmd
  let name = a:cmd.get_name()
  let self.actions[name] = id
  call self.auto_register(a:cmd)
endfunction

function! <SID>s:CommandRegistry_remove(cmd) dict
  call self.unregister_command(a:cmd)
  call self.remove_command(a:cmd.get_command_id())
endfunction

function! <SID>s:CommandRegistry_unregister() dict
  for cmd in values(self.commands)
    if cmd.has_ex_mode()
      call self.unregister_command(cmd)
    endif
    if cmd.has_ctrlp_mode()
      call self.unregister_ctrlp_command(cmd)
    endif
  endfor
endfunction

function! <SID>s:CommandRegistry_remove_all() dict
  for cmd in values(self.commands)
    call self.remove_command(cmd.get_command_id())
    call self.remove_action(cmd.get_name())
  endfor
endfunction

function! <SID>s:CommandRegistry_count() dict
  return len(self.commands)
endfunction

function! <SID>s:CommandRegistry_auto_register(cmd) dict
  if a:cmd.get_auto_register()
    call self.register(a:cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register(cmd) dict
  if a:cmd.has_ex_mode()
    call self.register_ex_commands(a:cmd)
  endif
  if a:cmd.has_ctrlp_mode()
    call self.register_ctrlp_commands(a:cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register_ex_commands(cmd) dict
  let options = a:cmd.get_options()
  let names = a:cmd.get_names()
  for name in names
    call self.register_ex_command(a:cmd, name, options, self.get_self_callback())
  endfor
  call a:cmd.set_registered(1)
endfunction

function! <SID>s:CommandRegistry_register_ctrlp_commands(cmd) dict
  let names = a:cmd.get_ctrlp_names()
  let options = {}
  let options.bang = 0
  let options.bar = 0
  let options.nargs = '0'
  let options.complete = 0
  for name in names
    let name = "CtrlP" . name
    call self.register_ctrlp_command(a:cmd, name, options)
  endfor
endfunction

function! <SID>s:CommandRegistry_remove_command(id) dict
  execute ":unlet self.commands[" . a:id . "]"
endfunction

function! <SID>s:CommandRegistry_remove_action(name) dict
  execute ":unlet self.actions['" . a:name . "']"
endfunction

function! <SID>s:CommandRegistry_unregister_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_names()
    for name in names
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! <SID>s:CommandRegistry_unregister_ctrlp_command(cmd) dict
  if a:cmd.has_registered() && a:cmd.get_auto_unregister()
    let names = a:cmd.get_ctrlp_names()
    for name in names
      let name = "CtrlP" . name
      if exists(":" . name)
        execute ":silent! delcommand " . name
      endif
    endfor
  endif
endfunction

function! <SID>s:CommandRegistry_find(cmd_line) dict
  for cmd in values(self.commands)
    let match = self.command_has_name(cmd, a:cmd_line)
    if match.ok
      let match.cmd = cmd
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! <SID>s:CommandRegistry_register_ex_command(cmd, name, options, Callback) dict
  let builder = s:CommandBuilderConstructor()
  let id = a:cmd.get_command_id()
  if type(a:options.complete) ==# type('string') && a:options.complete ==# 'customlist'
    let a:options.complete = self.get_completer(id, a:name)
  endif
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_callback(id, a:name, a:Callback))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! <SID>s:CommandRegistry_command_has_name(cmd, cmd_name) dict
  let names = a:cmd.get_names()
  for name in names
    if a:cmd_name =~# "^" . name
      let match = {}
      let match.ok = 1
      let match.name = name
      return match
    endif
  endfor
  return {'ok': 0}
endfunction

function! <SID>s:CommandRegistry_new_callback() dict
  let Callback = s:create_delegate(self, 'run_command')
  return Callback
endfunction

function! <SID>s:CommandRegistry_get_callback(id, name, Callback) dict
  let callback_name = s:get_delegate_name(a:Callback)
  let opts = "{'bang':'<bang>', 'line1': <line1>, 'line2': <line2>, 'count': <count>})"
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "', [<f-args>], " . opts
endfunction

function! <SID>s:CommandRegistry_get_completer(id, name) dict
  let delegate = s:CompleteDelegateConstructor(self, a:id, a:name)
  let Callback = s:create_delegate(delegate, 'invoke')
  let callback_name = s:get_delegate_name(Callback)
  return "customlist," . callback_name
endfunction

function! <SID>s:CommandRegistry_register_command(id) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(cmd)
    call self.register(cmd)
  endif
endfunction

function! <SID>s:CommandRegistry_register_commands() dict
  for cmd in values(self.commands)
    call self.register(cmd)
  endfor
endfunction

function! <SID>s:CommandRegistry_run_command(id, match, args, options) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to run for id: " . a:id . ", name: " . a:match)
    return 0
  endif
  let a:options.match = a:match
  let a:options.bang = self.has_bang(a:args, a:options)
  if cmd.get_range() && self.has_range(a:args, a:options)
    let a:options.range = [a:options.line1, a:options.line2]
  endif
  if cmd.get_count()
    if !self.has_count(a:args, a:options)
      let a:options.count = 0
    endif
  else
    if self.has_count(a:args, a:options)
      unlet a:options['count']
    endif
  endif
  let arguments = a:args + [a:options]
  return call(cmd['run'], arguments, cmd)
endfunction

function! <SID>s:CommandRegistry_run_action(name, ...) dict
  if !(has_key(self.actions, a:name))
    call s:echo_warn("Warning: Unable to find action for name: " . a:name)
    return 0
  endif
  let n = len(a:000)
  if n >=# 1
    let last_arg = a:000[-1]
    if type(last_arg) ==# type({}) && has_key(last_arg, 'is_option') && last_arg.is_option ==# 1
      let opts = last_arg
      let params = a:000[0 : -2]
    else
      let opts = {}
      let params = a:000
    endif
  else
    let opts = {}
    let params = a:000
  endif
  let id = self.actions[a:name]
  return self.run_command(id, a:name, params, opts)
endfunction

function! <SID>s:CommandRegistry_complete_command(id, name, word, cmd_line, cursor) dict
  let cmd = self.find_by_id(a:id)
  if !(self.is_cmd(cmd))
    call s:echo_warn("Warning: Unable to find command to complete for id: " . a:id . ", name: " . match)
    return 0
  endif
  return cmd.complete(a:word, a:cmd_line, a:cursor)
endfunction

function! <SID>s:CommandRegistry_is_cmd(cmd) dict
  return type(a:cmd) !=# type(0)
endfunction

function! <SID>s:CommandRegistry_has_bang(args, options) dict
  let bang = has_key(a:options, 'bang') && a:options.bang !=# ''
  if !(bang)
    let nargs = len(a:args)
    if nargs ># 0
      let last_arg = a:args[-1]
      if type(last_arg) ==# type('') && last_arg =~# '!$'
        let bang = 1
        let a:args[-1] = strpart(last_arg, 0, len(last_arg) - 1)
      endif
    endif
  endif
  return bang
endfunction

function! <SID>s:CommandRegistry_has_range(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_has_count(args, options) dict
  if has_key(a:options, 'line1') && has_key(a:options, 'line2') && has_key(a:options, 'count')
    return a:options.line1 ==# a:options.line2 && a:options.count !=# -1
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_get_display_name(id, name) dict
  let cmd = self.find_by_id(a:id)
  if self.is_cmd(a:id)
    return cmd.get_display_name(a:name)
  endif
  return "UnknownCommand - " . a:name
endfunction

function! <SID>s:CommandRegistry_find_by_id(id) dict
  if has_key(self.commands, a:id)
    return self.commands[a:id]
  else
    return 0
  endif
endfunction

function! <SID>s:CommandRegistry_has_action(name) dict
  return has_key(self.actions, a:name)
endfunction

function! <SID>s:CommandRegistry_register_ctrlp_command(cmd, name, options) dict
  let id = a:cmd.get_command_id()
  let builder = s:CommandBuilderConstructor()
  call builder.options(a:options)
  call builder.name(a:name)
  call builder.repr(self.get_ctrlp_repr(id, a:name))
  let ex_cmd = builder.build()
  execute ex_cmd
endfunction

function! <SID>s:CommandRegistry_has_ctrlp() dict
  return exists('g:ctrlp_ext_vars')
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_extension() dict
  if !(has_key(self, 'ctrlp_extension'))
    let agent = self.get_ctrlp_agent()
    let self.ctrlp_options = {}
    let self.ctrlp_extension = s:CtrlPExtensionConstructor()
    call self.ctrlp_extension.set_name('Portkey')
    call self.ctrlp_extension.set_agent(agent)
    call self.ctrlp_extension.set_options(self.ctrlp_options)
    call self.ctrlp_extension.enable()
  endif
  return self.ctrlp_extension
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_agent() dict
  if !(has_key(self, 'ctrlp_agent'))
    let self.ctrlp_agent = s:CtrlPAgentConstructor(self)
  endif
  return self.ctrlp_agent
endfunction

function! <SID>s:CommandRegistry_get_self_callback() dict
  if !(has_key(self, 'Callback'))
    let self.Callback = self.new_callback()
  endif
  return self.Callback
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_callback() dict
  if !(has_key(self, 'CtrlPCallback'))
    let delegate = s:CtrlPDelegateConstructor(self.get_ctrlp_extension(), self)
    let self.CtrlPCallback = s:create_delegate(delegate, 'invoke')
  endif
  return self.CtrlPCallback
endfunction

function! <SID>s:CommandRegistry_get_ctrlp_repr(id, name) dict
  let Callback = self.get_ctrlp_callback()
  let callback_name = s:get_delegate_name(Callback)
  return ":call " . callback_name . "('" . a:id . "', '" . a:name . "')"
endfunction

function! <SID>s:CommandRegistry_unlink() dict
  let Callback = self.get_self_callback()
  call s:unlink_delegate(Callback)
  unlet self.Callback
  let CtrlPCallback = self.get_ctrlp_callback()
  call s:unlink_delegate(CtrlPCallback)
  unlet self.CtrlPCallback
endfunction

function! s:CompleteDelegateConstructor(registry, id, name)
  let completeDelegateObj = {}
  let completeDelegateObj.registry = a:registry
  let completeDelegateObj.id = a:id
  let completeDelegateObj.name = a:name
  let completeDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:CompleteDelegate_invoke')
  return completeDelegateObj
endfunction

function! <SID>s:CompleteDelegate_invoke(word, cmd_line, cursor) dict
  return self.registry.complete_command(self.id, self.name, a:word, a:cmd_line, a:cursor)
endfunction

function! s:CtrlPDelegateConstructor(extension, registry)
  let ctrlPDelegateObj = {}
  let ctrlPDelegateObj.extension = a:extension
  let ctrlPDelegateObj.registry = a:registry
  let ctrlPDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:CtrlPDelegate_invoke')
  return ctrlPDelegateObj
endfunction

function! <SID>s:CtrlPDelegate_invoke(id, name) dict
  let agent = self.extension.get_agent()
  call agent.set_command(a:id, a:name)
  call self.extension.set_name(self.registry.get_display_name(a:id, a:name))
  call self.extension.show()
endfunction

function! s:CtrlPAgentConstructor(registry)
  let ctrlPAgentObj = {}
  let ctrlPAgentObj.registry = a:registry
  let ctrlPAgentObj.init = function('<SNR>' . s:SID() . '_s:CtrlPAgent_init')
  let ctrlPAgentObj.accept = function('<SNR>' . s:SID() . '_s:CtrlPAgent_accept')
  let ctrlPAgentObj.enter = function('<SNR>' . s:SID() . '_s:CtrlPAgent_enter')
  let ctrlPAgentObj.exit = function('<SNR>' . s:SID() . '_s:CtrlPAgent_exit')
  let ctrlPAgentObj.opts = function('<SNR>' . s:SID() . '_s:CtrlPAgent_opts')
  let ctrlPAgentObj.set_command = function('<SNR>' . s:SID() . '_s:CtrlPAgent_set_command')
  let ctrlPAgentObj.has_command = function('<SNR>' . s:SID() . '_s:CtrlPAgent_has_command')
  return ctrlPAgentObj
endfunction

function! <SID>s:CtrlPAgent_init() dict
  return self.registry.complete_command(self.command_id, self.resource_type, '', self.resource_type, 0)
endfunction

function! <SID>s:CtrlPAgent_accept(mode, str) dict
  let opts = {}
  let opts.mode = a:mode
  return self.registry.run_command(self.command_id, self.resource_type, [a:str], opts)
endfunction

function! <SID>s:CtrlPAgent_enter() dict
endfunction

function! <SID>s:CtrlPAgent_exit() dict
endfunction

function! <SID>s:CtrlPAgent_opts() dict
endfunction

function! <SID>s:CtrlPAgent_set_command(id, name) dict
  let self.command_id = a:id
  let self.resource_type = a:name
endfunction

function! <SID>s:CtrlPAgent_has_command() dict
  return has_key(self, 'command_id')
endfunction

" included: 'autocmd_loader.riml'
function! s:AutocmdLoaderConstructor()
  let autocmdLoaderObj = {}
  let autocmdLoaderObj.cmds = []
  let autocmdLoaderObj.set_group_name = function('<SNR>' . s:SID() . '_s:AutocmdLoader_set_group_name')
  let autocmdLoaderObj.get_group_name = function('<SNR>' . s:SID() . '_s:AutocmdLoader_get_group_name')
  let autocmdLoaderObj.load = function('<SNR>' . s:SID() . '_s:AutocmdLoader_load')
  let autocmdLoaderObj.unload = function('<SNR>' . s:SID() . '_s:AutocmdLoader_unload')
  let autocmdLoaderObj.cmd = function('<SNR>' . s:SID() . '_s:AutocmdLoader_cmd')
  let autocmdLoaderObj.size = function('<SNR>' . s:SID() . '_s:AutocmdLoader_size')
  return autocmdLoaderObj
endfunction

function! <SID>s:AutocmdLoader_set_group_name(group_name) dict
  let self.group_name = a:group_name
endfunction

function! <SID>s:AutocmdLoader_get_group_name() dict
  return self.group_name
endfunction

function! <SID>s:AutocmdLoader_load() dict
  execute ":augroup " . self.get_group_name()
  execute ":autocmd!"
  for cmd in self.cmds
    execute ":autocmd " . cmd
  endfor
  execute ":augroup END"
endfunction

function! <SID>s:AutocmdLoader_unload() dict
  execute ":augroup " . self.group_name
  execute ":autocmd!"
  execute ":augroup END"
endfunction

function! <SID>s:AutocmdLoader_cmd(ex_cmd) dict
  call add(self.cmds, a:ex_cmd)
endfunction

function! <SID>s:AutocmdLoader_size() dict
  return len(self.cmds)
endfunction

" included: 'environment.riml'
function! s:EnvironmentConstructor()
  let environmentObj = {}
  let opts = {}
  let opts.autostart = 1
  let opts.adaptive_mappings = 1
  let opts.warn_on_mapping_conflicts = 1
  let environmentObj.options = opts
  let environmentObj.on_inject = function('<SNR>' . s:SID() . '_s:Environment_on_inject')
  let environmentObj.load_defaults = function('<SNR>' . s:SID() . '_s:Environment_load_defaults')
  let environmentObj.set_option = function('<SNR>' . s:SID() . '_s:Environment_set_option')
  let environmentObj.get_option = function('<SNR>' . s:SID() . '_s:Environment_get_option')
  let environmentObj.load_option = function('<SNR>' . s:SID() . '_s:Environment_load_option')
  let environmentObj.load_options = function('<SNR>' . s:SID() . '_s:Environment_load_options')
  return environmentObj
endfunction

function! <SID>s:Environment_on_inject() dict
  call self.load_options()
endfunction

function! <SID>s:Environment_load_defaults(opts) dict
  let self.options = a:opts
endfunction

function! <SID>s:Environment_set_option(name, value) dict
  let self.options[a:name] = a:value
endfunction

function! <SID>s:Environment_get_option(name) dict
  return self.options[a:name]
endfunction

function! <SID>s:Environment_load_option(name) dict
  let key = "portkey_" . a:name
  if exists("g:" . key)
    execute "let value = g:" . key
    call self.set_option(a:name, value)
  endif
endfunction

function! <SID>s:Environment_load_options() dict
  for option in keys(self.options)
    call self.load_option(option)
  endfor
endfunction

" included: 'projection_template.riml'
function! s:ProjectionTemplateConstructor(original)
  let projectionTemplateObj = {}
  let projectionTemplateObj.original = a:original
  let projectionTemplateObj.compiled = {'is_template': 0}
  let projectionTemplateObj.error = ''
  let projectionTemplateObj.get_original = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_get_original')
  let projectionTemplateObj.get_compiled = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_get_compiled')
  let projectionTemplateObj.has_error = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_has_error')
  let projectionTemplateObj.get_error = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_get_error')
  let projectionTemplateObj.compile = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_compile')
  let projectionTemplateObj.render = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_render')
  let projectionTemplateObj.is_compiled = function('<SNR>' . s:SID() . '_s:ProjectionTemplate_is_compiled')
  return projectionTemplateObj
endfunction

function! <SID>s:ProjectionTemplate_get_original() dict
  return self.original
endfunction

function! <SID>s:ProjectionTemplate_get_compiled() dict
  return self.compiled
endfunction

function! <SID>s:ProjectionTemplate_has_error() dict
  return self.error !=# ''
endfunction

function! <SID>s:ProjectionTemplate_get_error() dict
  return self.error
endfunction

function! <SID>s:ProjectionTemplate_compile(lexer, compiler) dict
  try
    let self.error = ''
    let tokens = a:lexer.scan(self.original)
    let self.compiled = a:compiler.compile(tokens)
  catch /.*/
    let self.error = "Error: Template expansion failed.\n\n" . v:exception
  endtry
endfunction

function! <SID>s:ProjectionTemplate_render(context) dict
  if self.is_compiled()
    return self.compiled.render(a:context)
  else
    return self.error
  endif
endfunction

function! <SID>s:ProjectionTemplate_is_compiled() dict
  return has_key(self.compiled, 'is_template') && self.compiled.is_template
endfunction

" included: 'projection_pattern.riml'
function! s:ProjectionPatternConstructor(original, projection)
  let projectionPatternObj = {}
  let projectionPatternObj.original = a:original
  let projectionPatternObj.projection = a:projection
  if a:original =~# '\V**'
    let projectionPatternObj.recursive = 1
  else
    let projectionPatternObj.recursive = 0
  endif
  let projectionPatternObj.get_original = function('<SNR>' . s:SID() . '_s:ProjectionPattern_get_original')
  let projectionPatternObj.get_projection = function('<SNR>' . s:SID() . '_s:ProjectionPattern_get_projection')
  let projectionPatternObj.swap = function('<SNR>' . s:SID() . '_s:ProjectionPattern_swap')
  let projectionPatternObj.get_regex = function('<SNR>' . s:SID() . '_s:ProjectionPattern_get_regex')
  let projectionPatternObj.has_template = function('<SNR>' . s:SID() . '_s:ProjectionPattern_has_template')
  let projectionPatternObj.set_template = function('<SNR>' . s:SID() . '_s:ProjectionPattern_set_template')
  let projectionPatternObj.get_template = function('<SNR>' . s:SID() . '_s:ProjectionPattern_get_template')
  let projectionPatternObj.is_recursive = function('<SNR>' . s:SID() . '_s:ProjectionPattern_is_recursive')
  return projectionPatternObj
endfunction

function! <SID>s:ProjectionPattern_get_original() dict
  return self.original
endfunction

function! <SID>s:ProjectionPattern_get_projection() dict
  return self.projection
endfunction

function! <SID>s:ProjectionPattern_swap(filename) dict
  let pattern = self.get_original()
  if pattern =~# '\V*'
    if !self.is_recursive()
      return substitute(pattern, '\V*', a:filename, '')
    else
      return substitute(pattern, '\V**', a:filename, '')
    endif
  elseif pattern =~# '/'
    let parent_dir = fnamemodify(pattern, ':h')
    let root_name = fnamemodify(pattern, ':t:r')
    let ext = fnamemodify(pattern, ':e')
    if ext !=# ''
      let ext = '.' . ext
    endif
    return parent_dir . "/" . a:filename . ext
  else
    let root_name = fnamemodify(pattern, ':r')
    let ext = fnamemodify(pattern, ':e')
    if ext !=# ''
      let ext = '.' . ext
    endif
    return a:filename . ext
  endif
endfunction

function! <SID>s:ProjectionPattern_get_regex() dict
  if !(has_key(self, 'regex'))
    let self.regex = s:escape_regex(self.original)
  endif
  return self.regex
endfunction

function! <SID>s:ProjectionPattern_has_template() dict
  return has_key(self, 'template')
endfunction

function! <SID>s:ProjectionPattern_set_template(template) dict
  let self.template = s:ProjectionTemplateConstructor(a:template)
endfunction

function! <SID>s:ProjectionPattern_get_template() dict
  return self.template
endfunction

function! <SID>s:ProjectionPattern_is_recursive() dict
  return self.recursive
endfunction

function! s:escape_regex(pattern)
  if a:pattern ==# '*'
    let pattern_regex = '\v([^.]*)'
  elseif a:pattern =~# '*'
    let pattern_regex = a:pattern
    let pattern_regex = substitute(pattern_regex, '\v\*+', '(.{-})', '')
    let pattern_regex = '\v' . pattern_regex
  elseif a:pattern =~# '/'
    let parent_dir = fnamemodify(a:pattern, ':h')
    let root_name = fnamemodify(a:pattern, ':t:r')
    let ext = fnamemodify(a:pattern, ':e')
    if ext !=# ''
      let ext = '.' . ext
    endif
    let pattern_regex = '\v' . parent_dir . "/(" . root_name . ")" . ext
  else
    let root_name = fnamemodify(a:pattern, ':r')
    let ext = fnamemodify(a:pattern, ':e')
    if ext !=# ''
      let ext = '.' . ext
    endif
    let pattern_regex = '\v' . "(" . root_name . ")" . ext
  endif
  return pattern_regex
endfunction

" included: 'projection_match.riml'
function! s:ProjectionMatcherConstructor(map)
  let projectionMatcherObj = {}
  let projectionMatcherObj.map = a:map
  let projectionMatcherObj.current_order = 'asc'
  let projectionMatcherObj.match = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_match')
  let projectionMatcherObj.get_pattern_store = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_get_pattern_store')
  let projectionMatcherObj.set_updated = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_set_updated')
  let projectionMatcherObj.get_updated = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_get_updated')
  let projectionMatcherObj.get_patterns = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_get_patterns')
  let projectionMatcherObj.sort_projections = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_sort_projections')
  let projectionMatcherObj.update = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_update')
  let projectionMatcherObj.get_callback = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_get_callback')
  let projectionMatcherObj.compare_patterns = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_compare_patterns')
  let projectionMatcherObj.compare_alphabetical = function('<SNR>' . s:SID() . '_s:ProjectionMatcher_compare_alphabetical')
  return projectionMatcherObj
endfunction

function! <SID>s:ProjectionMatcher_match(path, order) dict
  for pattern in self.get_patterns(a:order)
    let result = matchlist(a:path, pattern.get_regex())
    if len(result) ># 0
      let match = s:ProjectionMatchConstructor(1)
      call match.set_input(a:path)
      call match.set_source(result[1])
      call match.set_pattern(pattern)
      return match
    endif
  endfor
  let match = s:ProjectionMatchConstructor(0)
  call match.set_input(a:path)
  return match
endfunction

function! <SID>s:ProjectionMatcher_get_pattern_store(order) dict
  return a:order . "_patterns"
endfunction

function! <SID>s:ProjectionMatcher_set_updated(order) dict
  let key = a:order . "_updated"
  let self[key] = 1
endfunction

function! <SID>s:ProjectionMatcher_get_updated(order) dict
  let key = a:order . "_updated"
  return has_key(self, key) && self[key]
endfunction

function! <SID>s:ProjectionMatcher_get_patterns(order) dict
  let pattern_store = self.get_pattern_store(a:order)
  if !(self.get_updated(a:order))
    let projections = self.map.get_projections()
    let self[pattern_store] = self.sort_projections(projections, a:order)
    call self.set_updated(a:order)
  endif
  return self[pattern_store]
endfunction

function! <SID>s:ProjectionMatcher_sort_projections(projections, order) dict
  let ordered_patterns = []
  for projection in a:projections
    for pattern in projection.get_patterns()
      call add(ordered_patterns, pattern)
    endfor
  endfor
  let self.current_order = a:order
  call sort(ordered_patterns, self.get_callback())
  return ordered_patterns
endfunction

function! <SID>s:ProjectionMatcher_update() dict
  let self.asc_updated = 0
  let self.desc_updated = 0
endfunction

function! <SID>s:ProjectionMatcher_get_callback() dict
  if !(has_key(self, 'CompareFunc'))
    let self.CompareFunc = s:create_delegate(self, 'compare_patterns')
  endif
  return self.CompareFunc
endfunction

function! <SID>s:ProjectionMatcher_compare_patterns(a, b) dict
  let pattern_a = a:a.get_original()
  let pattern_b = a:b.get_original()
  let parent_dir_a = fnamemodify(pattern_a, ':h')
  let parent_dir_b = fnamemodify(pattern_b, ':h')
  let parent_dir_la = len(parent_dir_a)
  let parent_dir_lb = len(parent_dir_b)
  if parent_dir_a ==# parent_dir_b
    let tail_a = fnamemodify(pattern_a, ':t')
    let tail_b = fnamemodify(pattern_b, ':t')
    let len_a = len(tail_a)
    let len_b = len(tail_b)
    let result = len_a - len_b
  elseif parent_dir_la >=# parent_dir_lb
    if match(parent_dir_a, parent_dir_b) ==# 0
      let result = 1
    else
      let result = self.compare_alphabetical(parent_dir_a, parent_dir_b)
    endif
  elseif parent_dir_la <# parent_dir_lb
    if match(parent_dir_b, parent_dir_a) ==# 0
      let result = -1
    else
      let result = 1
    endif
  else
    let result = self.compare_alphabetical(parent_dir_a, parent_dir_b)
  endif
  if result >=# 1
    let result = 1
  elseif result <=# -1
    let result = -1
  else
    let result = 0
  endif
  if self.current_order ==# 'asc'
    return result
  else
    return result * -1
  endif
endfunction

function! <SID>s:ProjectionMatcher_compare_alphabetical(a, b) dict
  if a:a <# a:b
    let result = -1
  elseif a:a ># a:b
    let result = 1
  else
    let result = 0
  endif
  return result
endfunction

function! s:ProjectionMatchConstructor(ok)
  let projectionMatchObj = {}
  let projectionMatchObj.ok = a:ok
  let projectionMatchObj.is_match = 1
  let projectionMatchObj.set_input = function('<SNR>' . s:SID() . '_s:ProjectionMatch_set_input')
  let projectionMatchObj.get_input = function('<SNR>' . s:SID() . '_s:ProjectionMatch_get_input')
  let projectionMatchObj.set_source = function('<SNR>' . s:SID() . '_s:ProjectionMatch_set_source')
  let projectionMatchObj.get_source = function('<SNR>' . s:SID() . '_s:ProjectionMatch_get_source')
  let projectionMatchObj.set_pattern = function('<SNR>' . s:SID() . '_s:ProjectionMatch_set_pattern')
  let projectionMatchObj.get_pattern = function('<SNR>' . s:SID() . '_s:ProjectionMatch_get_pattern')
  return projectionMatchObj
endfunction

function! <SID>s:ProjectionMatch_set_input(input) dict
  let self.input = a:input
endfunction

function! <SID>s:ProjectionMatch_get_input() dict
  return self.input
endfunction

function! <SID>s:ProjectionMatch_set_source(source) dict
  let self.source = a:source
endfunction

function! <SID>s:ProjectionMatch_get_source() dict
  return self.source
endfunction

function! <SID>s:ProjectionMatch_set_pattern(pattern) dict
  let self.pattern = a:pattern
endfunction

function! <SID>s:ProjectionMatch_get_pattern() dict
  return self.pattern
endfunction

" included: 'projection.riml'
let s:projection_id_counter = 0
function! s:next_projection_id()
  let s:projection_id_counter += 1
  return s:projection_id_counter
endfunction

function! s:ProjectionConstructor(resource_type)
  let projectionObj = {}
  let projectionObj.is_projection = 1
  let projectionObj.revision = 0
  let projectionObj.id = s:next_projection_id()
  let projection_templates = {}
  let projection_templates['alternate'] = []
  let projection_templates['related'] = []
  let projection_templates['test'] = []
  let projectionObj.projection_templates = projection_templates
  let projectionObj.keywords = []
  let projectionObj.patterns = []
  let projectionObj.resource_type = a:resource_type
  let projectionObj.affinity = 'null'
  let projectionObj.mapping = 'null'
  let projectionObj.compiler = 'null'
  let projectionObj.scope = 'null'
  let projectionObj.get_revision = function('<SNR>' . s:SID() . '_s:Projection_get_revision')
  let projectionObj.bump_revision = function('<SNR>' . s:SID() . '_s:Projection_bump_revision')
  let projectionObj.get_id = function('<SNR>' . s:SID() . '_s:Projection_get_id')
  let projectionObj.get_hash = function('<SNR>' . s:SID() . '_s:Projection_get_hash')
  let projectionObj.has_pattern = function('<SNR>' . s:SID() . '_s:Projection_has_pattern')
  let projectionObj.add_pattern = function('<SNR>' . s:SID() . '_s:Projection_add_pattern')
  let projectionObj.get_patterns = function('<SNR>' . s:SID() . '_s:Projection_get_patterns')
  let projectionObj.match = function('<SNR>' . s:SID() . '_s:Projection_match')
  let projectionObj.get_compare_func = function('<SNR>' . s:SID() . '_s:Projection_get_compare_func')
  let projectionObj.has_projection_template = function('<SNR>' . s:SID() . '_s:Projection_has_projection_template')
  let projectionObj.get_projection_templates = function('<SNR>' . s:SID() . '_s:Projection_get_projection_templates')
  let projectionObj.add_projection_template = function('<SNR>' . s:SID() . '_s:Projection_add_projection_template')
  let projectionObj.get_resource_type = function('<SNR>' . s:SID() . '_s:Projection_get_resource_type')
  let projectionObj.has_keyword = function('<SNR>' . s:SID() . '_s:Projection_has_keyword')
  let projectionObj.add_keyword = function('<SNR>' . s:SID() . '_s:Projection_add_keyword')
  let projectionObj.get_keyword_list = function('<SNR>' . s:SID() . '_s:Projection_get_keyword_list')
  let projectionObj.set_affinity = function('<SNR>' . s:SID() . '_s:Projection_set_affinity')
  let projectionObj.get_affinity = function('<SNR>' . s:SID() . '_s:Projection_get_affinity')
  let projectionObj.get_mapping = function('<SNR>' . s:SID() . '_s:Projection_get_mapping')
  let projectionObj.set_mapping = function('<SNR>' . s:SID() . '_s:Projection_set_mapping')
  let projectionObj.has_mapping = function('<SNR>' . s:SID() . '_s:Projection_has_mapping')
  let projectionObj.get_compiler = function('<SNR>' . s:SID() . '_s:Projection_get_compiler')
  let projectionObj.set_compiler = function('<SNR>' . s:SID() . '_s:Projection_set_compiler')
  let projectionObj.has_compiler = function('<SNR>' . s:SID() . '_s:Projection_has_compiler')
  let projectionObj.get_scope = function('<SNR>' . s:SID() . '_s:Projection_get_scope')
  let projectionObj.set_scope = function('<SNR>' . s:SID() . '_s:Projection_set_scope')
  let projectionObj.has_scope = function('<SNR>' . s:SID() . '_s:Projection_has_scope')
  return projectionObj
endfunction

function! <SID>s:Projection_get_revision() dict
  return self.revision
endfunction

function! <SID>s:Projection_bump_revision() dict
  let self.revision += 1
endfunction

function! <SID>s:Projection_get_id() dict
  return self.id
endfunction

function! <SID>s:Projection_get_hash() dict
  return self.id . "-" . self.revision
endfunction

function! <SID>s:Projection_has_pattern(pattern) dict
  for p in self.patterns
    if p.get_original() ==# a:pattern
      return 1
    endif
  endfor
  return 0
endfunction

function! <SID>s:Projection_add_pattern(pattern) dict
  let pattern_obj = s:ProjectionPatternConstructor(a:pattern, self)
  call add(self.patterns, pattern_obj)
  return pattern_obj
endfunction

function! <SID>s:Projection_get_patterns() dict
  return self.patterns
endfunction

function! <SID>s:Projection_match(filename) dict
  let patterns = copy(self.patterns)
  call sort(patterns, self.get_compare_func())
  for pattern in patterns
    let expansion = pattern.swap(a:filename)
    if match(expansion, a:filename) >=# 0
      return expansion
    endif
  endfor
  return ''
endfunction

function! <SID>s:Projection_get_compare_func() dict
  let matcher = s:ProjectionMatcherConstructor({})
  let CompareFunc = s:create_delegate(matcher, 'compare_patterns')
  return CompareFunc
endfunction

function! <SID>s:Projection_has_projection_template(projection_type, template_str) dict
  let templates = self.get_projection_templates(a:projection_type)
  for template in templates
    if template.get_original() ==# a:template_str
      return 1
    endif
  endfor
  return 0
endfunction

function! <SID>s:Projection_get_projection_templates(projection_type) dict
  return self.projection_templates[a:projection_type]
endfunction

function! <SID>s:Projection_add_projection_template(projection_type, ...) dict
  let templates = self.get_projection_templates(a:projection_type)
  let changed = 0
  for template in a:000
    if !(self.has_projection_template(a:projection_type, template))
      call add(templates, s:ProjectionTemplateConstructor(template))
      let changed = 1
    endif
  endfor
  return changed
endfunction

function! <SID>s:Projection_get_resource_type() dict
  return self.resource_type
endfunction

function! <SID>s:Projection_has_keyword(keyword) dict
  return index(self.keywords, a:keyword) >=# 0
endfunction

function! <SID>s:Projection_add_keyword(keyword) dict
  call add(self.keywords, a:keyword)
endfunction

function! <SID>s:Projection_get_keyword_list() dict
  return self.keywords
endfunction

function! <SID>s:Projection_set_affinity(affinity) dict
  let self.affinity = a:affinity
endfunction

function! <SID>s:Projection_get_affinity() dict
  return self.affinity
endfunction

function! <SID>s:Projection_get_mapping() dict
  return self.mapping
endfunction

function! <SID>s:Projection_set_mapping(mapping) dict
  let self.mapping = a:mapping
endfunction

function! <SID>s:Projection_has_mapping() dict
  return has_key(self, 'mapping') && self.mapping !=# 'null'
endfunction

function! <SID>s:Projection_get_compiler() dict
  return self.compiler
endfunction

function! <SID>s:Projection_set_compiler(compiler) dict
  let self.compiler = a:compiler
endfunction

function! <SID>s:Projection_has_compiler() dict
  return has_key(self, 'compiler') && self.compiler !=# 'null'
endfunction

function! <SID>s:Projection_get_scope() dict
  return self.scope
endfunction

function! <SID>s:Projection_set_scope(scope) dict
  let self.scope = a:scope
endfunction

function! <SID>s:Projection_has_scope() dict
  return has_key(self, 'scope') && self.scope !=# 'null'
endfunction

" included: 'projection_collection.riml'
function! s:ProjectionCollectionConstructor()
  let projectionCollectionObj = {}
  let projectionCollectionObj.projections = {}
  let projectionCollectionObj.trie = s:TrieConstructor()
  let projectionCollectionObj.needs = function('<SNR>' . s:SID() . '_s:ProjectionCollection_needs')
  let projectionCollectionObj.get_matcher = function('<SNR>' . s:SID() . '_s:ProjectionCollection_get_matcher')
  let projectionCollectionObj.add = function('<SNR>' . s:SID() . '_s:ProjectionCollection_add')
  let projectionCollectionObj.change_projection = function('<SNR>' . s:SID() . '_s:ProjectionCollection_change_projection')
  let projectionCollectionObj.has = function('<SNR>' . s:SID() . '_s:ProjectionCollection_has')
  let projectionCollectionObj.find_by_resource_type = function('<SNR>' . s:SID() . '_s:ProjectionCollection_find_by_resource_type')
  let projectionCollectionObj.get_projections = function('<SNR>' . s:SID() . '_s:ProjectionCollection_get_projections')
  let projectionCollectionObj.get_resource_types = function('<SNR>' . s:SID() . '_s:ProjectionCollection_get_resource_types')
  let projectionCollectionObj.get_mappings = function('<SNR>' . s:SID() . '_s:ProjectionCollection_get_mappings')
  let projectionCollectionObj.get_patterns = function('<SNR>' . s:SID() . '_s:ProjectionCollection_get_patterns')
  let projectionCollectionObj.match = function('<SNR>' . s:SID() . '_s:ProjectionCollection_match')
  return projectionCollectionObj
endfunction

function! <SID>s:ProjectionCollection_needs() dict
  return ['extensions']
endfunction

function! <SID>s:ProjectionCollection_get_matcher() dict
  if !(has_key(self, 'matcher'))
    let self.matcher = s:ProjectionMatcherConstructor(self)
  endif
  return self.matcher
endfunction

function! <SID>s:ProjectionCollection_add(resource_type, json) dict
  if self.has(a:resource_type)
    let projection = self.find_by_resource_type(a:resource_type)
    let is_new = 0
  else
    let projection = s:ProjectionConstructor(a:resource_type)
    let is_new = 1
  endif
  let loader = s:ProjectionLoaderConstructor(projection)
  let changed = loader.load(a:json)
  if is_new
    let self.projections[a:resource_type] = projection
    call self.trie.add_word(a:resource_type, projection)
    call self.change_projection(projection)
  endif
  if changed
    call self.get_matcher().update()
  endif
  return projection
endfunction

function! <SID>s:ProjectionCollection_change_projection(projection) dict
  if has_key(self, 'extensions')
    let extensions = self.extensions
    for extension in extensions.get_all_extensions()
      call extension.configure_projection(a:projection)
    endfor
  endif
endfunction

function! <SID>s:ProjectionCollection_has(resource_type) dict
  return has_key(self.projections, a:resource_type)
endfunction

function! <SID>s:ProjectionCollection_find_by_resource_type(resource_type) dict
  if has_key(self.projections, a:resource_type)
    return self.projections[a:resource_type]
  else
    let node = self.trie.get(a:resource_type)
    if node.is_node
      return node.get_source()
    else
      return {'is_projection': 0}
    endif
  endif
endfunction

function! <SID>s:ProjectionCollection_get_projections() dict
  return values(self.projections)
endfunction

function! <SID>s:ProjectionCollection_get_resource_types() dict
  return keys(self.projections)
endfunction

function! <SID>s:ProjectionCollection_get_mappings() dict
  return self.trie.find_distinct_prefixes()
endfunction

function! <SID>s:ProjectionCollection_get_patterns(order) dict
  return self.get_matcher().get_patterns(a:order)
endfunction

function! <SID>s:ProjectionCollection_match(path, ...) dict
  if len(a:000) ==# 1
    let order = a:000[0]
  else
    let order = 'desc'
  endif
  return self.get_matcher().match(a:path, order)
endfunction

function! s:ProjectionLoaderConstructor(projection)
  let projectionLoaderObj = {}
  let projectionLoaderObj.projection = a:projection
  let projectionLoaderObj.changed = 0
  let projectionLoaderObj.load = function('<SNR>' . s:SID() . '_s:ProjectionLoader_load')
  let projectionLoaderObj.get_changed = function('<SNR>' . s:SID() . '_s:ProjectionLoader_get_changed')
  let projectionLoaderObj.load_property = function('<SNR>' . s:SID() . '_s:ProjectionLoader_load_property')
  let projectionLoaderObj.load_projection_template = function('<SNR>' . s:SID() . '_s:ProjectionLoader_load_projection_template')
  let projectionLoaderObj.load_list = function('<SNR>' . s:SID() . '_s:ProjectionLoader_load_list')
  let projectionLoaderObj.load_pattern = function('<SNR>' . s:SID() . '_s:ProjectionLoader_load_pattern')
  let projectionLoaderObj.has_property = function('<SNR>' . s:SID() . '_s:ProjectionLoader_has_property')
  let projectionLoaderObj.change_property = function('<SNR>' . s:SID() . '_s:ProjectionLoader_change_property')
  let projectionLoaderObj.change_list = function('<SNR>' . s:SID() . '_s:ProjectionLoader_change_list')
  let projectionLoaderObj.change_list_item = function('<SNR>' . s:SID() . '_s:ProjectionLoader_change_list_item')
  return projectionLoaderObj
endfunction

function! <SID>s:ProjectionLoader_load(json) dict
  let self.changed = 0
  call self.load_property('affinity', 'affinity', a:json)
  call self.load_property('mapping', 'mapping', a:json)
  call self.load_property('compiler', 'compiler', a:json)
  call self.load_property('scope', 'scope', a:json)
  call self.load_projection_template('alternate', a:json)
  call self.load_projection_template('related', a:json)
  call self.load_projection_template('test', a:json)
  call self.load_pattern(a:json)
  if has_key(a:json, 'keywords')
    let a:json['keyword_list'] = split(a:json['keywords'], ' ')
    call self.load_list('keyword', 'keyword_list', a:json)
  endif
  if self.changed
    call self.projection.bump_revision()
  endif
  return self.changed
endfunction

function! <SID>s:ProjectionLoader_get_changed() dict
  return self.changed
endfunction

function! <SID>s:ProjectionLoader_load_property(property, key, json) dict
  if has_key(a:json, a:key)
    let value = a:json[a:key]
    call self.change_property(a:property, value)
  endif
endfunction

function! <SID>s:ProjectionLoader_load_projection_template(projection_type, json) dict
  if has_key(a:json, a:projection_type)
    let value = a:json[a:projection_type]
    if type(value) ==# type('')
      let self.changed = self.projection.add_projection_template(a:projection_type, value)
    elseif type(value) ==# type([])
      let self.changed = call(self.projection['add_projection_template'], [a:projection_type] + value, self.projection)
    endif
  endif
endfunction

function! <SID>s:ProjectionLoader_load_list(property, key, json) dict
  if has_key(a:json, a:key)
    let list = a:json[a:key]
    call self.change_list(a:property, list)
  endif
endfunction

function! <SID>s:ProjectionLoader_load_pattern(json) dict
  if has_key(a:json, 'pattern')
    let pattern = self.projection.add_pattern(a:json['pattern'])
    if has_key(a:json, 'template')
      call pattern.set_template(a:json['template'])
    endif
  endif
endfunction

function! <SID>s:ProjectionLoader_has_property(property) dict
  let getter = "get_" . a:property
  let value = call(self.projection[getter], [], self.projection)
  if a:property ==# 'template'
    return value.get_original() !=# ''
  else
    return value !=# 'null'
  endif
endfunction

function! <SID>s:ProjectionLoader_change_property(property, value) dict
  if !(self.has_property(a:property))
    let setter = "set_" . a:property
    let result = call(self.projection[setter], [a:value], self.projection)
    let self.changed = 1
  endif
endfunction

function! <SID>s:ProjectionLoader_change_list(property, value) dict
  let setter = "add_" . a:property
  if type(a:value) ==# type('')
    call self.change_list_item(a:property, a:value)
  else
    for item in a:value
      call self.change_list_item(a:property, item)
    endfor
  endif
endfunction

function! <SID>s:ProjectionLoader_change_list_item(property, value) dict
  let getter = "has_" . a:property
  let has_item = call(self.projection[getter], [a:value], self.projection)
  if !(has_item)
    let setter = "add_" . a:property
    let result = call(self.projection[setter], [a:value], self.projection)
    let self.changed = 1
  endif
endfunction

" included: 'projector.riml'
function! s:ProjectorConstructor()
  let projectorObj = {}
  let projectorObj.is_projector = 1
  let projectorObj.needs = function('<SNR>' . s:SID() . '_s:Projector_needs')
  let projectorObj.get_projection_templates = function('<SNR>' . s:SID() . '_s:Projector_get_projection_templates')
  let projectorObj.get_file_template = function('<SNR>' . s:SID() . '_s:Projector_get_file_template')
  let projectorObj.render_template = function('<SNR>' . s:SID() . '_s:Projector_render_template')
  let projectorObj.append_template = function('<SNR>' . s:SID() . '_s:Projector_append_template')
  return projectorObj
endfunction

function! <SID>s:Projector_needs() dict
  return ['lexer', 'compiler', 'projections']
endfunction

function! <SID>s:Projector_get_projection_templates(projection, projection_type, context) dict
  let templates = a:projection.get_projection_templates(a:projection_type)
  let templates = copy(templates)
  if a:projection_type ==# 'alternate'
    let templates += a:projection.get_projection_templates('test')
  endif
  let compiled = []
  for template in templates
    call self.append_template(compiled, template, a:context)
  endfor
  return compiled
endfunction

function! <SID>s:Projector_get_file_template(filepath, context) dict
  let match = self.projections.match(a:filepath)
  if match.ok
    let pattern = match.get_pattern()
    if pattern.has_template()
      let template = pattern.get_template()
      return self.render_template(template, a:context)
    else
      return ''
    endif
  else
    return ''
  endif
  let template = projection.get_template()
  return self.render_template(template, a:context)
endfunction

function! <SID>s:Projector_render_template(template, context) dict
  if !(a:template.is_compiled())
    call a:template.compile(self.lexer, self.compiler)
  endif
  if !a:template.has_error()
    return a:template.render(a:context)
  else
    return a:template.get_error()
  endif
endfunction

function! <SID>s:Projector_append_template(list, template, context) dict
  let result = self.render_template(a:template, a:context)
  if !(a:template.has_error())
    call add(a:list, result)
  endif
endfunction

" included: 'buffer.riml'
function! s:BufferConstructor(path)
  let bufferObj = {}
  let bufferObj.root_marker = 'portkey.json'
  let bufferObj.path = a:path
  let bufferObj.root = ''
  let bufferObj.did_search = 0
  let bufferObj.enrolled = 0
  let bufferObj.configured = 0
  let bufferObj.has_root = function('<SNR>' . s:SID() . '_s:Buffer_has_root')
  let bufferObj.find_root = function('<SNR>' . s:SID() . '_s:Buffer_find_root')
  let bufferObj.get_path = function('<SNR>' . s:SID() . '_s:Buffer_get_path')
  let bufferObj.get_portkey_path = function('<SNR>' . s:SID() . '_s:Buffer_get_portkey_path')
  let bufferObj.get_portkey_display_path = function('<SNR>' . s:SID() . '_s:Buffer_get_portkey_display_path')
  let bufferObj.get_abs_portkey_path = function('<SNR>' . s:SID() . '_s:Buffer_get_abs_portkey_path')
  let bufferObj.get_root = function('<SNR>' . s:SID() . '_s:Buffer_get_root')
  let bufferObj.get_abs_root = function('<SNR>' . s:SID() . '_s:Buffer_get_abs_root')
  let bufferObj.get_abs_path = function('<SNR>' . s:SID() . '_s:Buffer_get_abs_path')
  let bufferObj.get_rel_path = function('<SNR>' . s:SID() . '_s:Buffer_get_rel_path')
  let bufferObj.get_rootname = function('<SNR>' . s:SID() . '_s:Buffer_get_rootname')
  let bufferObj.get_filename = function('<SNR>' . s:SID() . '_s:Buffer_get_filename')
  let bufferObj.reset = function('<SNR>' . s:SID() . '_s:Buffer_reset')
  let bufferObj.set_match = function('<SNR>' . s:SID() . '_s:Buffer_set_match')
  let bufferObj.get_match = function('<SNR>' . s:SID() . '_s:Buffer_get_match')
  let bufferObj.has_projection = function('<SNR>' . s:SID() . '_s:Buffer_has_projection')
  let bufferObj.get_projection = function('<SNR>' . s:SID() . '_s:Buffer_get_projection')
  let bufferObj.get_source = function('<SNR>' . s:SID() . '_s:Buffer_get_source')
  let bufferObj.get_pattern = function('<SNR>' . s:SID() . '_s:Buffer_get_pattern')
  let bufferObj.set_enrolled = function('<SNR>' . s:SID() . '_s:Buffer_set_enrolled')
  let bufferObj.get_enrolled = function('<SNR>' . s:SID() . '_s:Buffer_get_enrolled')
  let bufferObj.set_configured = function('<SNR>' . s:SID() . '_s:Buffer_set_configured')
  let bufferObj.get_configured = function('<SNR>' . s:SID() . '_s:Buffer_get_configured')
  return bufferObj
endfunction

function! <SID>s:Buffer_has_root() dict
  if self.did_search
    return self.root !=# ''
  else
    return self.find_root()
  endif
endfunction

function! <SID>s:Buffer_find_root() dict
  let parent_dir = fnamemodify(self.path, ':p:h')
  let portkey_json = findfile(self.root_marker, parent_dir . ";")
  let self.did_search = 1
  if portkey_json !=# ''
    let self.root = fnamemodify(portkey_json, ':h')
    return 1
  endif
  return 0
endfunction

function! <SID>s:Buffer_get_path() dict
  return self.path
endfunction

function! <SID>s:Buffer_get_portkey_path() dict
  let path = self.get_abs_root() . "portkey.json"
  return fnamemodify(path, ':.')
endfunction

function! <SID>s:Buffer_get_portkey_display_path(...) dict
  if len(a:000) ==# 0
    let portkey_path = self.get_portkey_path()
  else
    let portkey_path = a:000[0]
  endif
  let parent_dir = fnamemodify(portkey_path, ':p:h:t')
  let portkey_name = fnamemodify(portkey_path, ':t')
  return parent_dir . "/" . portkey_name
endfunction

function! <SID>s:Buffer_get_abs_portkey_path() dict
  return fnamemodify(self.get_portkey_path(), ':p')
endfunction

function! <SID>s:Buffer_get_root() dict
  if !(self.did_search)
    let result = self.find_root()
    if !(result)
      throw 'Portkey not found for #{self.path}, use has_root before get_root'
    endif
  endif
  return self.root
endfunction

function! <SID>s:Buffer_get_abs_root() dict
  if !(has_key(self, 'abs_root'))
    let self.abs_root = fnamemodify(self.root, ':p')
  endif
  return self.abs_root
endfunction

function! <SID>s:Buffer_get_abs_path() dict
  if !(has_key(self, 'abs_path'))
    let self.abs_path = fnamemodify(self.path, ':p')
  endif
  return self.abs_path
endfunction

function! <SID>s:Buffer_get_rel_path() dict
  if !(has_key(self, 'rel_path'))
    let self.rel_path = substitute(self.get_abs_path(), self.get_abs_root(), '', '')
  endif
  return self.rel_path
endfunction

function! <SID>s:Buffer_get_rootname() dict
  return fnamemodify(self.get_path(), ':t:r')
endfunction

function! <SID>s:Buffer_get_filename() dict
  return fnamemodify(self.get_path(), ':t')
endfunction

function! <SID>s:Buffer_reset() dict
  if has_key(self, 'match')
    unlet self.match
  endif
  let self.enrolled = 0
  let self.configured = 0
endfunction

function! <SID>s:Buffer_set_match(match) dict
  let self.match = a:match
  let self.configured = 1
endfunction

function! <SID>s:Buffer_get_match() dict
  return self.match
endfunction

function! <SID>s:Buffer_has_projection() dict
  return has_key(self, 'match')
endfunction

function! <SID>s:Buffer_get_projection() dict
  return self.get_match().get_pattern().get_projection()
endfunction

function! <SID>s:Buffer_get_source() dict
  return self.get_match().source
endfunction

function! <SID>s:Buffer_get_pattern() dict
  return self.get_match().pattern
endfunction

function! <SID>s:Buffer_set_enrolled(enrolled) dict
  let self.enrolled = a:enrolled
endfunction

function! <SID>s:Buffer_get_enrolled() dict
  return self.enrolled
endfunction

function! <SID>s:Buffer_set_configured(configured) dict
  let self.configured = a:configured
endfunction

function! <SID>s:Buffer_get_configured() dict
  return self.configured
endfunction

" included: 'buffer_collection.riml'
function! s:BufferCollectionConstructor()
  let bufferCollectionObj = {}
  let bufferCollectionObj.buffers = []
  let bufferCollectionObj.has_current = function('<SNR>' . s:SID() . '_s:BufferCollection_has_current')
  let bufferCollectionObj.get_current = function('<SNR>' . s:SID() . '_s:BufferCollection_get_current')
  let bufferCollectionObj.set_current = function('<SNR>' . s:SID() . '_s:BufferCollection_set_current')
  let bufferCollectionObj.clear = function('<SNR>' . s:SID() . '_s:BufferCollection_clear')
  return bufferCollectionObj
endfunction

function! <SID>s:BufferCollection_has_current() dict
  return has_key(self, 'current')
endfunction

function! <SID>s:BufferCollection_get_current() dict
  return self.current
endfunction

function! <SID>s:BufferCollection_set_current(current) dict
  let self.current = a:current
  call add(self.buffers, a:current)
endfunction

function! <SID>s:BufferCollection_clear() dict
  for buffer in self.buffers
    call buffer.reset()
  endfor
endfunction

" included: 'context.riml'
function! s:ContextConstructor()
  let contextObj = {}
  let contextObj.needs = function('<SNR>' . s:SID() . '_s:Context_needs')
  let contextObj.on_inject = function('<SNR>' . s:SID() . '_s:Context_on_inject')
  let contextObj.get_root = function('<SNR>' . s:SID() . '_s:Context_get_root')
  let contextObj.get_root_portkey = function('<SNR>' . s:SID() . '_s:Context_get_root_portkey')
  let contextObj.add_portkey = function('<SNR>' . s:SID() . '_s:Context_add_portkey')
  let contextObj.add_extension = function('<SNR>' . s:SID() . '_s:Context_add_extension')
  let contextObj.get_portkeys = function('<SNR>' . s:SID() . '_s:Context_get_portkeys')
  let contextObj.load = function('<SNR>' . s:SID() . '_s:Context_load')
  let contextObj.load_config = function('<SNR>' . s:SID() . '_s:Context_load_config')
  let contextObj.load_extensions = function('<SNR>' . s:SID() . '_s:Context_load_extensions')
  let contextObj.load_extension_by_name = function('<SNR>' . s:SID() . '_s:Context_load_extension_by_name')
  let contextObj.load_extension = function('<SNR>' . s:SID() . '_s:Context_load_extension')
  let contextObj.load_syntax_files = function('<SNR>' . s:SID() . '_s:Context_load_syntax_files')
  let contextObj.load_filters = function('<SNR>' . s:SID() . '_s:Context_load_filters')
  let contextObj.load_inflections = function('<SNR>' . s:SID() . '_s:Context_load_inflections')
  let contextObj.load_rankers = function('<SNR>' . s:SID() . '_s:Context_load_rankers')
  let contextObj.load_ranker = function('<SNR>' . s:SID() . '_s:Context_load_ranker')
  let contextObj.load_finders = function('<SNR>' . s:SID() . '_s:Context_load_finders')
  let contextObj.load_finder = function('<SNR>' . s:SID() . '_s:Context_load_finder')
  let contextObj.load_extractors = function('<SNR>' . s:SID() . '_s:Context_load_extractors')
  let contextObj.lookup = function('<SNR>' . s:SID() . '_s:Context_lookup')
  let contextObj.get_projections = function('<SNR>' . s:SID() . '_s:Context_get_projections')
  let contextObj.get_extension_names = function('<SNR>' . s:SID() . '_s:Context_get_extension_names')
  let contextObj.inject = function('<SNR>' . s:SID() . '_s:Context_inject')
  return contextObj
endfunction

function! <SID>s:Context_needs() dict
  return ['extensions']
endfunction

function! <SID>s:Context_on_inject() dict
  let c = self.container.child()
  let self.container = c
  call c.register('finder', 'Finder', 1)
  call c.register('ranker', 'Ranker', 1)
  call c.register('projector', 'Projector', 1)
  call c.register('lexer', 'Lexer', 1)
  call c.register('compiler', 'Compiler', 1)
  call c.register('completer', 'Completer', 1)
  call c.register('finder_facade', 'FinderFacade', 1)
  call c.register('syntax_loader', 'SyntaxLoader', 1)
  call c.register('filter_factory', 'FilterFactory', 1)
  call c.register('inflector', 'Inflector', 1)
  call c.register('autocmd_loader', 'AutocmdLoader', 1)
  call c.register('extractors', 'ExtractorCollection', 1)
  call c.register('globber', 'Globber', 1)
  call c.register('alternate_finder_context', 'AlternateFinderContext', 1)
  call c.register('related_finder_context', 'RelatedFinderContext', 1)
  call c.register('resource_finder_context', 'ResourceFinderContext', 1)
  call c.register('get_file_finder_context', 'GetFileFinderContext', 1)
  call c.register('test_finder_context', 'TestFinderContext', 1)
  call c.register('launcher', 'Launcher', 1)
  call c.register('pick_file_strategy', 'PickFileStrategy', 1)
  call c.register('first_file_strategy', 'FirstFileStrategy', 1)
  call c.register('nth_file_strategy', 'NthFileStrategy', 1)
  call c.register('new_resource_strategy', 'NewResourceStrategy', 1)
  call c.register('test_file_strategy', 'TestFileStrategy', 1)
  call c.register('get_file_strategy', 'GetFileStrategy', 1)
  call c.register('strip_ext_strategy', 'StripExtStrategy', 1)
  call c.register('underscorize_strategy', 'UnderscorizeStrategy', 1)
  call c.register('camelize_strategy', 'CamelizeStrategy', 1)
  call c.register('affinize_strategy', 'AffinizeStrategy', 1)
  call c.register('projections', 'ProjectionCollection', 1)
  call c.register('context', self)
  call c.register('make', 'Make', 1)
endfunction

function! <SID>s:Context_get_root() dict
  return self.root
endfunction

function! <SID>s:Context_get_root_portkey() dict
  return self.root . "portkey.json"
endfunction

function! <SID>s:Context_add_portkey(file) dict
  call add(self.portkeys, a:file)
endfunction

function! <SID>s:Context_add_extension(extension_name) dict
  call add(self.extension_names, a:extension_name)
endfunction

function! <SID>s:Context_get_portkeys() dict
  return self.portkeys
endfunction

function! <SID>s:Context_load(root) dict
  let self.root = a:root
  let self.portkeys = []
  let self.extension_names = []
  let collector = s:PortkeyCollectorConstructor(self, self.lookup('projections'))
  let loader = s:PortkeyLoaderConstructor(self.extensions)
  call loader.load(self.get_root_portkey(), collector)
  call self.load_extensions()
  return !loader.has_errors()
endfunction

function! <SID>s:Context_load_config(json, path, scope) dict
  for [key, value] in items(a:json)
    if key ==# 'inflections'
      let loader = s:InflectionLoaderConstructor()
      let inflector = self.lookup('inflector')
      call loader.load(value, inflector)
    endif
  endfor
endfunction

function! <SID>s:Context_load_extensions() dict
  let extensions = self.extensions
  call self.load_extension_by_name('core')
  for extension_name in self.extension_names
    call self.load_extension_by_name(extension_name)
  endfor
endfunction

function! <SID>s:Context_load_extension_by_name(extension_name) dict
  let extensions = self.extensions
  if extensions.has_extension(a:extension_name)
    let extension = extensions.get_extension(a:extension_name)
    call self.load_extension(extension)
  endif
endfunction

function! <SID>s:Context_load_extension(extension) dict
  call self.container.inject(a:extension)
  call self.load_finders(a:extension)
  call self.load_rankers(a:extension)
  call self.load_inflections(a:extension)
  call self.load_filters(a:extension)
  call self.load_syntax_files(a:extension)
  call self.load_extractors(a:extension)
endfunction

function! <SID>s:Context_load_syntax_files(extension) dict
  let syntax_files = a:extension.get_syntax_files()
  if !(type(syntax_files) ==# type({}))
    return
  endif
  let syntax_loader = self.lookup('syntax_loader')
  for syntax_file_type in keys(syntax_files)
    let syntax_file = syntax_files[syntax_file_type]
    call syntax_loader.register(syntax_file_type, syntax_file)
  endfor
endfunction

function! <SID>s:Context_load_filters(extension) dict
  let filters = a:extension.get_filters()
  if !(type(filters) ==# type({}))
    return
  endif
  let filter_factory = self.lookup('filter_factory')
  for filter_name in keys(filters)
    let filter = filters[filter_name]
    call filter_factory.add_filter(filter_name, filter)
  endfor
endfunction

function! <SID>s:Context_load_inflections(extension) dict
  let inflector = self.lookup('inflector')
  call a:extension.configure_inflector(inflector)
endfunction

function! <SID>s:Context_load_rankers(extension) dict
  let ranker = self.lookup('ranker')
  call self.load_ranker(a:extension, 'projection', ranker)
  call self.load_ranker(a:extension, 'resource', ranker)
  call self.load_ranker(a:extension, 'file', ranker)
endfunction

function! <SID>s:Context_load_ranker(extension, type, ranker) dict
  let r = a:extension.get_ranker(a:type)
  if type(r) ==# type({})
    call self.inject(r)
    call a:ranker.add_ranker(a:type, r)
  endif
endfunction

function! <SID>s:Context_load_finders(extension) dict
  let finder = self.lookup('finder')
  call self.load_finder(a:extension, 'projection', finder)
  call self.load_finder(a:extension, 'resource', finder)
  call self.load_finder(a:extension, 'file', finder)
endfunction

function! <SID>s:Context_load_finder(extension, type, finder) dict
  let f = a:extension.get_finder(a:type)
  if type(f) ==# type({})
    call self.inject(f)
    call a:finder.add_finder(a:type, f)
  endif
endfunction

function! <SID>s:Context_load_extractors(extension) dict
  let ext_extractors = a:extension.get_extractors()
  let extractors = self.lookup('extractors')
  for extractor in ext_extractors
    call self.inject(extractor)
    call extractors.add_extractor(extractor)
  endfor
endfunction

function! <SID>s:Context_lookup(name) dict
  if a:name ==# 'context'
    return self
  else
    return self.container.lookup(a:name)
  endif
endfunction

function! <SID>s:Context_get_projections() dict
  return self.lookup('projections')
endfunction

function! <SID>s:Context_get_extension_names() dict
  return self.extension_names
endfunction

function! <SID>s:Context_inject(object) dict
  if has_key(self, 'container') && has_key(self.container, 'inject')
    call self.container.inject(a:object)
  endif
endfunction

function! s:PortkeyLoaderConstructor(extensions)
  let portkeyLoaderObj = {}
  let portkeyLoaderObj.parser = s:JSONParserConstructor()
  let portkeyLoaderObj.loaded_paths = {}
  let portkeyLoaderObj.is_portkey_loader = 1
  let portkeyLoaderObj.extensions = a:extensions
  let portkeyLoaderObj.errors = 0
  let portkeyLoaderObj.root_loaded = 0
  let portkeyLoaderObj.load = function('<SNR>' . s:SID() . '_s:PortkeyLoader_load')
  let portkeyLoaderObj.load_children = function('<SNR>' . s:SID() . '_s:PortkeyLoader_load_children')
  let portkeyLoaderObj.load_and_parse = function('<SNR>' . s:SID() . '_s:PortkeyLoader_load_and_parse')
  let portkeyLoaderObj.parse = function('<SNR>' . s:SID() . '_s:PortkeyLoader_parse')
  let portkeyLoaderObj.resolve_path = function('<SNR>' . s:SID() . '_s:PortkeyLoader_resolve_path')
  let portkeyLoaderObj.lookup_extension_path = function('<SNR>' . s:SID() . '_s:PortkeyLoader_lookup_extension_path')
  let portkeyLoaderObj.send_extension_event = function('<SNR>' . s:SID() . '_s:PortkeyLoader_send_extension_event')
  let portkeyLoaderObj.get_event_name = function('<SNR>' . s:SID() . '_s:PortkeyLoader_get_event_name')
  let portkeyLoaderObj.show_error = function('<SNR>' . s:SID() . '_s:PortkeyLoader_show_error')
  let portkeyLoaderObj.has_errors = function('<SNR>' . s:SID() . '_s:PortkeyLoader_has_errors')
  let portkeyLoaderObj.has_root_loaded = function('<SNR>' . s:SID() . '_s:PortkeyLoader_has_root_loaded')
  let portkeyLoaderObj.is_json = function('<SNR>' . s:SID() . '_s:PortkeyLoader_is_json')
  let portkeyLoaderObj.has_children = function('<SNR>' . s:SID() . '_s:PortkeyLoader_has_children')
  let portkeyLoaderObj.is_extension_name = function('<SNR>' . s:SID() . '_s:PortkeyLoader_is_extension_name')
  let portkeyLoaderObj.get_scope = function('<SNR>' . s:SID() . '_s:PortkeyLoader_get_scope')
  return portkeyLoaderObj
endfunction

function! <SID>s:PortkeyLoader_load(pathname, collector) dict
  if !(has_key(self, 'root_pathname'))
    let self.root_pathname = a:pathname
  endif
  let portkey_path = self.resolve_path(a:pathname)
  if portkey_path.is_custom
    call a:collector.add_extension(portkey_path.get_extension_name())
    return
  endif
  if !(portkey_path.is_portkey_path)
    call self.show_error('Cannot load portkey', a:pathname)
    return
  endif
  let path = portkey_path.get_filepath()
  let json = self.load_and_parse(path)
  if self.is_json(json)
    let self.loaded_paths[path] = 1
    call a:collector.add(json, path, self.get_scope(a:pathname))
    if portkey_path.is_extension()
      call a:collector.add_extension(portkey_path.get_extension_name())
    else
      let self.root_loaded = 1
    endif
    if self.has_children(json)
      call self.load_children(json, a:collector)
    endif
  endif
endfunction

function! <SID>s:PortkeyLoader_load_children(json, collector) dict
  let children = a:json['portkeys']
  for child in children
    call self.load(child, a:collector)
  endfor
endfunction

function! <SID>s:PortkeyLoader_load_and_parse(path) dict
  try
    if type(a:path) ==# type('')
      let lines = readfile(a:path)
      let text = join(lines, ' ')
      return self.parse(text, a:path)
    elseif !self.is_extension_name(a:path)
      call self.show_error('Invalid portkey path', a:path)
    endif
  catch /.*/
    call self.show_error('Failed to load json', a:path)
    return 0
  endtry
endfunction

function! <SID>s:PortkeyLoader_parse(text, path) dict
  let json = self.parser.parse(a:text)
  if self.is_json(json)
    return json
  else
    call self.show_error('Failed to parse json', a:path)
    return 0
  endif
endfunction

function! <SID>s:PortkeyLoader_resolve_path(pathname) dict
  let portkey_path = s:PortkeyPathConstructor(a:pathname)
  if portkey_path.is_extension()
    let extension_path = self.lookup_extension_path(portkey_path)
    if extension_path ==# 'custom'
      let portkey_path.is_custom = 1
      let portkey_path.is_portkey_path = 0
    elseif extension_path ==# 'not_found'
      let portkey_path.is_portkey_path = 0
    elseif extension_path ==# 'null'
      let portkey_path.is_portkey_path = 0
    else
      call portkey_path.set_filepath(extension_path)
    endif
    return portkey_path
  elseif filereadable(portkey_path.get_filepath())
    if self.root_pathname ==# a:pathname
      call self.send_extension_event('core')
    endif
    return portkey_path
  else
    return {'pathname': a:pathname, 'is_portkey_path': 0, 'is_custom': 0}
  endif
endfunction

function! <SID>s:PortkeyLoader_lookup_extension_path(portkey_path) dict
  let extension_name = a:portkey_path.get_extension_name()
  call self.send_extension_event(extension_name)
  if self.extensions.has_extension(extension_name)
    if a:portkey_path.get_pathname() =~# '\v:custom$'
      return 'custom'
    endif
    let extension = self.extensions.get_extension(extension_name)
    let parts = a:portkey_path.get_extension_name_parts()
    let filepath = extension.get_portkey_path(parts.type, parts.variant)
    if filepath !=# 'null'
      return filepath
    else
      return 'null'
    endif
  else
    call s:echo_warn("Extension not found: " . a:portkey_path.get_extension_name())
    return 'not_found'
  endif
endfunction

function! <SID>s:PortkeyLoader_send_extension_event(extension_name) dict
  if !(self.extensions.has_extension(a:extension_name))
    let event_name = self.get_event_name(a:extension_name)
    execute ":silent! doautocmd User " . event_name
  endif
endfunction

function! <SID>s:PortkeyLoader_get_event_name(extension_name) dict
  return 'portkey_extension_' . tolower(a:extension_name)
endfunction

function! <SID>s:PortkeyLoader_show_error(msg, path) dict
  let rel_path = fnamemodify(a:path, ':.')
  call s:echo_warn(a:msg . ": " . rel_path)
  let self.errors = 1
endfunction

function! <SID>s:PortkeyLoader_has_errors() dict
  return self.errors
endfunction

function! <SID>s:PortkeyLoader_has_root_loaded() dict
  return self.root_loaded
endfunction

function! <SID>s:PortkeyLoader_is_json(json) dict
  return type(a:json) ==# type({})
endfunction

function! <SID>s:PortkeyLoader_has_children(json) dict
  return has_key(a:json, 'portkeys') && type(a:json.portkeys) ==# type([])
endfunction

function! <SID>s:PortkeyLoader_is_extension_name(path) dict
  return a:path !~# '.json$'
endfunction

function! <SID>s:PortkeyLoader_get_scope(pathname) dict
  if self.is_extension_name(a:pathname) && self.extensions.has_extension(a:pathname)
    return self.extensions.get_extension(a:pathname).get_scope()
  else
    return 'global'
  endif
endfunction

function! s:PortkeyPathConstructor(pathname)
  let portkeyPathObj = {}
  let portkeyPathObj.pathname = a:pathname
  let portkeyPathObj.is_portkey_path = 1
  let portkeyPathObj.is_ext = 0
  let portkeyPathObj.is_custom = 0
  let portkeyPathObj.get_pathname = function('<SNR>' . s:SID() . '_s:PortkeyPath_get_pathname')
  let portkeyPathObj.build_extension_name = function('<SNR>' . s:SID() . '_s:PortkeyPath_build_extension_name')
  let portkeyPathObj.is_extension = function('<SNR>' . s:SID() . '_s:PortkeyPath_is_extension')
  let portkeyPathObj.get_extension_name = function('<SNR>' . s:SID() . '_s:PortkeyPath_get_extension_name')
  let portkeyPathObj.set_filepath = function('<SNR>' . s:SID() . '_s:PortkeyPath_set_filepath')
  let portkeyPathObj.get_filepath = function('<SNR>' . s:SID() . '_s:PortkeyPath_get_filepath')
  let portkeyPathObj.get_extension_name_parts = function('<SNR>' . s:SID() . '_s:PortkeyPath_get_extension_name_parts')
  let portkeyPathObj.get_name_parts = function('<SNR>' . s:SID() . '_s:PortkeyPath_get_name_parts')
  return portkeyPathObj
endfunction

function! <SID>s:PortkeyPath_get_pathname() dict
  return self.pathname
endfunction

function! <SID>s:PortkeyPath_build_extension_name() dict
  if self.pathname !~# '.json$'
    let self.extension_name_parts = self.get_name_parts(self.pathname)
    let self.extension_name = self.extension_name_parts.name
    let self.filepath = ''
    let self.is_ext = 1
  else
    let self.filepath = self.pathname
    let self.is_ext = 0
  endif
endfunction

function! <SID>s:PortkeyPath_is_extension() dict
  if !(has_key(self, 'filepath'))
    call self.build_extension_name()
  endif
  return self.is_ext
endfunction

function! <SID>s:PortkeyPath_get_extension_name() dict
  if !(has_key(self, 'filepath'))
    call self.build_extension_name()
  endif
  return self.extension_name
endfunction

function! <SID>s:PortkeyPath_set_filepath(filepath) dict
  let self.filepath = a:filepath
endfunction

function! <SID>s:PortkeyPath_get_filepath() dict
  return self.filepath
endfunction

function! <SID>s:PortkeyPath_get_extension_name_parts() dict
  return self.extension_name_parts
endfunction

function! <SID>s:PortkeyPath_get_name_parts(extension_name) dict
  let parts = {}
  let eparts = split(a:extension_name, ':')
  let n = len(eparts)
  if n ==# 2
    let parts.name = eparts[0]
    let vparts = split(eparts[1], '-')
    let m = len(vparts)
    if m ==# 2
      let parts.type = vparts[0]
      let parts.variant = vparts[1]
    else
      let parts.type = vparts[0]
      let parts.variant = ''
    endif
  else
    let parts.name = eparts[0]
    let parts.type = ''
    let parts.variant = ''
  endif
  return parts
endfunction

function! s:PortkeyCollectorConstructor(context, projections)
  let portkeyCollectorObj = {}
  let portkeyCollectorObj.context = a:context
  let portkeyCollectorObj.projections = a:projections
  let portkeyCollectorObj.add = function('<SNR>' . s:SID() . '_s:PortkeyCollector_add')
  let portkeyCollectorObj.add_extension = function('<SNR>' . s:SID() . '_s:PortkeyCollector_add_extension')
  return portkeyCollectorObj
endfunction

function! <SID>s:PortkeyCollector_add(json, path, scope) dict
  for [key, value] in items(a:json)
    if key ==# 'config'
      call self.context.load_config(value, a:path, a:scope)
    elseif key !=# 'portkeys'
      if has_key(value, 'type')
        let resource_type = value['type']
      elseif has_key(value, 'command')
        let resource_type = value['command']
      else
        let resource_type = 'unknown'
      endif
      let value['pattern'] = key
      if !(has_key(value, 'scope'))
        let value['scope'] = a:scope
      endif
      call self.projections.add(resource_type, value)
    endif
    unlet value
  endfor
  call self.context.add_portkey(a:path)
endfunction

function! <SID>s:PortkeyCollector_add_extension(extension_name) dict
  call self.context.add_extension(a:extension_name)
endfunction

" included: 'context_collection.riml'
function! s:ContextCollectionConstructor()
  let contextCollectionObj = {}
  let contextCollectionObj.contexts = {}
  let contextCollectionObj.contains = function('<SNR>' . s:SID() . '_s:ContextCollection_contains')
  let contextCollectionObj.add = function('<SNR>' . s:SID() . '_s:ContextCollection_add')
  let contextCollectionObj.remove = function('<SNR>' . s:SID() . '_s:ContextCollection_remove')
  let contextCollectionObj.remove_all = function('<SNR>' . s:SID() . '_s:ContextCollection_remove_all')
  let contextCollectionObj.get = function('<SNR>' . s:SID() . '_s:ContextCollection_get')
  return contextCollectionObj
endfunction

function! <SID>s:ContextCollection_contains(root) dict
  return has_key(self.contexts, a:root)
endfunction

function! <SID>s:ContextCollection_add(root) dict
  let context = self.container.lookup('context')
  let success = context.load(a:root)
  if success
    let self.contexts[a:root] = context
    return 1
  else
    return 0
  endif
endfunction

function! <SID>s:ContextCollection_remove(root) dict
  if self.contains(a:root)
    unlet self.contexts[a:root]
  endif
endfunction

function! <SID>s:ContextCollection_remove_all() dict
  for root in keys(self.contexts)
    call self.remove(root)
  endfor
endfunction

function! <SID>s:ContextCollection_get(root) dict
  return self.contexts[a:root]
endfunction

" included: 'ranker.riml'
function! s:RankerConstructor()
  let rankerObj = {}
  let rankerObj.rankers = s:ObjectCacheConstructor()
  let rankerObj.add_ranker = function('<SNR>' . s:SID() . '_s:Ranker_add_ranker')
  let rankerObj.rank = function('<SNR>' . s:SID() . '_s:Ranker_rank')
  let rankerObj.sort = function('<SNR>' . s:SID() . '_s:Ranker_sort')
  let rankerObj.compare_rank_items = function('<SNR>' . s:SID() . '_s:Ranker_compare_rank_items')
  let rankerObj.get_rankers = function('<SNR>' . s:SID() . '_s:Ranker_get_rankers')
  let rankerObj.to_rank_items = function('<SNR>' . s:SID() . '_s:Ranker_to_rank_items')
  let rankerObj.to_results = function('<SNR>' . s:SID() . '_s:Ranker_to_results')
  return rankerObj
endfunction

function! <SID>s:Ranker_add_ranker(type, ranker) dict
  call self.rankers.insert(a:type, a:ranker)
endfunction

function! <SID>s:Ranker_rank(type, context, results) dict
  let rankers = self.get_rankers(a:type)
  let rank_items = self.to_rank_items(a:results)
  for ranker in rankers
    let proceed = ranker.rank(a:context, rank_items)
    if !(proceed)
      break
    endif
  endfor
  call self.sort(rank_items)
  return self.to_results(rank_items)
endfunction

function! <SID>s:Ranker_sort(rank_items) dict
  let sort_function = s:new_delegate(self, 'compare_rank_items')
  call sort(a:rank_items, sort_function)
endfunction

function! <SID>s:Ranker_compare_rank_items(a, b) dict
  let rank_a = a:a.get_ranking()
  let rank_b = a:b.get_ranking()
  let result = rank_b - rank_a
  return result
endfunction

function! <SID>s:Ranker_get_rankers(type) dict
  if self.rankers.has(a:type)
    return self.rankers.get(a:type)
  else
    return []
  endif
endfunction

function! <SID>s:Ranker_to_rank_items(results) dict
  let items = []
  for result in a:results
    call add(items, s:RankItemConstructor(result, 0))
  endfor
  return items
endfunction

function! <SID>s:Ranker_to_results(rank_items) dict
  let results = []
  for rank_item in a:rank_items
    call add(results, rank_item.get_path())
  endfor
  return results
endfunction

function! s:RankItemConstructor(path, ranking)
  let rankItemObj = {}
  let rankItemObj.path = a:path
  let rankItemObj.ranking = a:ranking
  let rankItemObj.get_path = function('<SNR>' . s:SID() . '_s:RankItem_get_path')
  let rankItemObj.get_ranking = function('<SNR>' . s:SID() . '_s:RankItem_get_ranking')
  let rankItemObj.set_ranking = function('<SNR>' . s:SID() . '_s:RankItem_set_ranking')
  let rankItemObj.raise = function('<SNR>' . s:SID() . '_s:RankItem_raise')
  let rankItemObj.lower = function('<SNR>' . s:SID() . '_s:RankItem_lower')
  let rankItemObj.get_step_size = function('<SNR>' . s:SID() . '_s:RankItem_get_step_size')
  return rankItemObj
endfunction

function! <SID>s:RankItem_get_path() dict
  return self.path
endfunction

function! <SID>s:RankItem_get_ranking() dict
  return self.ranking
endfunction

function! <SID>s:RankItem_set_ranking(ranking) dict
  let self.ranking = a:ranking
endfunction

function! <SID>s:RankItem_raise(...) dict
  let step_size = self.get_step_size(a:000)
  let self.ranking += step_size
endfunction

function! <SID>s:RankItem_lower(...) dict
  let step_size = self.get_step_size(a:000)
  let self.ranking -= step_size
endfunction

function! <SID>s:RankItem_get_step_size(args) dict
  if len(a:args) ==# 1
    let step_size = a:args[0]
  else
    let step_size = 1
  endif
  return step_size
endfunction

" included: 'projection_ranker.riml'
function! s:ProjectionRankerConstructor()
  let projectionRankerObj = {}
  let projectionRankerObj.rank = function('<SNR>' . s:SID() . '_s:ProjectionRanker_rank')
  let projectionRankerObj.get_rootname = function('<SNR>' . s:SID() . '_s:ProjectionRanker_get_rootname')
  return projectionRankerObj
endfunction

function! <SID>s:ProjectionRanker_rank(context, rank_items) dict
  let buffer = a:context.lookup('buffer')
  let context_root = buffer.get_abs_root()
  let rootname = buffer.get_rootname()
  for rank_item in a:rank_items
    let rank_item_path = rank_item.get_path()
    let rank_item_rootname = self.get_rootname(rank_item_path)
    let match_result = match(rootname, rank_item_rootname)
    if match_result >=# 0
      call rank_item.raise(len(rank_item_rootname))
    endif
    if filereadable(context_root . rank_item_path)
      call rank_item.raise(1000)
    endif
  endfor
  return 1
endfunction

function! <SID>s:ProjectionRanker_get_rootname(path) dict
  return fnamemodify(a:path, ':t:r')
endfunction

" included: 'globber.riml'
function! s:GlobberConstructor()
  let globberObj = {}
  let globberObj.glob = function('<SNR>' . s:SID() . '_s:Globber_glob')
  let globberObj.get_glob_pattern = function('<SNR>' . s:SID() . '_s:Globber_get_glob_pattern')
  let globberObj.get_recursive_pattern = function('<SNR>' . s:SID() . '_s:Globber_get_recursive_pattern')
  return globberObj
endfunction

function! <SID>s:Globber_glob(path, pattern) dict
  let file_pattern = self.get_glob_pattern(a:pattern)
  let files_str = globpath(a:path, file_pattern)
  let files = split(files_str, '\n')
  return files
endfunction

function! <SID>s:Globber_get_glob_pattern(pattern) dict
  if !a:pattern.is_recursive()
    return a:pattern.get_original()
  else
    return self.get_recursive_pattern(a:pattern.get_original())
  endif
endfunction

function! <SID>s:Globber_get_recursive_pattern(pattern) dict
  return substitute(a:pattern, '\V**', '**/*', '')
endfunction

" included: 'data_frame.riml'
function! s:DataFrameConstructor(buffer)
  let dataFrameObj = {}
  let dataFrameObj.buffer = a:buffer
  let dataFrameObj.is_data_frame = 1
  let dataFrameObj.line = getline('.')
  if exists(':TagbarCurrentTag')
    let dataFrameObj.tag = tagbar#currenttag('%s', '', 's')
    let dataFrameObj.tag_full = tagbar#currenttag('%s', '', 'f')
    let dataFrameObj.tag_proto = tagbar#currenttag('%s', '', 'p')
  endif
  let dataFrameObj.set_line = function('<SNR>' . s:SID() . '_s:DataFrame_set_line')
  let dataFrameObj.set_tags = function('<SNR>' . s:SID() . '_s:DataFrame_set_tags')
  let dataFrameObj.set_source = function('<SNR>' . s:SID() . '_s:DataFrame_set_source')
  let dataFrameObj.set_source_path = function('<SNR>' . s:SID() . '_s:DataFrame_set_source_path')
  let dataFrameObj.print = function('<SNR>' . s:SID() . '_s:DataFrame_print')
  return dataFrameObj
endfunction

function! <SID>s:DataFrame_set_line(line) dict
  let self.line = a:line
endfunction

function! <SID>s:DataFrame_set_tags(tag, tag_full, tag_proto) dict
  let self.tag = a:tag
  let self.tag_full = a:tag_full
  let self.tag_proto = a:tag_proto
endfunction

function! <SID>s:DataFrame_set_source(source_name) dict
  let self.source = a:source_name
endfunction

function! <SID>s:DataFrame_set_source_path(source_path) dict
  let self.source_path = a:source_path
endfunction

function! <SID>s:DataFrame_print() dict
  call s:info('buffer', self.buffer.get_rel_path())
  call s:info('tag', self.tag)
  call s:info('tag_full', self.tag_full)
  call s:info('tag_proto', self.tag_proto)
endfunction

function! s:ProjectionDataFrameConstructor(buffer)
  let projectionDataFrameObj = {}
  let dataFrameObj = s:DataFrameConstructor(a:buffer)
  call extend(projectionDataFrameObj, dataFrameObj)
  let projectionDataFrameObj.is_switch_data_frame = 1
  let projectionDataFrameObj.set_projection = function('<SNR>' . s:SID() . '_s:ProjectionDataFrame_set_projection')
  let projectionDataFrameObj.set_pattern = function('<SNR>' . s:SID() . '_s:ProjectionDataFrame_set_pattern')
  let projectionDataFrameObj.print = function('<SNR>' . s:SID() . '_s:ProjectionDataFrame_print')
  let projectionDataFrameObj.DataFrame_print = function('<SNR>' . s:SID() . '_s:DataFrame_print')
  return projectionDataFrameObj
endfunction

function! <SID>s:ProjectionDataFrame_set_projection(projection, projection_type) dict
  let self.projection = a:projection
  let self.projection_type = a:projection_type
endfunction

function! <SID>s:ProjectionDataFrame_set_pattern(pattern) dict
  let self.pattern = a:pattern
endfunction

function! <SID>s:ProjectionDataFrame_print() dict
  call self.DataFrame_print()
  call s:info('projection', self.projection.get_resource_type())
  call s:info('projection_type', self.projection_type)
  call s:info('pattern', self.pattern.get_original())
endfunction

function! s:ResourceDataFrameConstructor(buffer)
  let resourceDataFrameObj = {}
  let dataFrameObj = s:DataFrameConstructor(a:buffer)
  call extend(resourceDataFrameObj, dataFrameObj)
  let resourceDataFrameObj.is_resource_file_data_frame = 1
  let resourceDataFrameObj.set_pattern_list = function('<SNR>' . s:SID() . '_s:ResourceDataFrame_set_pattern_list')
  return resourceDataFrameObj
endfunction

function! <SID>s:ResourceDataFrame_set_pattern_list(pattern_list) dict
  let self.pattern_list = a:pattern_list
endfunction

function! s:GetFileDataFrameConstructor(buffer)
  let getFileDataFrameObj = {}
  let dataFrameObj = s:DataFrameConstructor(a:buffer)
  call extend(getFileDataFrameObj, dataFrameObj)
  let getFileDataFrameObj.is_get_file_data_frame = 1
  let getFileDataFrameObj.set_pattern_list = function('<SNR>' . s:SID() . '_s:GetFileDataFrame_set_pattern_list')
  let getFileDataFrameObj.set_inflector = function('<SNR>' . s:SID() . '_s:GetFileDataFrame_set_inflector')
  let getFileDataFrameObj.set_projection = function('<SNR>' . s:SID() . '_s:GetFileDataFrame_set_projection')
  return getFileDataFrameObj
endfunction

function! <SID>s:GetFileDataFrame_set_pattern_list(pattern_list) dict
  let self.pattern_list = a:pattern_list
endfunction

function! <SID>s:GetFileDataFrame_set_inflector(inflector) dict
  let self.inflector = a:inflector
endfunction

function! <SID>s:GetFileDataFrame_set_projection(projection) dict
  let self.projection = a:projection
endfunction

function! s:FileTemplateDataFrameConstructor(buffer)
  let fileTemplateDataFrameObj = {}
  let dataFrameObj = s:DataFrameConstructor(a:buffer)
  call extend(fileTemplateDataFrameObj, dataFrameObj)
  let fileTemplateDataFrameObj.is_file_template_data_frame = 1
  return fileTemplateDataFrameObj
endfunction

" included: 'finder.riml'
function! s:FinderConstructor()
  let finderObj = {}
  let finderObj.finders = s:ObjectCacheConstructor()
  let finderObj.add_finder = function('<SNR>' . s:SID() . '_s:Finder_add_finder')
  let finderObj.find = function('<SNR>' . s:SID() . '_s:Finder_find')
  let finderObj.get_finders = function('<SNR>' . s:SID() . '_s:Finder_get_finders')
  return finderObj
endfunction

function! <SID>s:Finder_add_finder(type, finder) dict
  call self.finders.insert(a:type, a:finder)
endfunction

function! <SID>s:Finder_find(type, context) dict
  let collector = s:FinderCollectorConstructor()
  let finders = self.get_finders(a:type)
  let files = []
  for finder in finders
    let proceed = finder.find(a:context, collector)
    if !(proceed)
      break
    endif
  endfor
  return collector.get_results()
endfunction

function! <SID>s:Finder_get_finders(type) dict
  if self.finders.has(a:type)
    return self.finders.get(a:type)
  else
    return []
  endif
endfunction

function! s:FinderCollectorConstructor()
  let finderCollectorObj = {}
  let finderCollectorObj.results = []
  let finderCollectorObj.map = {}
  let finderCollectorObj.get_results = function('<SNR>' . s:SID() . '_s:FinderCollector_get_results')
  let finderCollectorObj.add = function('<SNR>' . s:SID() . '_s:FinderCollector_add')
  let finderCollectorObj.insert = function('<SNR>' . s:SID() . '_s:FinderCollector_insert')
  let finderCollectorObj.remove = function('<SNR>' . s:SID() . '_s:FinderCollector_remove')
  let finderCollectorObj.has = function('<SNR>' . s:SID() . '_s:FinderCollector_has')
  return finderCollectorObj
endfunction

function! <SID>s:FinderCollector_get_results() dict
  return self.results
endfunction

function! <SID>s:FinderCollector_add(...) dict
  for path in a:000
    if !(self.has(path))
      call add(self.results, path)
      let self.map[path] = 1
    endif
  endfor
endfunction

function! <SID>s:FinderCollector_insert(...) dict
  for path in a:000
    if !(self.has(path))
      call insert(self.results, path)
    endif
  endfor
endfunction

function! <SID>s:FinderCollector_remove(path) dict
  if self.has(a:path)
    unlet self.map[a:path]
    let i = index(self.results, a:path)
    call remove(self.results, i)
  endif
endfunction

function! <SID>s:FinderCollector_has(path) dict
  return has_key(self.map, a:path)
endfunction

" included: 'finder_matcher.riml'
function! s:FinderMatcherConstructor()
  let finderMatcherObj = {}
  let finderMatcherObj.shorten = function('<SNR>' . s:SID() . '_s:FinderMatcher_shorten')
  let finderMatcherObj.match = function('<SNR>' . s:SID() . '_s:FinderMatcher_match')
  let finderMatcherObj.sort = function('<SNR>' . s:SID() . '_s:FinderMatcher_sort')
  let finderMatcherObj.compare_filenames = function('<SNR>' . s:SID() . '_s:FinderMatcher_compare_filenames')
  let finderMatcherObj.match_filename = function('<SNR>' . s:SID() . '_s:FinderMatcher_match_filename')
  let finderMatcherObj.subst_filename = function('<SNR>' . s:SID() . '_s:FinderMatcher_subst_filename')
  let finderMatcherObj.find_common_parent = function('<SNR>' . s:SID() . '_s:FinderMatcher_find_common_parent')
  let finderMatcherObj.find_common_extension = function('<SNR>' . s:SID() . '_s:FinderMatcher_find_common_extension')
  return finderMatcherObj
endfunction

function! <SID>s:FinderMatcher_shorten(results) dict
  let names = []
  let common_parent = self.find_common_parent(a:results)
  let common_ext = self.find_common_extension(a:results)
  let parent_len = len(common_parent)
  let ext_len = len(common_ext)
  for result in a:results
    let result_len = len(result)
    if ext_len !=# 0
      let name = strpart(result, parent_len, result_len - parent_len - ext_len - 1)
    else
      let name = strpart(result, parent_len)
    endif
    call add(names, name)
  endfor
  return names
endfunction

function! <SID>s:FinderMatcher_match(filename, results) dict
  let common_parent = self.find_common_parent(a:results)
  let common_ext = self.find_common_extension(a:results)
  if common_ext !=# ''
    let common_ext = "." . common_ext
  endif
  for result in a:results
    let filename_pattern = common_parent . a:filename . common_ext . "$"
    if result =~# filename_pattern
      return result
    endif
  endfor
  return ''
endfunction

function! <SID>s:FinderMatcher_sort(results) dict
  let sort_function = s:new_delegate(self, 'compare_filenames')
  call sort(a:results, sort_function)
endfunction

function! <SID>s:FinderMatcher_compare_filenames(a, b) dict
  let len_a = len(a:a)
  let len_b = len(a:b)
  return len_a - len_b
endfunction

function! <SID>s:FinderMatcher_match_filename(filename, result) dict
  let sub_filename = self.subst_filename(a:filename, a:result)
  return sub_filename ==# a:result
endfunction

function! <SID>s:FinderMatcher_subst_filename(filename, result) dict
  let parent_dir = fnamemodify(a:result, ':h')
  let root_name = fnamemodify(a:result, ':t:r')
  let ext = fnamemodify(a:result, ':e')
  if parent_dir ==# '' || parent_dir ==# '.'
    return a:filename . "." . ext
  else
    return parent_dir . "/" . a:filename . "." . ext
  endif
endfunction

function! <SID>s:FinderMatcher_find_common_parent(list) dict
  let n = len(a:list)
  if n ==# 0
    return ''
  elseif n ==# 1
    let parent_dir = fnamemodify(a:list[0], ':h')
    let parent_dir_len = len(parent_dir)
    if parent_dir ==# '' || parent_dir ==# '.'
      return ''
    elseif parent_dir[parent_dir_len - 1] !=# '/'
      return parent_dir . '/'
    else
      return parent_dir
    endif
  endif
  let start = a:list[0]
  let prefix_len = strlen(start)
  for str in a:list
    let i = 0
    while i <# prefix_len
      if str[i] !=# start[i]
        let prefix_len = i
        break
      endif
      let i += 1
    endwhile
    if prefix_len ==# 0
      break
    endif
  endfor
  let common_parent = strpart(start, 0, prefix_len)
  let n = len(common_parent)
  if n >=# 1
    if common_parent[n - 1] ==# '/'
      return common_parent
    elseif common_parent =~# '/'
      return fnamemodify(common_parent, ':h') . '/'
    else
      return ''
    endif
  else
    return ''
  endif
endfunction

function! <SID>s:FinderMatcher_find_common_extension(results) dict
  let n = len(a:results)
  if n ># 1
    let ext = fnamemodify(a:results[0], ':e')
    let pattern = '\v' . ext . '$'
    for result in a:results
      if !(result =~# pattern)
        return ''
      endif
    endfor
    return ext
  elseif n ==# 1
    let ext = fnamemodify(a:results[0], ':e')
    return ext
  else
    return ''
  endif
endfunction

" included: 'projection_finder.riml'
function! s:ProjectionFinderConstructor(projector)
  let projectionFinderObj = {}
  let projectionFinderObj.projector = a:projector
  let projectionFinderObj.find = function('<SNR>' . s:SID() . '_s:ProjectionFinder_find')
  let projectionFinderObj.is_readable = function('<SNR>' . s:SID() . '_s:ProjectionFinder_is_readable')
  return projectionFinderObj
endfunction

function! <SID>s:ProjectionFinder_find(context, collector) dict
  let projection = a:context.lookup('projection')
  let projection_type = a:context.lookup('projection_type')
  let buffer = a:context.lookup('buffer')
  let root = buffer.get_abs_root()
  let templates = self.projector.get_projection_templates(projection, projection_type, a:context)
  for template in templates
    call a:collector.add(template)
  endfor
  return 1
endfunction

function! <SID>s:ProjectionFinder_is_readable(file) dict
  if has_key(self, 'readable')
    return self.readable
  endif
  return filereadable(a:file)
endfunction

" included: 'resource_finder.riml'
function! s:ResourceFinderConstructor()
  let resourceFinderObj = {}
  let resourceFinderObj.needs = function('<SNR>' . s:SID() . '_s:ResourceFinder_needs')
  let resourceFinderObj.find = function('<SNR>' . s:SID() . '_s:ResourceFinder_find')
  return resourceFinderObj
endfunction

function! <SID>s:ResourceFinder_needs() dict
  return ['globber']
endfunction

function! <SID>s:ResourceFinder_find(context, collector) dict
  let pattern_list = a:context.lookup('pattern_list')
  let buffer = a:context.lookup('buffer')
  let abs_root = buffer.get_abs_root()
  let files = []
  for pattern in pattern_list
    let files += self.globber.glob(abs_root, pattern)
  endfor
  let rel_files = []
  for file in files
    if !isdirectory(file)
      let rel_file = substitute(file, abs_root, '', '')
      call a:collector.add(rel_file)
    endif
  endfor
  return 1
endfunction

" included: 'file_finder.riml'
function! s:FileFinderConstructor()
  let fileFinderObj = {}
  let fileFinderObj.find = function('<SNR>' . s:SID() . '_s:FileFinder_find')
  let fileFinderObj.add_candidate = function('<SNR>' . s:SID() . '_s:FileFinder_add_candidate')
  let fileFinderObj.into_pattern = function('<SNR>' . s:SID() . '_s:FileFinder_into_pattern')
  let fileFinderObj.into_rootname = function('<SNR>' . s:SID() . '_s:FileFinder_into_rootname')
  return fileFinderObj
endfunction

function! <SID>s:FileFinder_find(context, collector) dict
  let pattern_list = a:context.lookup('pattern_list')
  let buffer = a:context.lookup('buffer')
  let root = buffer.get_abs_root()
  let src = a:context.lookup('source')
  let candidates = []
  for pattern in pattern_list
    call self.add_candidate(a:collector, root, self.into_pattern(src, pattern))
    call self.add_candidate(a:collector, root, self.into_rootname(src, pattern))
  endfor
  return 1
endfunction

function! <SID>s:FileFinder_add_candidate(collector, root, path) dict
  if filereadable(a:root . a:path)
    call a:collector.add(a:path)
  endif
endfunction

function! <SID>s:FileFinder_into_pattern(source, pattern) dict
  return a:pattern.swap(a:source)
endfunction

function! <SID>s:FileFinder_into_rootname(source, pattern) dict
  let pattern_str = a:pattern.get_original()
  let rootname = fnamemodify(pattern_str, ':t:r')
  return substitute(pattern_str, rootname, a:source, '')
endfunction

" included: 'finder_facade.riml'
function! s:FinderFacadeConstructor()
  let finderFacadeObj = {}
  let finderFacadeObj.needs = function('<SNR>' . s:SID() . '_s:FinderFacade_needs')
  let finderFacadeObj.find = function('<SNR>' . s:SID() . '_s:FinderFacade_find')
  let finderFacadeObj.pick = function('<SNR>' . s:SID() . '_s:FinderFacade_pick')
  let finderFacadeObj.first = function('<SNR>' . s:SID() . '_s:FinderFacade_first')
  let finderFacadeObj.nth = function('<SNR>' . s:SID() . '_s:FinderFacade_nth')
  let finderFacadeObj.find_and_rank = function('<SNR>' . s:SID() . '_s:FinderFacade_find_and_rank')
  return finderFacadeObj
endfunction

function! <SID>s:FinderFacade_needs() dict
  return ['finder', 'ranker', 'matcher']
endfunction

function! <SID>s:FinderFacade_find(type, context) dict
  let results = self.find_and_rank(a:type, a:context)
  return self.matcher.shorten(results)
endfunction

function! <SID>s:FinderFacade_pick(type, context, filename) dict
  let results = self.find_and_rank(a:type, a:context)
  return self.matcher.match(a:filename, results)
endfunction

function! <SID>s:FinderFacade_first(type, context) dict
  return self.nth(a:type, a:context, 1)
endfunction

function! <SID>s:FinderFacade_nth(type, context, index) dict
  let result_index = a:index - 1
  let results = self.find_and_rank(a:type, a:context)
  if len(results) ># result_index
    return results[result_index]
  else
    return ''
  endif
endfunction

function! <SID>s:FinderFacade_find_and_rank(type, context) dict
  let results = self.finder.find(a:type, a:context)
  return self.ranker.rank(a:type, a:context, results)
endfunction

" included: 'map_builder.riml'
function! s:MapBuilderConstructor()
  let mapBuilderObj = {}
  let mapBuilderObj.cmd_mode = 'nnoremap'
  let mapBuilderObj.cmd_options = ''
  let mapBuilderObj.cmd_params = ''
  let mapBuilderObj.cmd_plug = 0
  let mapBuilderObj.append_to = function('<SNR>' . s:SID() . '_s:MapBuilder_append_to')
  let mapBuilderObj.options = function('<SNR>' . s:SID() . '_s:MapBuilder_options')
  let mapBuilderObj.option = function('<SNR>' . s:SID() . '_s:MapBuilder_option')
  let mapBuilderObj.lhs = function('<SNR>' . s:SID() . '_s:MapBuilder_lhs')
  let mapBuilderObj.rhs = function('<SNR>' . s:SID() . '_s:MapBuilder_rhs')
  let mapBuilderObj.mode = function('<SNR>' . s:SID() . '_s:MapBuilder_mode')
  let mapBuilderObj.build = function('<SNR>' . s:SID() . '_s:MapBuilder_build')
  return mapBuilderObj
endfunction

function! <SID>s:MapBuilder_append_to(key, str) dict
  let key = "cmd_" . a:key
  let self[key] = self[key] . " " . a:str
endfunction

function! <SID>s:MapBuilder_options(opts) dict
  for [name, value] in items(a:opts)
    call self.option(name, value)
  endfor
endfunction

function! <SID>s:MapBuilder_option(name, value) dict
  if a:name ==# 'plug' && a:value ==# 1
    let self.cmd_plug = 1
  elseif type(a:value) ==# type(1)
    if a:value ==# 1
      call self.append_to('options', "<" . a:name . ">")
    endif
  else
    call self.append_to('options', "<" . a:name . "> " . a:value)
  endif
endfunction

function! <SID>s:MapBuilder_lhs(str) dict
  let self.cmd_lhs = a:str
endfunction

function! <SID>s:MapBuilder_rhs(str) dict
  let self.cmd_rhs = a:str
endfunction

function! <SID>s:MapBuilder_mode(str) dict
  let self.cmd_mode = a:str
endfunction

function! <SID>s:MapBuilder_build() dict
  let cmd = self.cmd_mode
  let cmd .= ' '
  let cmd .= self.cmd_options
  let cmd .= ' '
  if self.cmd_plug
    let cmd .= '<Plug>'
  endif
  let cmd .= self.cmd_lhs
  if self.cmd_rhs !=# ''
    let cmd .= ' '
    let cmd .= self.cmd_rhs
  endif
  return cmd
endfunction

" included: 'map_loader.riml'
function! s:MapLoaderConstructor(Callback)
  let mapLoaderObj = {}
  let mapLoaderObj.Callback = a:Callback
  let mapLoaderObj.check_conflicts = 0
  let mapLoaderObj.set_check_conflicts = function('<SNR>' . s:SID() . '_s:MapLoader_set_check_conflicts')
  let mapLoaderObj.get_check_conflicts = function('<SNR>' . s:SID() . '_s:MapLoader_get_check_conflicts')
  let mapLoaderObj.load = function('<SNR>' . s:SID() . '_s:MapLoader_load')
  let mapLoaderObj.unload = function('<SNR>' . s:SID() . '_s:MapLoader_unload')
  let mapLoaderObj.do_mapping = function('<SNR>' . s:SID() . '_s:MapLoader_do_mapping')
  let mapLoaderObj.print = function('<SNR>' . s:SID() . '_s:MapLoader_print')
  let mapLoaderObj.get_callback_expr = function('<SNR>' . s:SID() . '_s:MapLoader_get_callback_expr')
  let mapLoaderObj.has_conflict = function('<SNR>' . s:SID() . '_s:MapLoader_has_conflict')
  return mapLoaderObj
endfunction

function! <SID>s:MapLoader_set_check_conflicts(check_conflicts) dict
  let self.check_conflicts = a:check_conflicts
endfunction

function! <SID>s:MapLoader_get_check_conflicts() dict
  return self.check_conflicts
endfunction

function! <SID>s:MapLoader_load(mappings) dict
  call self.do_mapping(a:mappings, 1)
endfunction

function! <SID>s:MapLoader_unload(mappings) dict
  call self.do_mapping(a:mappings, 0)
endfunction

function! <SID>s:MapLoader_do_mapping(mappings, do_load) dict
  for mapping in a:mappings
    let map_keys = mapping.value
    let projection = mapping.source
    let resource_type = projection.get_resource_type()
    if projection.has_mapping() && projection.get_mapping() !=# ''
      let map_keys = projection.get_mapping()
    endif
    let opts = {}
    let opts.buffer = 1
    let opts.silent = 1
    let map_sequence = '<LocalLeader>' . map_keys
    let short_map_sequence = '<LocalLeader>' . map_keys[0]
    let builder = s:MapBuilderConstructor()
    call builder.lhs(map_sequence)
    if a:do_load
      call builder.mode('nnoremap')
      call builder.rhs(self.get_callback_expr(resource_type))
    else
      call builder.mode('nunmap')
      call builder.rhs('')
    endif
    call builder.options(opts)
    let cmd = builder.build()
    let cmd = 'silent! ' . cmd
    if a:do_load && self.has_conflict(map_keys, 0)
      call s:echo_warn("Portkey: Mapping for " . resource_type . " " . map_sequence . " conflicts with " . short_map_sequence)
    endif
    execute cmd
  endfor
endfunction

function! <SID>s:MapLoader_print(mappings) dict
  let i = 0
  for mapping in a:mappings
    let map_keys = mapping.value
    let projection = mapping.source
    let resource_type = projection.get_resource_type()
    if projection.has_mapping() && projection.get_mapping() !=# ''
      let map_keys = projection.get_mapping()
    endif
    let opts = {}
    let opts.buffer = 1
    let opts.silent = 1
    let map_sequence = g:maplocalleader . map_keys
    let short_map_sequence = g:maplocalleader . map_keys[0]
    let line = map_sequence
    let line .= repeat(' ', 10 - len(map_sequence))
    let line .= resource_type
    let line .= repeat(' ', 15 - len(resource_type))
    if self.has_conflict(map_keys, 1)
      let line .= " (Conflicts with " . short_map_sequence . ")"
    endif
    call s:echo_msg(line)
    let i += 1
  endfor
  if i ==# 0
    call s:echo_warn('Portkey: No Mappings Found.')
  endif
endfunction

function! <SID>s:MapLoader_get_callback_expr(arg) dict
  let callback_name = s:get_delegate_name(self.Callback)
  return ":call " . callback_name . "('" . a:arg . "')<CR>"
endfunction

function! <SID>s:MapLoader_has_conflict(keys, force) dict
  if !(self.check_conflicts || a:force)
    return 0
  endif
  let map_sequence = '<LocalLeader>' . a:keys
  let short_map_sequence = '<LocalLeader>' . a:keys[0]
  let map_rhs = maparg(short_map_sequence)
  if map_rhs =~# 'Delegate'
    return 0
  else
    return map_rhs !=# ''
  endif
endfunction

" included: 'syntax_loader.riml'
function! s:SyntaxLoaderConstructor()
  let syntaxLoaderObj = {}
  let syntaxLoaderObj.syntaxes = {}
  let syntaxLoaderObj.register = function('<SNR>' . s:SID() . '_s:SyntaxLoader_register')
  let syntaxLoaderObj.get_syntax = function('<SNR>' . s:SID() . '_s:SyntaxLoader_get_syntax')
  let syntaxLoaderObj.has_syntax = function('<SNR>' . s:SID() . '_s:SyntaxLoader_has_syntax')
  let syntaxLoaderObj.load = function('<SNR>' . s:SID() . '_s:SyntaxLoader_load')
  let syntaxLoaderObj.load_by_pattern = function('<SNR>' . s:SID() . '_s:SyntaxLoader_load_by_pattern')
  return syntaxLoaderObj
endfunction

function! <SID>s:SyntaxLoader_register(resource_type, file) dict
  let self.syntaxes[a:resource_type] = a:file
endfunction

function! <SID>s:SyntaxLoader_get_syntax(resource_type) dict
  return self.syntaxes[a:resource_type]
endfunction

function! <SID>s:SyntaxLoader_has_syntax(resource_type) dict
  return has_key(self.syntaxes, a:resource_type)
endfunction

function! <SID>s:SyntaxLoader_load(resource_type) dict
  if self.has_syntax(a:resource_type)
    let path = self.get_syntax(a:resource_type)
    execute ":runtime! " . path
  endif
endfunction

function! <SID>s:SyntaxLoader_load_by_pattern(filepath) dict
  for [pattern, syntax_file] in items(self.syntaxes)
    if match(a:filepath, "\v" . pattern . "$") >=# 0
      execute ":runtime! " . syntax_file
    endif
  endfor
endfunction

" included: 'make_env.riml'
function! s:MakeEnvConstructor()
  let makeEnvObj = {}
  let makeEnvObj.makeprg = &makeprg
  let makeEnvObj.errorformat = &errorformat
  let makeEnvObj.compiler = get(b:, 'current_compiler', 'null')
  let found_compiler = exists('b:current_compiler')
  let makeEnvObj.found_compiler = found_compiler
  if found_compiler
    let makeEnvObj.compiler = b:current_compiler
  endif
  let makeEnvObj.found_local_dir = haslocaldir()
  let makeEnvObj.dir = getcwd()
  let makeEnvObj.get_makeprg = function('<SNR>' . s:SID() . '_s:MakeEnv_get_makeprg')
  let makeEnvObj.get_errorformat = function('<SNR>' . s:SID() . '_s:MakeEnv_get_errorformat')
  let makeEnvObj.get_dir = function('<SNR>' . s:SID() . '_s:MakeEnv_get_dir')
  let makeEnvObj.has_local_dir = function('<SNR>' . s:SID() . '_s:MakeEnv_has_local_dir')
  let makeEnvObj.has_compiler = function('<SNR>' . s:SID() . '_s:MakeEnv_has_compiler')
  let makeEnvObj.get_compiler = function('<SNR>' . s:SID() . '_s:MakeEnv_get_compiler')
  let makeEnvObj.restore = function('<SNR>' . s:SID() . '_s:MakeEnv_restore')
  let makeEnvObj.chdir = function('<SNR>' . s:SID() . '_s:MakeEnv_chdir')
  return makeEnvObj
endfunction

function! <SID>s:MakeEnv_get_makeprg() dict
  return self.makeprg
endfunction

function! <SID>s:MakeEnv_get_errorformat() dict
  return self.errorformat
endfunction

function! <SID>s:MakeEnv_get_dir() dict
  return self.dir
endfunction

function! <SID>s:MakeEnv_has_local_dir() dict
  return self.found_local_dir
endfunction

function! <SID>s:MakeEnv_has_compiler() dict
  return self.found_compiler
endfunction

function! <SID>s:MakeEnv_get_compiler() dict
  return self.compiler
endfunction

function! <SID>s:MakeEnv_restore() dict
  let &makeprg = self.makeprg
  let &errorformat = self.errorformat
  call self.chdir(self.dir)
  if self.found_compiler
    let b:current_compiler = self.compiler
  elseif exists('b:current_compiler')
    unlet b:current_compiler
  endif
endfunction

function! <SID>s:MakeEnv_chdir(dir) dict
  let cwd = getcwd()
  if cwd !=# a:dir
    if self.has_local_dir()
      execute "chdir " . a:dir
    else
      execute "lchdir " . a:dir
    endif
  endif
endfunction

" included: 'make.riml'
function! s:MakeConstructor()
  let makeObj = {}
  let makeObj.bang = 0
  let makeObj.show_quickfix = 1
  let makeObj.mocked = 0
  let makeObj.use_dispatch_make = 1
  let makeObj.exec_cmd = ''
  let makeObj.is_make = 1
  let makeObj.set_bang = function('<SNR>' . s:SID() . '_s:Make_set_bang')
  let makeObj.get_bang = function('<SNR>' . s:SID() . '_s:Make_get_bang')
  let makeObj.set_dir = function('<SNR>' . s:SID() . '_s:Make_set_dir')
  let makeObj.get_dir = function('<SNR>' . s:SID() . '_s:Make_get_dir')
  let makeObj.set_show_quickfix = function('<SNR>' . s:SID() . '_s:Make_set_show_quickfix')
  let makeObj.get_show_quickfix = function('<SNR>' . s:SID() . '_s:Make_get_show_quickfix')
  let makeObj.set_compiler = function('<SNR>' . s:SID() . '_s:Make_set_compiler')
  let makeObj.get_compiler = function('<SNR>' . s:SID() . '_s:Make_get_compiler')
  let makeObj.set_makeprg = function('<SNR>' . s:SID() . '_s:Make_set_makeprg')
  let makeObj.get_makeprg = function('<SNR>' . s:SID() . '_s:Make_get_makeprg')
  let makeObj.set_errorformat = function('<SNR>' . s:SID() . '_s:Make_set_errorformat')
  let makeObj.get_errorformat = function('<SNR>' . s:SID() . '_s:Make_get_errorformat')
  let makeObj.set_mocked = function('<SNR>' . s:SID() . '_s:Make_set_mocked')
  let makeObj.get_mocked = function('<SNR>' . s:SID() . '_s:Make_get_mocked')
  let makeObj.get_exec_cmd = function('<SNR>' . s:SID() . '_s:Make_get_exec_cmd')
  let makeObj.set_use_dispatch_make = function('<SNR>' . s:SID() . '_s:Make_set_use_dispatch_make')
  let makeObj.get_use_dispatch_make = function('<SNR>' . s:SID() . '_s:Make_get_use_dispatch_make')
  let makeObj.make = function('<SNR>' . s:SID() . '_s:Make_make')
  let makeObj.load_env = function('<SNR>' . s:SID() . '_s:Make_load_env')
  let makeObj.run = function('<SNR>' . s:SID() . '_s:Make_run')
  let makeObj.get_make_cmd = function('<SNR>' . s:SID() . '_s:Make_get_make_cmd')
  return makeObj
endfunction

function! <SID>s:Make_set_bang(bang) dict
  let self.bang = a:bang
endfunction

function! <SID>s:Make_get_bang() dict
  return self.bang
endfunction

function! <SID>s:Make_set_dir(dir) dict
  let self.dir = a:dir
endfunction

function! <SID>s:Make_get_dir() dict
  return self.dir
endfunction

function! <SID>s:Make_set_show_quickfix(show_quickfix) dict
  let self.show_quickfix = a:show_quickfix
endfunction

function! <SID>s:Make_get_show_quickfix() dict
  return self.show_quickfix
endfunction

function! <SID>s:Make_set_compiler(compiler) dict
  let self.compiler = a:compiler
endfunction

function! <SID>s:Make_get_compiler() dict
  return self.compiler
endfunction

function! <SID>s:Make_set_makeprg(makeprg) dict
  let self.makeprg = a:makeprg
endfunction

function! <SID>s:Make_get_makeprg() dict
  return self.makeprg
endfunction

function! <SID>s:Make_set_errorformat(errorformat) dict
  let self.errorformat = a:errorformat
endfunction

function! <SID>s:Make_get_errorformat() dict
  return self.errorformat
endfunction

function! <SID>s:Make_set_mocked(mocked) dict
  let self.mocked = a:mocked
endfunction

function! <SID>s:Make_get_mocked() dict
  return self.mocked
endfunction

function! <SID>s:Make_get_exec_cmd() dict
  return self.exec_cmd
endfunction

function! <SID>s:Make_set_use_dispatch_make(use_dispatch_make) dict
  let self.use_dispatch_make = a:use_dispatch_make
endfunction

function! <SID>s:Make_get_use_dispatch_make() dict
  return self.use_dispatch_make
endfunction

function! <SID>s:Make_make(...) dict
  let env = s:MakeEnvConstructor()
  try
    call self.load_env()
    call self.run(a:000)
  catch /.*/
    let caught_error = 1
  finally
    call env.restore()
  endtry
endfunction

function! <SID>s:Make_load_env() dict
  if has_key(self, 'dir')
    execute ":chdir " . self.dir
  endif
  if has_key(self, 'compiler')
    if !exists('g:speckle_mode')
      execute ":compiler " . self.compiler
    else
      execute ":silent! compiler " . self.compiler
    endif
  endif
  if has_key(self, 'makeprg')
    let &makeprg = self.makeprg
  endif
  if has_key(self, 'errorformat')
    let &errorformat = self.errorformat
  endif
endfunction

function! <SID>s:Make_run(args) dict
  let make_args = join(a:args, ' ')
  let make_cmd = self.get_make_cmd()
  let cmd = ":" . make_cmd . " " . make_args
  if !self.mocked
    execute cmd
    if self.show_quickfix
      cwindow
    endif
  else
    let self.exec_cmd = cmd
  endif
endfunction

function! <SID>s:Make_get_make_cmd() dict
  if exists(':Make') ==# 2 && self.get_use_dispatch_make()
    let cmd = 'Make'
  else
    let cmd = 'make'
  endif
  if self.get_bang()
    let cmd .= '!'
  endif
  return cmd
endfunction

" included: 'command_options.riml'
function! s:CommandOptionsConstructor()
  let commandOptionsObj = {}
  let commandOptionsObj.set_args = function('<SNR>' . s:SID() . '_s:CommandOptions_set_args')
  let commandOptionsObj.get_args = function('<SNR>' . s:SID() . '_s:CommandOptions_get_args')
  let commandOptionsObj.get_nargs = function('<SNR>' . s:SID() . '_s:CommandOptions_get_nargs')
  let commandOptionsObj.get_opts = function('<SNR>' . s:SID() . '_s:CommandOptions_get_opts')
  let commandOptionsObj.set_filename = function('<SNR>' . s:SID() . '_s:CommandOptions_set_filename')
  let commandOptionsObj.get_filename = function('<SNR>' . s:SID() . '_s:CommandOptions_get_filename')
  let commandOptionsObj.set_launchables = function('<SNR>' . s:SID() . '_s:CommandOptions_set_launchables')
  let commandOptionsObj.get_launchables = function('<SNR>' . s:SID() . '_s:CommandOptions_get_launchables')
  let commandOptionsObj.set_append_mode = function('<SNR>' . s:SID() . '_s:CommandOptions_set_append_mode')
  let commandOptionsObj.get_append_mode = function('<SNR>' . s:SID() . '_s:CommandOptions_get_append_mode')
  let commandOptionsObj.get_option = function('<SNR>' . s:SID() . '_s:CommandOptions_get_option')
  let commandOptionsObj.get_word = function('<SNR>' . s:SID() . '_s:CommandOptions_get_word')
  let commandOptionsObj.get_bang = function('<SNR>' . s:SID() . '_s:CommandOptions_get_bang')
  let commandOptionsObj.has_range = function('<SNR>' . s:SID() . '_s:CommandOptions_has_range')
  let commandOptionsObj.get_range = function('<SNR>' . s:SID() . '_s:CommandOptions_get_range')
  let commandOptionsObj.has_count = function('<SNR>' . s:SID() . '_s:CommandOptions_has_count')
  let commandOptionsObj.get_count = function('<SNR>' . s:SID() . '_s:CommandOptions_get_count')
  let commandOptionsObj.set_window_mode = function('<SNR>' . s:SID() . '_s:CommandOptions_set_window_mode')
  let commandOptionsObj.get_window_mode = function('<SNR>' . s:SID() . '_s:CommandOptions_get_window_mode')
  let commandOptionsObj.calc_window_mode = function('<SNR>' . s:SID() . '_s:CommandOptions_calc_window_mode')
  let commandOptionsObj.has_resource_type = function('<SNR>' . s:SID() . '_s:CommandOptions_has_resource_type')
  let commandOptionsObj.get_resource_type = function('<SNR>' . s:SID() . '_s:CommandOptions_get_resource_type')
  let commandOptionsObj.set_resource_type = function('<SNR>' . s:SID() . '_s:CommandOptions_set_resource_type')
  let commandOptionsObj.build_resource_type = function('<SNR>' . s:SID() . '_s:CommandOptions_build_resource_type')
  return commandOptionsObj
endfunction

function! <SID>s:CommandOptions_set_args(args) dict
  let self.args = a:args
  let self.nargs = len(a:args)
  if self.nargs ==# 2
    call self.set_filename(self.args[0])
    let self.opts = self.args[1]
  elseif self.nargs ==# 1
    call self.set_filename('')
    let self.opts = self.args[0]
  else
    call self.set_filename('')
    let self.opts = {}
  endif
endfunction

function! <SID>s:CommandOptions_get_args() dict
  return self.args
endfunction

function! <SID>s:CommandOptions_get_nargs() dict
  return self.nargs
endfunction

function! <SID>s:CommandOptions_get_opts() dict
  return self.opts
endfunction

function! <SID>s:CommandOptions_set_filename(filename) dict
  let self.filename = a:filename
endfunction

function! <SID>s:CommandOptions_get_filename() dict
  return self.filename
endfunction

function! <SID>s:CommandOptions_set_launchables(launchables) dict
  let self.launchables = a:launchables
endfunction

function! <SID>s:CommandOptions_get_launchables() dict
  return self.launchables
endfunction

function! <SID>s:CommandOptions_set_append_mode(append_mode) dict
  let self.append_mode = a:append_mode
endfunction

function! <SID>s:CommandOptions_get_append_mode() dict
  return self.append_mode
endfunction

function! <SID>s:CommandOptions_get_option(name, default) dict
  if has_key(self.opts, a:name)
    return self.opts[a:name]
  else
    return a:default
  endif
endfunction

function! <SID>s:CommandOptions_get_word() dict
  return self.get_option('word', '')
endfunction

function! <SID>s:CommandOptions_get_bang() dict
  return self.get_option('bang', 0)
endfunction

function! <SID>s:CommandOptions_has_range() dict
  return has_key(self.opts, 'range')
endfunction

function! <SID>s:CommandOptions_get_range() dict
  return self.get_option('range', [1, 1])
endfunction

function! <SID>s:CommandOptions_has_count() dict
  return has_key(self.opts, 'count') && self.opts.count ># 0
endfunction

function! <SID>s:CommandOptions_get_count() dict
  if has_key(self.opts, 'count') && self.opts.count ># 0
    return self.opts.count
  else
    return 1
  endif
endfunction

function! <SID>s:CommandOptions_set_window_mode(window_mode) dict
  let self.window_mode = a:window_mode
endfunction

function! <SID>s:CommandOptions_get_window_mode() dict
  if !(has_key(self, 'window_mode'))
    let self.window_mode = self.calc_window_mode()
  endif
  return self.window_mode
endfunction

function! <SID>s:CommandOptions_calc_window_mode() dict
  if !(has_key(self.opts, 'match'))
    return 'e'
  endif
  let opts = self.opts
  let match = opts.match
  let match_len = strlen(match)
  if match =~# '^CtrlP'
    if has_key(opts, 'mode')
      let mode = opts.mode
    else
      let mode = 'e'
    endif
  elseif match_len ==# 2
    let mode = match[1]
  elseif match_len ># 2
    let mode = tolower(match[0])
    if self.has_range() && mode ==# 'd'
      let mode = 'e'
    endif
  elseif match_len ==# 1
    let mode = 'e'
  else
    let mode = 'e'
  endif
  return tolower(mode)
endfunction

function! <SID>s:CommandOptions_has_resource_type() dict
  return has_key(self, 'resource_type')
endfunction

function! <SID>s:CommandOptions_get_resource_type() dict
  if !(has_key(self, 'resource_type'))
    let self.resource_type = self.build_resource_type()
  endif
  return self.resource_type
endfunction

function! <SID>s:CommandOptions_set_resource_type(resource_type) dict
  let self.resource_type = a:resource_type
endfunction

function! <SID>s:CommandOptions_build_resource_type() dict
  if has_key(self.opts, 'cmd_line')
    let cmd_line = self.opts.cmd_line
  elseif has_key(self.opts, 'match')
    let cmd_line = self.opts.match
  else
    let cmd_line = ''
  endif
  let pattern = '\v^([^\w]*)(CtrlP|\u)(\w+)\s*'
  let matches = matchlist(cmd_line, pattern)
  if len(matches) ># 0
    let resource_type = matches[3]
    return resource_type
  else
    return 'unknown'
  endif
endfunction

" included: 'completer.riml'
function! s:CompleterConstructor()
  let completerObj = {}
  let completerObj.needs = function('<SNR>' . s:SID() . '_s:Completer_needs')
  let completerObj.complete = function('<SNR>' . s:SID() . '_s:Completer_complete')
  let completerObj.filter = function('<SNR>' . s:SID() . '_s:Completer_filter')
  return completerObj
endfunction

function! <SID>s:Completer_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:Completer_complete(finder_context, options) dict
  let query_type = a:finder_context.get_query_type(a:options)
  let template_context = a:finder_context.get_template_context(a:options)
  let results = self.finder_facade.find(query_type, template_context)
  return self.filter(results, a:options)
endfunction

function! <SID>s:Completer_filter(results, options) dict
  let word = a:options.get_word()
  if word !=# ''
    return filter(a:results, "v:val =~ '^" . word . "'")
  else
    return a:results
  endif
endfunction

" included: 'finder_context.riml'
function! s:FinderContextConstructor()
  let finderContextObj = {}
  let finderContextObj.lookup = function('<SNR>' . s:SID() . '_s:FinderContext_lookup')
  let finderContextObj.buffer_has_projection = function('<SNR>' . s:SID() . '_s:FinderContext_buffer_has_projection')
  let finderContextObj.buffer_has_context = function('<SNR>' . s:SID() . '_s:FinderContext_buffer_has_context')
  let finderContextObj.buffer_has_enrolled = function('<SNR>' . s:SID() . '_s:FinderContext_buffer_has_enrolled')
  let finderContextObj.get_current_buffer = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_buffer')
  let finderContextObj.get_current_buffer_path = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_buffer_path')
  let finderContextObj.get_current_buffer_filename = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_buffer_filename')
  let finderContextObj.get_current_buffer_rootname = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_buffer_rootname')
  let finderContextObj.get_current_contexts = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_contexts')
  let finderContextObj.get_current_context = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_context')
  let finderContextObj.get_current_root = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_root')
  let finderContextObj.get_current_projection = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_projection')
  let finderContextObj.get_current_projections = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_projections')
  let finderContextObj.get_current_pattern = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_pattern')
  let finderContextObj.get_current_resource_type = function('<SNR>' . s:SID() . '_s:FinderContext_get_current_resource_type')
  return finderContextObj
endfunction

function! <SID>s:FinderContext_lookup(name) dict
  return self.container.lookup(a:name)
endfunction

function! <SID>s:FinderContext_buffer_has_projection() dict
  return self.get_current_buffer().has_projection()
endfunction

function! <SID>s:FinderContext_buffer_has_context() dict
  return self.get_current_contexts().contains(self.get_current_root())
endfunction

function! <SID>s:FinderContext_buffer_has_enrolled() dict
  return self.get_current_buffer().get_enrolled()
endfunction

function! <SID>s:FinderContext_get_current_buffer() dict
  return self.lookup('buffers').get_current()
endfunction

function! <SID>s:FinderContext_get_current_buffer_path() dict
  return self.get_current_buffer().get_rel_path()
endfunction

function! <SID>s:FinderContext_get_current_buffer_filename() dict
  return self.get_current_buffer().get_filename()
endfunction

function! <SID>s:FinderContext_get_current_buffer_rootname() dict
  return self.get_current_buffer().get_rootname()
endfunction

function! <SID>s:FinderContext_get_current_contexts() dict
  return self.lookup('contexts')
endfunction

function! <SID>s:FinderContext_get_current_context() dict
  return self.get_current_contexts().get(self.get_current_root())
endfunction

function! <SID>s:FinderContext_get_current_root() dict
  return self.get_current_buffer().get_abs_root()
endfunction

function! <SID>s:FinderContext_get_current_projection() dict
  return self.get_current_buffer().get_projection()
endfunction

function! <SID>s:FinderContext_get_current_projections() dict
  return self.get_current_context().get_projections()
endfunction

function! <SID>s:FinderContext_get_current_pattern() dict
  return self.get_current_buffer().get_pattern()
endfunction

function! <SID>s:FinderContext_get_current_resource_type() dict
  return self.get_current_projection().get_resource_type()
endfunction

" included: 'alternate_finder_context.riml'
function! s:AlternateFinderContextConstructor()
  let alternateFinderContextObj = {}
  let finderContextObj = s:FinderContextConstructor()
  call extend(alternateFinderContextObj, finderContextObj)
  let alternateFinderContextObj.get_query_type = function('<SNR>' . s:SID() . '_s:AlternateFinderContext_get_query_type')
  let alternateFinderContextObj.get_template_context = function('<SNR>' . s:SID() . '_s:AlternateFinderContext_get_template_context')
  return alternateFinderContextObj
endfunction

function! <SID>s:AlternateFinderContext_get_query_type(options) dict
  return 'projection'
endfunction

function! <SID>s:AlternateFinderContext_get_template_context(options) dict
  let buffer = self.get_current_buffer()
  let match = buffer.get_match()
  let pattern = match.get_pattern()
  let projection = pattern.get_projection()
  let source_name = match.get_source()
  let data_frame = s:ProjectionDataFrameConstructor(buffer)
  call data_frame.set_projection(projection, 'alternate')
  call data_frame.set_source(source_name)
  call data_frame.set_source_path(buffer.get_rel_path())
  call data_frame.set_pattern(pattern)
  let template_context = s:TemplateContextConstructor(data_frame)
  return template_context
endfunction

" included: 'resource_finder_context.riml'
function! s:ResourceFinderContextConstructor()
  let resourceFinderContextObj = {}
  let finderContextObj = s:FinderContextConstructor()
  call extend(resourceFinderContextObj, finderContextObj)
  let resourceFinderContextObj.get_query_type = function('<SNR>' . s:SID() . '_s:ResourceFinderContext_get_query_type')
  let resourceFinderContextObj.get_template_context = function('<SNR>' . s:SID() . '_s:ResourceFinderContext_get_template_context')
  return resourceFinderContextObj
endfunction

function! <SID>s:ResourceFinderContext_get_query_type(options) dict
  return 'resource'
endfunction

function! <SID>s:ResourceFinderContext_get_template_context(options) dict
  let resource_type = a:options.get_resource_type()
  let projections = self.get_current_projections()
  let projection = projections.find_by_resource_type(resource_type)
  let pattern_list = projection.get_patterns()
  let buffer = self.get_current_buffer()
  let data_frame = s:ResourceDataFrameConstructor(buffer)
  call data_frame.set_pattern_list(pattern_list)
  if buffer.has_projection()
    call data_frame.set_source(buffer.get_source())
    call data_frame.set_source_path(buffer.get_rel_path())
  endif
  let context = s:TemplateContextConstructor(data_frame)
  return context
endfunction

" included: 'related_finder_context.riml'
function! s:RelatedFinderContextConstructor()
  let relatedFinderContextObj = {}
  let finderContextObj = s:FinderContextConstructor()
  call extend(relatedFinderContextObj, finderContextObj)
  let relatedFinderContextObj.get_query_type = function('<SNR>' . s:SID() . '_s:RelatedFinderContext_get_query_type')
  let relatedFinderContextObj.get_template_context = function('<SNR>' . s:SID() . '_s:RelatedFinderContext_get_template_context')
  return relatedFinderContextObj
endfunction

function! <SID>s:RelatedFinderContext_get_query_type(options) dict
  return 'projection'
endfunction

function! <SID>s:RelatedFinderContext_get_template_context(options) dict
  let buffer = self.get_current_buffer()
  let match = buffer.get_match()
  let pattern = match.get_pattern()
  let projection = pattern.get_projection()
  let source_name = match.get_source()
  let data_frame = s:ProjectionDataFrameConstructor(buffer)
  call data_frame.set_projection(projection, 'related')
  call data_frame.set_source(source_name)
  call data_frame.set_source_path(buffer.get_rel_path())
  call data_frame.set_pattern(pattern)
  let template_context = s:TemplateContextConstructor(data_frame)
  return template_context
endfunction

" included: 'test_finder_context.riml'
function! s:TestFinderContextConstructor()
  let testFinderContextObj = {}
  let finderContextObj = s:FinderContextConstructor()
  call extend(testFinderContextObj, finderContextObj)
  let testFinderContextObj.get_query_type = function('<SNR>' . s:SID() . '_s:TestFinderContext_get_query_type')
  let testFinderContextObj.get_template_context = function('<SNR>' . s:SID() . '_s:TestFinderContext_get_template_context')
  return testFinderContextObj
endfunction

function! <SID>s:TestFinderContext_get_query_type(options) dict
  return 'projection'
endfunction

function! <SID>s:TestFinderContext_get_template_context(options) dict
  let buffer = self.get_current_buffer()
  let match = buffer.get_match()
  let pattern = match.get_pattern()
  let projection = pattern.get_projection()
  let source_name = match.get_source()
  let data_frame = s:ProjectionDataFrameConstructor(buffer)
  call data_frame.set_projection(projection, 'test')
  call data_frame.set_source(source_name)
  call data_frame.set_source_path(buffer.get_rel_path())
  call data_frame.set_pattern(pattern)
  let template_context = s:TemplateContextConstructor(data_frame)
  return template_context
endfunction

" included: 'get_file_finder_context.riml'
function! s:GetFileFinderContextConstructor()
  let getFileFinderContextObj = {}
  let finderContextObj = s:FinderContextConstructor()
  call extend(getFileFinderContextObj, finderContextObj)
  let getFileFinderContextObj.get_query_type = function('<SNR>' . s:SID() . '_s:GetFileFinderContext_get_query_type')
  let getFileFinderContextObj.get_template_context = function('<SNR>' . s:SID() . '_s:GetFileFinderContext_get_template_context')
  return getFileFinderContextObj
endfunction

function! <SID>s:GetFileFinderContext_get_query_type(options) dict
  return 'file'
endfunction

function! <SID>s:GetFileFinderContext_get_template_context(options) dict
  let name_fragment = a:options.get_filename()
  let buffer = self.get_current_buffer()
  let projections = self.get_current_projections()
  let patterns = projections.get_patterns('asc')
  let data_frame = s:GetFileDataFrameConstructor(buffer)
  call data_frame.set_pattern_list(patterns)
  call data_frame.set_source(name_fragment)
  call data_frame.set_source_path(buffer.get_rel_path())
  call data_frame.set_inflector(self.lookup('inflector'))
  call data_frame.set_projection(self.get_current_projection())
  let template_context = s:TemplateContextConstructor(data_frame)
  return template_context
endfunction

" included: 'extractor.riml'
function! s:ExtractorConstructor()
  let extractorObj = {}
  let extractorObj.match = function('<SNR>' . s:SID() . '_s:Extractor_match')
  let extractorObj.change_source = function('<SNR>' . s:SID() . '_s:Extractor_change_source')
  let extractorObj.change_destination = function('<SNR>' . s:SID() . '_s:Extractor_change_destination')
  return extractorObj
endfunction

function! <SID>s:Extractor_match(context) dict
  return 0
endfunction

function! <SID>s:Extractor_change_source(lines, mode, range) dict
endfunction

function! <SID>s:Extractor_change_destination(lines, mode, range) dict
endfunction

" included: 'extractor_collection.riml'
function! s:ExtractorCollectionConstructor()
  let extractorCollectionObj = {}
  let extractorCollectionObj.extractors = []
  let extractorCollectionObj.add_extractor = function('<SNR>' . s:SID() . '_s:ExtractorCollection_add_extractor')
  let extractorCollectionObj.remove_extractor = function('<SNR>' . s:SID() . '_s:ExtractorCollection_remove_extractor')
  let extractorCollectionObj.get_all_extractors = function('<SNR>' . s:SID() . '_s:ExtractorCollection_get_all_extractors')
  let extractorCollectionObj.has_extractor = function('<SNR>' . s:SID() . '_s:ExtractorCollection_has_extractor')
  let extractorCollectionObj.find_extractor = function('<SNR>' . s:SID() . '_s:ExtractorCollection_find_extractor')
  let extractorCollectionObj.size = function('<SNR>' . s:SID() . '_s:ExtractorCollection_size')
  return extractorCollectionObj
endfunction

function! <SID>s:ExtractorCollection_add_extractor(extractor) dict
  call insert(self.extractors, a:extractor)
endfunction

function! <SID>s:ExtractorCollection_remove_extractor(name) dict
  let i = 0
  for extractor in self.extractors
    if extractor.get_name() ==# a:name
      call remove(self.extractors, i)
      break
    endif
    let i += 1
  endfor
endfunction

function! <SID>s:ExtractorCollection_get_all_extractors() dict
  return self.extractors
endfunction

function! <SID>s:ExtractorCollection_has_extractor(name) dict
  let i = 0
  for extractor in self.extractors
    if extractor.get_name() ==# a:name
      return 1
    endif
    let i += 1
  endfor
  return 0
endfunction

function! <SID>s:ExtractorCollection_find_extractor(context) dict
  for extractor in self.extractors
    if extractor.match(a:context)
      return extractor
    endif
  endfor
  return {'is_extractor': 0}
endfunction

function! <SID>s:ExtractorCollection_size() dict
  return len(self.extractors)
endfunction

" included: 'lines_extractor.riml'
function! s:LinesExtractorConstructor()
  let linesExtractorObj = {}
  let linesExtractorObj.is_lines_extractor = 1
  let linesExtractorObj.is_extractor = 1
  let linesExtractorObj.match = function('<SNR>' . s:SID() . '_s:LinesExtractor_match')
  let linesExtractorObj.change_source = function('<SNR>' . s:SID() . '_s:LinesExtractor_change_source')
  let linesExtractorObj.change_destination = function('<SNR>' . s:SID() . '_s:LinesExtractor_change_destination')
  return linesExtractorObj
endfunction

function! <SID>s:LinesExtractor_match(context) dict
  return 1
endfunction

function! <SID>s:LinesExtractor_change_source(start_line, end_line, opts) dict
  let cmd = ":" . a:start_line . "," . a:end_line . "d"
  execute cmd
endfunction

function! <SID>s:LinesExtractor_change_destination(lines, opts) dict
  if a:opts.get_append_mode()
    call append(line('$'), a:lines)
  else
    call setline(1, a:lines)
  endif
endfunction

" included: 'extension.riml'
function! s:ExtensionConstructor()
  let extensionObj = {}
  let extensionObj.get_name = function('<SNR>' . s:SID() . '_s:Extension_get_name')
  let extensionObj.get_portkey_path = function('<SNR>' . s:SID() . '_s:Extension_get_portkey_path')
  let extensionObj.get_scope = function('<SNR>' . s:SID() . '_s:Extension_get_scope')
  let extensionObj.get_finder = function('<SNR>' . s:SID() . '_s:Extension_get_finder')
  let extensionObj.get_ranker = function('<SNR>' . s:SID() . '_s:Extension_get_ranker')
  let extensionObj.get_syntax_files = function('<SNR>' . s:SID() . '_s:Extension_get_syntax_files')
  let extensionObj.configure_inflector = function('<SNR>' . s:SID() . '_s:Extension_configure_inflector')
  let extensionObj.configure_projection = function('<SNR>' . s:SID() . '_s:Extension_configure_projection')
  let extensionObj.get_filters = function('<SNR>' . s:SID() . '_s:Extension_get_filters')
  let extensionObj.get_extractors = function('<SNR>' . s:SID() . '_s:Extension_get_extractors')
  return extensionObj
endfunction

function! <SID>s:Extension_get_name() dict
endfunction

function! <SID>s:Extension_get_portkey_path(type, variant) dict
endfunction

function! <SID>s:Extension_get_scope() dict
endfunction

function! <SID>s:Extension_get_finder(type) dict
endfunction

function! <SID>s:Extension_get_ranker(type) dict
endfunction

function! <SID>s:Extension_get_syntax_files() dict
endfunction

function! <SID>s:Extension_configure_inflector(inflector) dict
endfunction

function! <SID>s:Extension_configure_projection(projection) dict
endfunction

function! <SID>s:Extension_get_filters() dict
endfunction

function! <SID>s:Extension_get_extractors() dict
endfunction

" included: 'extension_collection.riml'
function! s:ExtensionCollectionConstructor()
  let extensionCollectionObj = {}
  let extensionCollectionObj.extensions = {}
  let extensionCollectionObj.add_extension = function('<SNR>' . s:SID() . '_s:ExtensionCollection_add_extension')
  let extensionCollectionObj.remove_extension = function('<SNR>' . s:SID() . '_s:ExtensionCollection_remove_extension')
  let extensionCollectionObj.has_extension = function('<SNR>' . s:SID() . '_s:ExtensionCollection_has_extension')
  let extensionCollectionObj.get_extension = function('<SNR>' . s:SID() . '_s:ExtensionCollection_get_extension')
  let extensionCollectionObj.get_all_extensions = function('<SNR>' . s:SID() . '_s:ExtensionCollection_get_all_extensions')
  let extensionCollectionObj.find_extension_portkey = function('<SNR>' . s:SID() . '_s:ExtensionCollection_find_extension_portkey')
  return extensionCollectionObj
endfunction

function! <SID>s:ExtensionCollection_add_extension(extension) dict
  let self.extensions[a:extension.get_name()] = a:extension
endfunction

function! <SID>s:ExtensionCollection_remove_extension(name) dict
  if self.has_extension(a:name)
    unlet self.extensions[a:name]
  endif
endfunction

function! <SID>s:ExtensionCollection_has_extension(name) dict
  return has_key(self.extensions, a:name)
endfunction

function! <SID>s:ExtensionCollection_get_extension(name) dict
  return self.extensions[a:name]
endfunction

function! <SID>s:ExtensionCollection_get_all_extensions() dict
  return values(self.extensions)
endfunction

function! <SID>s:ExtensionCollection_find_extension_portkey(name) dict
  if self.has_extension(a:name)
    return self.get_extension(a:name).get_portkey_path()
  else
    return ''
  endif
endfunction

" included: 'core_extension.riml'
function! s:CoreExtensionConstructor()
  let coreExtensionObj = {}
  let coreExtensionObj.needs = function('<SNR>' . s:SID() . '_s:CoreExtension_needs')
  let coreExtensionObj.get_name = function('<SNR>' . s:SID() . '_s:CoreExtension_get_name')
  let coreExtensionObj.get_scope = function('<SNR>' . s:SID() . '_s:CoreExtension_get_scope')
  let coreExtensionObj.get_portkey_path = function('<SNR>' . s:SID() . '_s:CoreExtension_get_portkey_path')
  let coreExtensionObj.load = function('<SNR>' . s:SID() . '_s:CoreExtension_load')
  let coreExtensionObj.get_finder = function('<SNR>' . s:SID() . '_s:CoreExtension_get_finder')
  let coreExtensionObj.get_ranker = function('<SNR>' . s:SID() . '_s:CoreExtension_get_ranker')
  let coreExtensionObj.get_syntax_files = function('<SNR>' . s:SID() . '_s:CoreExtension_get_syntax_files')
  let coreExtensionObj.get_extractors = function('<SNR>' . s:SID() . '_s:CoreExtension_get_extractors')
  let coreExtensionObj.configure_inflector = function('<SNR>' . s:SID() . '_s:CoreExtension_configure_inflector')
  let coreExtensionObj.configure_projection = function('<SNR>' . s:SID() . '_s:CoreExtension_configure_projection')
  let coreExtensionObj.get_filters = function('<SNR>' . s:SID() . '_s:CoreExtension_get_filters')
  let coreExtensionObj.lookup = function('<SNR>' . s:SID() . '_s:CoreExtension_lookup')
  return coreExtensionObj
endfunction

function! <SID>s:CoreExtension_needs() dict
  return ['projector']
endfunction

function! <SID>s:CoreExtension_get_name() dict
  return 'core'
endfunction

function! <SID>s:CoreExtension_get_scope() dict
  return 'global'
endfunction

function! <SID>s:CoreExtension_get_portkey_path(type, variant) dict
  return 'portkey.json'
endfunction

function! <SID>s:CoreExtension_load() dict
  return 1
endfunction

function! <SID>s:CoreExtension_get_finder(type) dict
  if a:type ==# 'projection'
    return s:ProjectionFinderConstructor(self.lookup('projector'))
  elseif a:type ==# 'resource'
    return s:ResourceFinderConstructor()
  elseif a:type ==# 'file'
    return s:FileFinderConstructor()
  else
    return 0
  endif
endfunction

function! <SID>s:CoreExtension_get_ranker(type) dict
  if a:type ==# 'projection'
    return s:ProjectionRankerConstructor()
  else
    return 0
  endif
endfunction

function! <SID>s:CoreExtension_get_syntax_files() dict
  return {}
endfunction

function! <SID>s:CoreExtension_get_extractors() dict
  return [s:LinesExtractorConstructor()]
endfunction

function! <SID>s:CoreExtension_configure_inflector(inflector) dict
endfunction

function! <SID>s:CoreExtension_configure_projection(projection) dict
endfunction

function! <SID>s:CoreExtension_get_filters() dict
  return {}
endfunction

function! <SID>s:CoreExtension_lookup(name) dict
  return self.container.lookup(a:name)
endfunction

" included: 'launchable_collection.riml'
function! s:LaunchableCollectionConstructor()
  let launchableCollectionObj = {}
  let launchableCollectionObj.launchables = []
  let launchableCollectionObj.is_launchable_collection = 1
  let launchableCollectionObj.add = function('<SNR>' . s:SID() . '_s:LaunchableCollection_add')
  let launchableCollectionObj.get_all = function('<SNR>' . s:SID() . '_s:LaunchableCollection_get_all')
  let launchableCollectionObj.find = function('<SNR>' . s:SID() . '_s:LaunchableCollection_find')
  let launchableCollectionObj.size = function('<SNR>' . s:SID() . '_s:LaunchableCollection_size')
  return launchableCollectionObj
endfunction

function! <SID>s:LaunchableCollection_add(launchable) dict
  call add(self.launchables, a:launchable)
endfunction

function! <SID>s:LaunchableCollection_get_all() dict
  return self.launchables
endfunction

function! <SID>s:LaunchableCollection_find(strategy) dict
  for launchable in self.launchables
    if launchable.get_strategy() ==# a:strategy
      return launchable
    endif
  endfor
  return {'is_launchable': 0}
endfunction

function! <SID>s:LaunchableCollection_size() dict
  return len(self.launchables)
endfunction

" included: 'launcher.riml'
function! s:LauncherConstructor()
  let launcherObj = {}
  let launcherObj.is_launcher = 1
  let launcherObj.run = function('<SNR>' . s:SID() . '_s:Launcher_run')
  let launcherObj.launch = function('<SNR>' . s:SID() . '_s:Launcher_launch')
  let launcherObj.render_template = function('<SNR>' . s:SID() . '_s:Launcher_render_template')
  let launcherObj.get_file_template_context = function('<SNR>' . s:SID() . '_s:Launcher_get_file_template_context')
  let launcherObj.find_source_name = function('<SNR>' . s:SID() . '_s:Launcher_find_source_name')
  let launcherObj.extract_from_source = function('<SNR>' . s:SID() . '_s:Launcher_extract_from_source')
  let launcherObj.extract_into_destination = function('<SNR>' . s:SID() . '_s:Launcher_extract_into_destination')
  let launcherObj.create_strategy = function('<SNR>' . s:SID() . '_s:Launcher_create_strategy')
  let launcherObj.lookup = function('<SNR>' . s:SID() . '_s:Launcher_lookup')
  let launcherObj.on_inject = function('<SNR>' . s:SID() . '_s:Launcher_on_inject')
  return launcherObj
endfunction

function! <SID>s:Launcher_run(strategies, finder_context, options) dict
  let self.options = a:options
  let launchables = self.lookup('launchables')
  call a:options.set_launchables(launchables)
  for strategy_class in a:strategies
    let strategy = self.create_strategy(strategy_class)
    let filepath = strategy.get_launchable(a:finder_context, a:options)
    let launchable = s:LaunchableConstructor(filepath, strategy_class)
    call launchables.add(launchable)
    if !(filepath ==# '')
      return launchable
    endif
  endfor
  return {'is_launchable': 0}
endfunction

function! <SID>s:Launcher_launch(strategies, finder_context, options) dict
  let launchable = self.run(a:strategies, a:finder_context, a:options)
  if launchable.is_launchable
    let filepath = launchable.filepath
    let create_if_not_found = a:options.get_bang()
    let window_mode = a:options.get_window_mode()
    let buffer_opener = self.lookup('buffer_opener')
    let abs_filepath = buffer_opener.get_abs_path(filepath)
    let file_exists = filereadable(abs_filepath)
    if a:options.has_range()
      call a:options.set_append_mode(file_exists)
      let create_if_not_found = 1
      call self.extract_from_source(a:finder_context, a:options)
    endif
    if (window_mode ==# 'e' || window_mode ==# 'edit') && &hidden ==# 0 && getbufvar(bufname('%'), '&mod')
      let window_mode = 's'
    endif
    let success = buffer_opener.open(filepath, create_if_not_found, window_mode)
    call launchable.set_launched(success)
    if success
      if a:options.has_range()
        call self.extract_into_destination(a:finder_context, a:options)
      elseif !file_exists
        call self.render_template(filepath, a:options)
      endif
    endif
  endif
  return launchable
endfunction

function! <SID>s:Launcher_render_template(filepath, options) dict
  let context = self.get_file_template_context(a:filepath, a:options)
  let projector = self.lookup('projector')
  let template = projector.get_file_template(a:filepath, context)
  if template !=# ''
    let lines = s:str_to_lines(template)
    call setline(1, lines)
  endif
endfunction

function! <SID>s:Launcher_get_file_template_context(filepath, options) dict
  let buffers = self.lookup('buffers')
  let current_buffer = buffers.get_current()
  let source_name = self.find_source_name(a:filepath)
  let data_frame = s:FileTemplateDataFrameConstructor(current_buffer)
  call data_frame.set_source(source_name)
  call data_frame.set_source_path(current_buffer.get_rel_path())
  let template_context = s:TemplateContextConstructor(data_frame)
  return template_context
endfunction

function! <SID>s:Launcher_find_source_name(filepath) dict
  let projections = self.lookup('projections')
  let match = projections.match(a:filepath)
  if match.ok
    return match.get_source()
  else
    return ''
  endif
endfunction

function! <SID>s:Launcher_extract_from_source(finder_context, options) dict
  let extractors = self.lookup('extractors')
  let self.extractor = extractors.find_extractor(a:finder_context)
  if self.extractor.is_extractor
    let [range_start, range_end] = a:options.get_range()
    let self.extracted_lines = getline(range_start, range_end)
    call self.container.inject(self.extractor)
    call self.extractor.change_source(range_start, range_end, a:options)
  endif
endfunction

function! <SID>s:Launcher_extract_into_destination(finder_context, options) dict
  if self.extractor.is_extractor
    call self.extractor.change_destination(self.extracted_lines, a:options)
  endif
endfunction

function! <SID>s:Launcher_create_strategy(klass) dict
  return self.container.lookup(a:klass)
endfunction

function! <SID>s:Launcher_lookup(name) dict
  return self.container.lookup(a:name)
endfunction

function! <SID>s:Launcher_on_inject() dict
  let self.container = self.container.child()
  call self.container.register('launchables', 'LaunchableCollection', 1)
  call self.container.register('buffer_opener', 'BufferOpener', 1)
  call self.container.register('launcher', self)
endfunction

function! s:LaunchableConstructor(filepath, strategy)
  let launchableObj = {}
  let launchableObj.filepath = a:filepath
  let launchableObj.strategy = a:strategy
  let launchableObj.is_launchable = 1
  let launchableObj.launched = 0
  let launchableObj.get_strategy = function('<SNR>' . s:SID() . '_s:Launchable_get_strategy')
  let launchableObj.get_filepath = function('<SNR>' . s:SID() . '_s:Launchable_get_filepath')
  let launchableObj.set_launched = function('<SNR>' . s:SID() . '_s:Launchable_set_launched')
  let launchableObj.get_launched = function('<SNR>' . s:SID() . '_s:Launchable_get_launched')
  return launchableObj
endfunction

function! <SID>s:Launchable_get_strategy() dict
  return self.strategy
endfunction

function! <SID>s:Launchable_get_filepath() dict
  return self.filepath
endfunction

function! <SID>s:Launchable_set_launched(launched) dict
  let self.launched = a:launched
endfunction

function! <SID>s:Launchable_get_launched() dict
  return self.launched
endfunction

" included: 'pick_file_strategy.riml'
function! s:PickFileStrategyConstructor()
  let pickFileStrategyObj = {}
  let pickFileStrategyObj.needs = function('<SNR>' . s:SID() . '_s:PickFileStrategy_needs')
  let pickFileStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:PickFileStrategy_get_launchable')
  return pickFileStrategyObj
endfunction

function! <SID>s:PickFileStrategy_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:PickFileStrategy_get_launchable(finder_context, options) dict
  let query_type = a:finder_context.get_query_type(a:options)
  let filename = a:options.get_filename()
  if filename !=# ''
    let template_context = a:finder_context.get_template_context(a:options)
    return self.finder_facade.pick(query_type, template_context, filename)
  else
    return ''
  endif
endfunction

" included: 'first_file_strategy.riml'
function! s:FirstFileStrategyConstructor()
  let firstFileStrategyObj = {}
  let firstFileStrategyObj.needs = function('<SNR>' . s:SID() . '_s:FirstFileStrategy_needs')
  let firstFileStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:FirstFileStrategy_get_launchable')
  return firstFileStrategyObj
endfunction

function! <SID>s:FirstFileStrategy_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:FirstFileStrategy_get_launchable(finder_context, options) dict
  let query_type = a:finder_context.get_query_type(a:options)
  let template_context = a:finder_context.get_template_context(a:options)
  return self.finder_facade.first(query_type, template_context)
endfunction

" included: 'nth_file_strategy.riml'
function! s:NthFileStrategyConstructor()
  let nthFileStrategyObj = {}
  let nthFileStrategyObj.needs = function('<SNR>' . s:SID() . '_s:NthFileStrategy_needs')
  let nthFileStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:NthFileStrategy_get_launchable')
  return nthFileStrategyObj
endfunction

function! <SID>s:NthFileStrategy_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:NthFileStrategy_get_launchable(finder_context, options) dict
  let query_type = a:finder_context.get_query_type(a:options)
  let filename = a:options.get_filename()
  let template_context = a:finder_context.get_template_context(a:options)
  let index = a:options.get_count()
  return self.finder_facade.nth(query_type, template_context, index)
endfunction

" included: 'new_resource_strategy.riml'
function! s:NewResourceStrategyConstructor()
  let newResourceStrategyObj = {}
  let newResourceStrategyObj.needs = function('<SNR>' . s:SID() . '_s:NewResourceStrategy_needs')
  let newResourceStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:NewResourceStrategy_get_launchable')
  let newResourceStrategyObj.lookup = function('<SNR>' . s:SID() . '_s:NewResourceStrategy_lookup')
  let newResourceStrategyObj.affinize = function('<SNR>' . s:SID() . '_s:NewResourceStrategy_affinize')
  return newResourceStrategyObj
endfunction

function! <SID>s:NewResourceStrategy_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:NewResourceStrategy_get_launchable(finder_context, options) dict
  let filename = a:options.get_filename()
  let resource_type = a:options.get_resource_type()
  if filename ==# ''
    let buffers = self.lookup('buffers')
    let buffer = buffers.get_current()
    if buffer.has_projection()
      let filename = buffer.get_source()
    endif
  endif
  if filename !=# ''
    let filename = fnamemodify(filename, ':r')
    let container = self.container
    let projections = self.container.lookup('projections')
    let projection = projections.find_by_resource_type(resource_type)
    let affinity = projection.get_affinity()
    let filename = self.affinize(filename, affinity)
    return projection.match(filename)
  else
    let query_type = a:finder_context.get_query_type(a:options)
    let template_context = a:finder_context.get_template_context(a:options)
    return self.finder_facade.first(query_type, template_context)
  endif
endfunction

function! <SID>s:NewResourceStrategy_lookup(name) dict
  return self.container.lookup(a:name)
endfunction

function! <SID>s:NewResourceStrategy_affinize(name, affinity) dict
  if a:affinity !=# '' && a:affinity !=# 'null'
    let inflector = self.container.lookup('inflector')
    return inflector.affinize(a:name, a:affinity)
  else
    return a:name
  endif
endfunction

" included: 'test_file_strategy.riml'
function! s:TestFileStrategyConstructor()
  let testFileStrategyObj = {}
  let testFileStrategyObj.needs = function('<SNR>' . s:SID() . '_s:TestFileStrategy_needs')
  let testFileStrategyObj.lookup = function('<SNR>' . s:SID() . '_s:TestFileStrategy_lookup')
  let testFileStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:TestFileStrategy_get_launchable')
  let testFileStrategyObj.is_test = function('<SNR>' . s:SID() . '_s:TestFileStrategy_is_test')
  return testFileStrategyObj
endfunction

function! <SID>s:TestFileStrategy_needs() dict
  return ['finder_facade']
endfunction

function! <SID>s:TestFileStrategy_lookup(name) dict
  return self.container.lookup(a:name)
endfunction

function! <SID>s:TestFileStrategy_get_launchable(finder_context, options) dict
  let buffers = self.lookup('buffers')
  let current_buffer = buffers.get_current()
  let projection = current_buffer.get_projection()
  if !(projection.has_compiler())
    return ''
  endif
  let resource_type = projection.get_resource_type()
  if self.is_test(resource_type)
    let test_file = current_buffer.get_rel_path()
  else
    let query_type = a:finder_context.get_query_type(a:options)
    let template_context = a:finder_context.get_template_context(a:options)
    let test_file = self.finder_facade.first(query_type, template_context)
  endif
  return test_file
endfunction

function! <SID>s:TestFileStrategy_is_test(resource_type) dict
  return a:resource_type =~# 'test$' || a:resource_type =~# 'spec$'
endfunction

" included: 'get_file_strategy.riml'
function! s:GetFileStrategyConstructor()
  let getFileStrategyObj = {}
  let getFileStrategyObj.needs = function('<SNR>' . s:SID() . '_s:GetFileStrategy_needs')
  let getFileStrategyObj.first = function('<SNR>' . s:SID() . '_s:GetFileStrategy_first')
  let getFileStrategyObj.get_launchable = function('<SNR>' . s:SID() . '_s:GetFileStrategy_get_launchable')
  let getFileStrategyObj.get_variant = function('<SNR>' . s:SID() . '_s:GetFileStrategy_get_variant')
  return getFileStrategyObj
endfunction

function! <SID>s:GetFileStrategy_needs() dict
  return ['finder_facade', 'inflector', 'buffers']
endfunction

function! <SID>s:GetFileStrategy_first(filename, finder_context, options) dict
  let query_type = a:finder_context.get_query_type(a:options)
  let template_context = a:finder_context.get_template_context(a:options)
  return self.finder_facade.first(query_type, template_context)
endfunction

function! <SID>s:GetFileStrategy_get_launchable(finder_context, options) dict
  let filename = a:options.get_filename()
  let variant = self.get_variant(filename)
  let result = self.first(variant, a:finder_context, a:options)
  call a:options.set_filename(variant)
  return result
endfunction

function! <SID>s:GetFileStrategy_get_variant(current) dict
  return a:current
endfunction

function! s:StripExtStrategyConstructor()
  let stripExtStrategyObj = {}
  let getFileStrategyObj = s:GetFileStrategyConstructor()
  call extend(stripExtStrategyObj, getFileStrategyObj)
  let stripExtStrategyObj.get_variant = function('<SNR>' . s:SID() . '_s:StripExtStrategy_get_variant')
  return stripExtStrategyObj
endfunction

function! <SID>s:StripExtStrategy_get_variant(current) dict
  return fnamemodify(a:current, ':r')
endfunction

function! s:AffinizeStrategyConstructor()
  let affinizeStrategyObj = {}
  let getFileStrategyObj = s:GetFileStrategyConstructor()
  call extend(affinizeStrategyObj, getFileStrategyObj)
  let affinizeStrategyObj.get_variant = function('<SNR>' . s:SID() . '_s:AffinizeStrategy_get_variant')
  return affinizeStrategyObj
endfunction

function! <SID>s:AffinizeStrategy_get_variant(current) dict
  let current_buffer = self.buffers.get_current()
  let projection = current_buffer.get_projection()
  let affinity = projection.get_affinity()
  if affinity !=# 'null' && affinity !=# ''
    return self.inflector.affinize(a:current, affinity)
  else
    return a:current
  endif
endfunction

function! s:UnderscorizeStrategyConstructor()
  let underscorizeStrategyObj = {}
  let getFileStrategyObj = s:GetFileStrategyConstructor()
  call extend(underscorizeStrategyObj, getFileStrategyObj)
  let underscorizeStrategyObj.get_variant = function('<SNR>' . s:SID() . '_s:UnderscorizeStrategy_get_variant')
  return underscorizeStrategyObj
endfunction

function! <SID>s:UnderscorizeStrategy_get_variant(current) dict
  return self.inflector.underscorize(a:current)
endfunction

function! s:CamelizeStrategyConstructor()
  let camelizeStrategyObj = {}
  let getFileStrategyObj = s:GetFileStrategyConstructor()
  call extend(camelizeStrategyObj, getFileStrategyObj)
  let camelizeStrategyObj.get_variant = function('<SNR>' . s:SID() . '_s:CamelizeStrategy_get_variant')
  return camelizeStrategyObj
endfunction

function! <SID>s:CamelizeStrategy_get_variant(current) dict
  return self.inflector.camelize(a:current)
endfunction

" included: 'portkey_command.riml'
function! s:PortkeyCommandConstructor(container)
  let portkeyCommandObj = {}
  let baseCommandObj = s:BaseCommandConstructor()
  call extend(portkeyCommandObj, baseCommandObj)
  let portkeyCommandObj.container = a:container
  let portkeyCommandObj.lookup = function('<SNR>' . s:SID() . '_s:PortkeyCommand_lookup')
  let portkeyCommandObj.process = function('<SNR>' . s:SID() . '_s:PortkeyCommand_process')
  let portkeyCommandObj.get_env_var = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_env_var')
  let portkeyCommandObj.buffer_has_projection = function('<SNR>' . s:SID() . '_s:PortkeyCommand_buffer_has_projection')
  let portkeyCommandObj.buffer_has_context = function('<SNR>' . s:SID() . '_s:PortkeyCommand_buffer_has_context')
  let portkeyCommandObj.buffer_has_enrolled = function('<SNR>' . s:SID() . '_s:PortkeyCommand_buffer_has_enrolled')
  let portkeyCommandObj.get_current_buffer = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_buffer')
  let portkeyCommandObj.get_current_buffer_path = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_buffer_path')
  let portkeyCommandObj.get_current_buffer_filename = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_buffer_filename')
  let portkeyCommandObj.get_current_buffer_rootname = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_buffer_rootname')
  let portkeyCommandObj.get_current_contexts = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_contexts')
  let portkeyCommandObj.get_current_context = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_context')
  let portkeyCommandObj.get_current_root = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_root')
  let portkeyCommandObj.get_current_projection = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_projection')
  let portkeyCommandObj.get_current_projections = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_projections')
  let portkeyCommandObj.get_current_pattern = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_pattern')
  let portkeyCommandObj.get_current_resource_type = function('<SNR>' . s:SID() . '_s:PortkeyCommand_get_current_resource_type')
  return portkeyCommandObj
endfunction

function! <SID>s:PortkeyCommand_lookup(object) dict
  let c = self.container
  let buffers = c.lookup('buffers')
  if buffers.has_current()
    let current_buffer = buffers.get_current()
    let contexts = c.lookup('contexts')
    let root = current_buffer.get_abs_root()
    if contexts.contains(root)
      let context = contexts.get(root)
      return context.lookup(a:object)
    else
      return c.lookup(a:object)
    endif
  else
    return c.lookup(a:object)
  endif
endfunction

function! <SID>s:PortkeyCommand_process(...) dict
  let registry = self.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! <SID>s:PortkeyCommand_get_env_var(name) dict
  return self.lookup('env').get_option(a:name)
endfunction

function! <SID>s:PortkeyCommand_buffer_has_projection() dict
  return self.get_current_buffer().has_projection()
endfunction

function! <SID>s:PortkeyCommand_buffer_has_context() dict
  return self.get_current_contexts().contains(self.get_current_root())
endfunction

function! <SID>s:PortkeyCommand_buffer_has_enrolled() dict
  return self.get_current_buffer().get_enrolled()
endfunction

function! <SID>s:PortkeyCommand_get_current_buffer() dict
  return self.lookup('buffers').get_current()
endfunction

function! <SID>s:PortkeyCommand_get_current_buffer_path() dict
  return self.get_current_buffer().get_rel_path()
endfunction

function! <SID>s:PortkeyCommand_get_current_buffer_filename() dict
  return self.get_current_buffer().get_filename()
endfunction

function! <SID>s:PortkeyCommand_get_current_buffer_rootname() dict
  return self.get_current_buffer().get_rootname()
endfunction

function! <SID>s:PortkeyCommand_get_current_contexts() dict
  return self.lookup('contexts')
endfunction

function! <SID>s:PortkeyCommand_get_current_context() dict
  return self.get_current_contexts().get(self.get_current_root())
endfunction

function! <SID>s:PortkeyCommand_get_current_root() dict
  return self.get_current_buffer().get_abs_root()
endfunction

function! <SID>s:PortkeyCommand_get_current_projection() dict
  return self.get_current_buffer().get_projection()
endfunction

function! <SID>s:PortkeyCommand_get_current_projections() dict
  return self.get_current_context().get_projections()
endfunction

function! <SID>s:PortkeyCommand_get_current_pattern() dict
  return self.get_current_buffer().get_pattern()
endfunction

function! <SID>s:PortkeyCommand_get_current_resource_type() dict
  return self.get_current_projection().get_resource_type()
endfunction

" included: 'configure_buffer_command.riml'
function! s:ConfigureBufferCommandConstructor(container)
  let configureBufferCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(configureBufferCommandObj, portkeyCommandObj)
  let configureBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ConfigureBufferCommand_get_name')
  let configureBufferCommandObj.run = function('<SNR>' . s:SID() . '_s:ConfigureBufferCommand_run')
  return configureBufferCommandObj
endfunction

function! <SID>s:ConfigureBufferCommand_get_name() dict
  return 'ConfigureBuffer'
endfunction

function! <SID>s:ConfigureBufferCommand_run(buffer, opts) dict
  let container = self.container
  let root = a:buffer.get_abs_root()
  let contexts = container.lookup('contexts')
  if !(contexts.contains(root))
    let success = contexts.add(root)
    if success
      redraw
      echomsg "Portkey: Loading (" . a:buffer.get_portkey_display_path() . ") ... DONE"
    endif
  endif
  if contexts.contains(root)
    let context = contexts.get(root)
    let projections = context.get_projections()
    let match = projections.match(a:buffer.get_rel_path())
    if match.ok
      call a:buffer.set_match(match)
    endif
  endif
endfunction

" included: 'load_buffer_mappings_command.riml'
function! s:LoadBufferMappingsCommandConstructor(container)
  let loadBufferMappingsCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(loadBufferMappingsCommandObj, portkeyCommandObj)
  let loadBufferMappingsCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadBufferMappingsCommand_get_name')
  let loadBufferMappingsCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadBufferMappingsCommand_run')
  return loadBufferMappingsCommandObj
endfunction

function! <SID>s:LoadBufferMappingsCommand_get_name() dict
  return 'LoadBufferMappings'
endfunction

function! <SID>s:LoadBufferMappingsCommand_run(opts) dict
  if s:has_ctrlp_plugin() && self.buffer_has_context() && exists("g:maplocalleader") && self.get_env_var('adaptive_mappings')
    let projections = self.get_current_projections()
    let mappings = projections.get_mappings()
    let env = self.lookup('env')
    let delegate = s:MapDelegateConstructor()
    let Callback = s:create_delegate(delegate, 'invoke')
    let map_loader = s:MapLoaderConstructor(Callback)
    let check_conflicts = env.get_option('warn_on_mapping_conflicts')
    call map_loader.set_check_conflicts(check_conflicts)
    call map_loader.load(mappings)
    nnoremap <LocalLeader><LocalLeader> :PortkeyMappings<CR>
    call env.set_option('warn_on_mapping_conflicts', 0)
  endif
endfunction

function! s:MapDelegateConstructor()
  let mapDelegateObj = {}
  let mapDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:MapDelegate_invoke')
  return mapDelegateObj
endfunction

function! <SID>s:MapDelegate_invoke(resource_type) dict
  let ex_cmd = ":CtrlP" . a:resource_type
  execute ex_cmd
endfunction

" included: 'load_buffer_ex_cmds_command.riml'
function! s:LoadBufferExCmdsCommandConstructor(container)
  let loadBufferExCmdsCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(loadBufferExCmdsCommandObj, portkeyCommandObj)
  let loadBufferExCmdsCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadBufferExCmdsCommand_get_name')
  let loadBufferExCmdsCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadBufferExCmdsCommand_run')
  return loadBufferExCmdsCommandObj
endfunction

function! <SID>s:LoadBufferExCmdsCommand_get_name() dict
  return 'LoadBufferExCmds'
endfunction

function! <SID>s:LoadBufferExCmdsCommand_run(opts) dict
  call self.lookup('registry').register_commands()
  let buffer = self.get_current_buffer()
  let buffer_path = buffer.get_abs_path()
  let portkey_path = buffer.get_abs_portkey_path()
  if buffer_path ==# portkey_path
    let loader = self.lookup('autocmd_loader')
    call loader.set_group_name('portkey_refresh_group')
    call loader.cmd("BufWritePost <buffer> :PortkeyRefresh!")
    call loader.load()
  endif
endfunction

" included: 'load_get_file_command.riml'
function! s:LoadGetFileCommandConstructor(container)
  let loadGetFileCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(loadGetFileCommandObj, portkeyCommandObj)
  let loadGetFileCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadGetFileCommand_get_name')
  let loadGetFileCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:LoadGetFileCommand_has_ex_mode')
  let loadGetFileCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:LoadGetFileCommand_has_ctrlp_mode')
  let loadGetFileCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadGetFileCommand_run')
  return loadGetFileCommandObj
endfunction

function! <SID>s:LoadGetFileCommand_get_name() dict
  return 'LoadGetFile'
endfunction

function! <SID>s:LoadGetFileCommand_has_ex_mode() dict
  return self.buffer_has_projection()
endfunction

function! <SID>s:LoadGetFileCommand_has_ctrlp_mode() dict
  return self.buffer_has_projection()
endfunction

function! <SID>s:LoadGetFileCommand_run(opts) dict
  if !(has_key(self, 'Callback'))
    let DelegateFunc = s:IncludeExprDelegateConstructor(self)
    let self.callback = s:new_delegate(DelegateFunc, 'invoke')
  endif
  let cmd = ":setlocal includeexpr=" . self.callback . "(v:fname)"
  execute cmd
endfunction

function! s:IncludeExprDelegateConstructor(cmd)
  let includeExprDelegateObj = {}
  let includeExprDelegateObj.cmd = a:cmd
  let includeExprDelegateObj.invoke = function('<SNR>' . s:SID() . '_s:IncludeExprDelegate_invoke')
  return includeExprDelegateObj
endfunction

function! <SID>s:IncludeExprDelegate_invoke(filename) dict
  return self.cmd.process('GetFile', a:filename)
endfunction

" included: 'load_syntax_command.riml'
function! s:LoadSyntaxCommandConstructor(container)
  let loadSyntaxCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(loadSyntaxCommandObj, portkeyCommandObj)
  let loadSyntaxCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_get_name')
  let loadSyntaxCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadSyntaxCommand_run')
  return loadSyntaxCommandObj
endfunction

function! <SID>s:LoadSyntaxCommand_get_name() dict
  return 'LoadSyntax'
endfunction

function! <SID>s:LoadSyntaxCommand_run(opts) dict
  if self.buffer_has_projection()
    let resource_type = self.get_current_resource_type()
    let syntax_loader = self.lookup('syntax_loader')
    call syntax_loader.load(resource_type)
    call syntax_loader.load_by_pattern(self.get_current_buffer_path())
  endif
endfunction

" included: 'show_version_command.riml'
function! s:ShowVersionCommandConstructor(container)
  let showVersionCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(showVersionCommandObj, portkeyCommandObj)
  let showVersionCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ShowVersionCommand_get_name')
  let showVersionCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:ShowVersionCommand_has_ex_mode')
  let showVersionCommandObj.run = function('<SNR>' . s:SID() . '_s:ShowVersionCommand_run')
  return showVersionCommandObj
endfunction

function! <SID>s:ShowVersionCommand_get_name() dict
  return 'PortkeyVersion'
endfunction

function! <SID>s:ShowVersionCommand_has_ex_mode() dict
  return 1
endfunction

function! <SID>s:ShowVersionCommand_run(opts) dict
  if self.buffer_has_projection()
    let resource_type = self.get_current_resource_type()
  else
    let resource_type = "unknown"
  endif
  let portkeys = self.get_current_context().get_portkeys()
  let buffer = self.get_current_buffer()
  call s:echo_msg("Portkey: version=" . g:portkey_version)
  call s:echo_msg("Current Resource Type: " . resource_type)
  call s:echo_msg("Portkeys Loaded:")
  let i = 1
  for portkey in portkeys
    call s:echo_msg(i . ". " . buffer.get_portkey_display_path(portkey))
    let i += 1
  endfor
endfunction

" included: 'change_current_buffer_command.riml'
function! s:ChangeCurrentBufferCommandConstructor(container)
  let changeCurrentBufferCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(changeCurrentBufferCommandObj, portkeyCommandObj)
  let changeCurrentBufferCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ChangeCurrentBufferCommand_get_name')
  let changeCurrentBufferCommandObj.run = function('<SNR>' . s:SID() . '_s:ChangeCurrentBufferCommand_run')
  return changeCurrentBufferCommandObj
endfunction

function! <SID>s:ChangeCurrentBufferCommand_get_name() dict
  return 'ChangeCurrentBuffer'
endfunction

function! <SID>s:ChangeCurrentBufferCommand_run(buffer, opts) dict
  call self.lookup('buffers').set_current(a:buffer)
  if self.buffer_has_context() && !self.buffer_has_enrolled()
    call self.process('LoadBufferExCmds')
    call a:buffer.set_enrolled(1)
    call self.process('LoadBufferMappings')
    call self.process('LoadGetFile')
    call self.process('LoadSyntax')
  endif
endfunction

" included: 'load_extension_command.riml'
function! s:LoadExtensionCommandConstructor(container)
  let loadExtensionCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(loadExtensionCommandObj, portkeyCommandObj)
  let loadExtensionCommandObj.get_name = function('<SNR>' . s:SID() . '_s:LoadExtensionCommand_get_name')
  let loadExtensionCommandObj.run = function('<SNR>' . s:SID() . '_s:LoadExtensionCommand_run')
  return loadExtensionCommandObj
endfunction

function! <SID>s:LoadExtensionCommand_get_name() dict
  return 'LoadExtension'
endfunction

function! <SID>s:LoadExtensionCommand_run(extension, opts) dict
  let extensions = self.lookup('extensions')
  call extensions.add_extension(a:extension)
endfunction

" included: 'portkey_refresh_command.riml'
function! s:RefreshCommandConstructor(container)
  let refreshCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(refreshCommandObj, portkeyCommandObj)
  let refreshCommandObj.get_name = function('<SNR>' . s:SID() . '_s:RefreshCommand_get_name')
  let refreshCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:RefreshCommand_has_ex_mode')
  let refreshCommandObj.get_auto_unregister = function('<SNR>' . s:SID() . '_s:RefreshCommand_get_auto_unregister')
  let refreshCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:RefreshCommand_get_bang')
  let refreshCommandObj.run = function('<SNR>' . s:SID() . '_s:RefreshCommand_run')
  return refreshCommandObj
endfunction

function! <SID>s:RefreshCommand_get_name() dict
  return 'PortkeyRefresh'
endfunction

function! <SID>s:RefreshCommand_has_ex_mode() dict
  return 1
endfunction

function! <SID>s:RefreshCommand_get_auto_unregister() dict
  return 0
endfunction

function! <SID>s:RefreshCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:RefreshCommand_run(opts) dict
  if a:opts.bang
    let opts = {}
    let opts.is_option = 1
    let opts.bang = 1
    let opts.silent = 1
    call self.process('PortkeyMappings', opts)
    let env = self.lookup('env')
    call env.load_option('warn_on_mapping_conflicts')
    let contexts = self.get_current_contexts()
    call contexts.remove(self.get_current_root())
  endif
  let buffer = self.get_current_buffer()
  let registry = self.lookup('registry')
  call registry.unregister()
  let buffer_collection = self.lookup('buffers')
  call buffer_collection.clear()
  call self.process('ConfigureBuffer', buffer)
  call self.process('ChangeCurrentBuffer', buffer)
endfunction

" included: 'portkey_mappings_command.riml'
function! s:PortkeyMappingsCommandConstructor(container)
  let portkeyMappingsCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(portkeyMappingsCommandObj, portkeyCommandObj)
  let portkeyMappingsCommandObj.get_name = function('<SNR>' . s:SID() . '_s:PortkeyMappingsCommand_get_name')
  let portkeyMappingsCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:PortkeyMappingsCommand_has_ex_mode')
  let portkeyMappingsCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:PortkeyMappingsCommand_get_bang')
  let portkeyMappingsCommandObj.run = function('<SNR>' . s:SID() . '_s:PortkeyMappingsCommand_run')
  return portkeyMappingsCommandObj
endfunction

function! <SID>s:PortkeyMappingsCommand_get_name() dict
  return 'PortkeyMappings'
endfunction

function! <SID>s:PortkeyMappingsCommand_has_ex_mode() dict
  return 1
endfunction

function! <SID>s:PortkeyMappingsCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:PortkeyMappingsCommand_run(opts) dict
  if !(s:has_ctrlp_plugin())
    call s:echo_error('Portkey: CtrlP plugin not found.')
    return
  endif
  if !(self.buffer_has_context())
    return
  endif
  let projections = self.get_current_projections()
  let mappings = projections.get_mappings()
  let env = self.lookup('env')
  let Callback = s:create_delegate(self, 'null')
  let map_loader = s:MapLoaderConstructor(Callback)
  if a:opts.bang
    call map_loader.unload(mappings)
    silent! nunmap <LocalLeader><LocalLeader>
    if !(has_key(a:opts, 'silent') && a:opts.silent)
      call s:echo_warn('Portkey: mappings cleared.')
    endif
  else
    call map_loader.set_check_conflicts(env.get_option('warn_on_mapping_conflicts'))
    call map_loader.print(mappings)
  endif
endfunction

" included: 'open_portkey_command.riml'
function! s:OpenPortkeyCommandConstructor(controller)
  let openPortkeyCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:controller)
  call extend(openPortkeyCommandObj, portkeyCommandObj)
  let openPortkeyCommandObj.get_name = function('<SNR>' . s:SID() . '_s:OpenPortkeyCommand_get_name')
  let openPortkeyCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:OpenPortkeyCommand_get_aliases')
  let openPortkeyCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:OpenPortkeyCommand_has_ex_mode')
  let openPortkeyCommandObj.run = function('<SNR>' . s:SID() . '_s:OpenPortkeyCommand_run')
  return openPortkeyCommandObj
endfunction

function! <SID>s:OpenPortkeyCommand_get_name() dict
  return 'OpenPortkey'
endfunction

function! <SID>s:OpenPortkeyCommand_get_aliases() dict
  return ['PK']
endfunction

function! <SID>s:OpenPortkeyCommand_has_ex_mode() dict
  return 1
endfunction

function! <SID>s:OpenPortkeyCommand_run(opts) dict
  let portkey_path = self.get_current_buffer().get_portkey_path()
  let portkey_path = fnamemodify(portkey_path, ':.')
  let file_opener = self.lookup('file_opener')
  call file_opener.open(portkey_path, 'e')
endfunction

" included: 'switch_file_command.riml'
function! s:SwitchFileCommandConstructor(container)
  let switchFileCommandObj = {}
  let portkeyCommandObj = s:PortkeyCommandConstructor(a:container)
  call extend(switchFileCommandObj, portkeyCommandObj)
  let switchFileCommandObj.variants = ['E', 'S', 'V', 'T', 'D']
  let switchFileCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_has_ex_mode')
  let switchFileCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_has_ctrlp_mode')
  let switchFileCommandObj.get_ctrlp_aliases = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_ctrlp_aliases')
  let switchFileCommandObj.get_nargs = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_nargs')
  let switchFileCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_bang')
  let switchFileCommandObj.get_completer = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_completer')
  let switchFileCommandObj.complete = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_complete')
  let switchFileCommandObj.run = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_run')
  let switchFileCommandObj.launch = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_launch')
  let switchFileCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_finder_context')
  let switchFileCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_launcher_strategies')
  let switchFileCommandObj.get_error_label = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_error_label')
  let switchFileCommandObj.get_error_msg = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_get_error_msg')
  let switchFileCommandObj.can_complete = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_can_complete')
  let switchFileCommandObj.can_run = function('<SNR>' . s:SID() . '_s:SwitchFileCommand_can_run')
  return switchFileCommandObj
endfunction

function! <SID>s:SwitchFileCommand_has_ex_mode() dict
  return self.buffer_has_context() && self.buffer_has_projection()
endfunction

function! <SID>s:SwitchFileCommand_has_ctrlp_mode() dict
  return self.buffer_has_context() && self.buffer_has_projection()
endfunction

function! <SID>s:SwitchFileCommand_get_ctrlp_aliases() dict
  return [self.get_name()]
endfunction

function! <SID>s:SwitchFileCommand_get_nargs() dict
  return '?'
endfunction

function! <SID>s:SwitchFileCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:SwitchFileCommand_get_completer() dict
  return 'customlist'
endfunction

function! <SID>s:SwitchFileCommand_complete(word, cmd_line, cursor) dict
  let opts = {}
  let opts.word = a:word
  let opts.match = a:cmd_line
  let opts.cursor = a:cursor
  let options = self.lookup('command_options')
  call options.set_args([opts])
  if !(self.can_complete(options))
    return []
  endif
  let finder_context_class = self.get_finder_context()
  let finder_context = self.lookup(finder_context_class)
  let completer = self.lookup('completer')
  let results = completer.complete(finder_context, options)
  return results
endfunction

function! <SID>s:SwitchFileCommand_run(...) dict
  let options = self.lookup('command_options')
  call options.set_args(a:000)
  if !(self.can_run(options))
    let msg = self.get_error_msg({'is_launchable': 0}, options)
    if msg !=# ''
      call s:echo_error(msg)
    endif
    if len(a:000) ==# 2
      return a:000[0]
    else
      return 0
    endif
  endif
  let finder_context_class = self.get_finder_context()
  let finder_context = self.lookup(finder_context_class)
  let strategies = self.get_launcher_strategies()
  return self.launch(strategies, finder_context, options)
endfunction

function! <SID>s:SwitchFileCommand_launch(strategies, finder_context, options) dict
  let launcher = self.lookup('launcher')
  let launchable = launcher.launch(a:strategies, a:finder_context, a:options)
  let msg = self.get_error_msg(launchable, a:options)
  if msg !=# ''
    call s:echo_error(msg)
  endif
  return launchable
endfunction

function! <SID>s:SwitchFileCommand_get_finder_context() dict
  return ''
endfunction

function! <SID>s:SwitchFileCommand_get_launcher_strategies() dict
  return []
endfunction

function! <SID>s:SwitchFileCommand_get_error_label(options) dict
  return self.get_name()
endfunction

function! <SID>s:SwitchFileCommand_get_error_msg(launchable, options) dict
  if a:launchable.is_launchable && a:launchable.get_launched()
    return
  endif
  let inflector = self.lookup('inflector')
  let msg = inflector.titleize(self.get_error_label(a:options))
  if a:launchable.is_launchable
    let filepath = a:launchable.get_filepath()
    let msg .= " not found: " . filepath
  else
    let msg .= " not found for: " . self.get_current_buffer().get_rel_path()
  endif
  return msg
endfunction

function! <SID>s:SwitchFileCommand_can_complete(options) dict
  return self.buffer_has_projection()
endfunction

function! <SID>s:SwitchFileCommand_can_run(options) dict
  return self.buffer_has_projection()
endfunction

" included: 'alternate_file_command.riml'
function! s:AlternateFileCommandConstructor(container)
  let alternateFileCommandObj = {}
  let switchFileCommandObj = s:SwitchFileCommandConstructor(a:container)
  call extend(alternateFileCommandObj, switchFileCommandObj)
  let alternateFileCommandObj.get_name = function('<SNR>' . s:SID() . '_s:AlternateFileCommand_get_name')
  let alternateFileCommandObj.get_count = function('<SNR>' . s:SID() . '_s:AlternateFileCommand_get_count')
  let alternateFileCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:AlternateFileCommand_get_aliases')
  let alternateFileCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:AlternateFileCommand_get_launcher_strategies')
  let alternateFileCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:AlternateFileCommand_get_finder_context')
  return alternateFileCommandObj
endfunction

function! <SID>s:AlternateFileCommand_get_name() dict
  return 'Alternate'
endfunction

function! <SID>s:AlternateFileCommand_get_count() dict
  return 1
endfunction

function! <SID>s:AlternateFileCommand_get_aliases() dict
  return ['AE', 'AS', 'AV', 'AT', 'AD', 'A']
endfunction

function! <SID>s:AlternateFileCommand_get_launcher_strategies() dict
  return ['pick_file_strategy', 'nth_file_strategy']
endfunction

function! <SID>s:AlternateFileCommand_get_finder_context() dict
  return 'alternate_finder_context'
endfunction

" included: 'related_file_command.riml'
function! s:RelatedFileCommandConstructor(container)
  let relatedFileCommandObj = {}
  let switchFileCommandObj = s:SwitchFileCommandConstructor(a:container)
  call extend(relatedFileCommandObj, switchFileCommandObj)
  let relatedFileCommandObj.get_name = function('<SNR>' . s:SID() . '_s:RelatedFileCommand_get_name')
  let relatedFileCommandObj.get_count = function('<SNR>' . s:SID() . '_s:RelatedFileCommand_get_count')
  let relatedFileCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:RelatedFileCommand_get_aliases')
  let relatedFileCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:RelatedFileCommand_get_finder_context')
  let relatedFileCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:RelatedFileCommand_get_launcher_strategies')
  return relatedFileCommandObj
endfunction

function! <SID>s:RelatedFileCommand_get_name() dict
  return 'Related'
endfunction

function! <SID>s:RelatedFileCommand_get_count() dict
  return 1
endfunction

function! <SID>s:RelatedFileCommand_get_aliases() dict
  return ['RE', 'RS', 'RV', 'RT', 'RD', 'R']
endfunction

function! <SID>s:RelatedFileCommand_get_finder_context() dict
  return 'related_finder_context'
endfunction

function! <SID>s:RelatedFileCommand_get_launcher_strategies() dict
  return ['pick_file_strategy', 'nth_file_strategy']
endfunction

" included: 'resource_file_command.riml'
function! s:ResourceFileCommandConstructor(container)
  let resourceFileCommandObj = {}
  let switchFileCommandObj = s:SwitchFileCommandConstructor(a:container)
  call extend(resourceFileCommandObj, switchFileCommandObj)
  let resourceFileCommandObj.get_name = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_name')
  let resourceFileCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_has_ex_mode')
  let resourceFileCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_has_ctrlp_mode')
  let resourceFileCommandObj.get_range = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_range')
  let resourceFileCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_aliases')
  let resourceFileCommandObj.get_ctrlp_aliases = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_ctrlp_aliases')
  let resourceFileCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_finder_context')
  let resourceFileCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_launcher_strategies')
  let resourceFileCommandObj.get_resource_type_names = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_resource_type_names')
  let resourceFileCommandObj.get_error_label = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_get_error_label')
  let resourceFileCommandObj.can_complete = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_can_complete')
  let resourceFileCommandObj.can_run = function('<SNR>' . s:SID() . '_s:ResourceFileCommand_can_run')
  return resourceFileCommandObj
endfunction

function! <SID>s:ResourceFileCommand_get_name() dict
  return 'ResourceFile'
endfunction

function! <SID>s:ResourceFileCommand_has_ex_mode() dict
  return self.buffer_has_context()
endfunction

function! <SID>s:ResourceFileCommand_has_ctrlp_mode() dict
  return self.buffer_has_context()
endfunction

function! <SID>s:ResourceFileCommand_get_range() dict
  return 1
endfunction

function! <SID>s:ResourceFileCommand_get_aliases() dict
  let resource_type_names = self.get_resource_type_names()
  let aliases = []
  for resource_type in resource_type_names
    for variant in self.variants
      let alias = variant . resource_type
      call add(aliases, alias)
    endfor
  endfor
  return aliases
endfunction

function! <SID>s:ResourceFileCommand_get_ctrlp_aliases() dict
  return self.get_resource_type_names()
endfunction

function! <SID>s:ResourceFileCommand_get_finder_context() dict
  return 'resource_finder_context'
endfunction

function! <SID>s:ResourceFileCommand_get_launcher_strategies() dict
  return ['pick_file_strategy', 'new_resource_strategy']
endfunction

function! <SID>s:ResourceFileCommand_get_resource_type_names() dict
  let contexts = self.get_current_contexts()
  let root = self.get_current_root()
  if !(contexts.contains(root))
    return []
  endif
  let context = contexts.get(root)
  let projections = context.get_projections()
  let resource_types = projections.get_resource_types()
  return resource_types
endfunction

function! <SID>s:ResourceFileCommand_get_error_label(options) dict
  let resource_type = a:options.get_resource_type()
  if resource_type !=# '' && resource_type !=# 'unknown'
    return resource_type
  else
    return self.get_name()
  endif
endfunction

function! <SID>s:ResourceFileCommand_can_complete(options) dict
  if !(self.buffer_has_context())
    return 0
  endif
  let projections = self.lookup('projections')
  let resource_type = a:options.get_resource_type()
  let projection = projections.find_by_resource_type(resource_type)
  if projection.is_projection
    call a:options.set_resource_type(resource_type)
    return 1
  else
    return 0
  endif
endfunction

function! <SID>s:ResourceFileCommand_can_run(options) dict
  return self.buffer_has_context()
endfunction

" included: 'get_file_command.riml'
function! s:GetFileCommandConstructor(container)
  let getFileCommandObj = {}
  let switchFileCommandObj = s:SwitchFileCommandConstructor(a:container)
  call extend(getFileCommandObj, switchFileCommandObj)
  let getFileCommandObj.get_name = function('<SNR>' . s:SID() . '_s:GetFileCommand_get_name')
  let getFileCommandObj.has_ex_mode = function('<SNR>' . s:SID() . '_s:GetFileCommand_has_ex_mode')
  let getFileCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:GetFileCommand_has_ctrlp_mode')
  let getFileCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:GetFileCommand_get_finder_context')
  let getFileCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:GetFileCommand_get_launcher_strategies')
  let getFileCommandObj.launch = function('<SNR>' . s:SID() . '_s:GetFileCommand_launch')
  let getFileCommandObj.to_rel_path = function('<SNR>' . s:SID() . '_s:GetFileCommand_to_rel_path')
  return getFileCommandObj
endfunction

function! <SID>s:GetFileCommand_get_name() dict
  return 'GetFile'
endfunction

function! <SID>s:GetFileCommand_has_ex_mode() dict
  return 0
endfunction

function! <SID>s:GetFileCommand_has_ctrlp_mode() dict
  return 0
endfunction

function! <SID>s:GetFileCommand_get_finder_context() dict
  return 'get_file_finder_context'
endfunction

function! <SID>s:GetFileCommand_get_launcher_strategies() dict
  let s = []
  call add(s, 'get_file_strategy')
  call add(s, 'strip_ext_strategy')
  call add(s, 'underscorize_strategy')
  call add(s, 'camelize_strategy')
  call add(s, 'affinize_strategy')
  return s
endfunction

function! <SID>s:GetFileCommand_launch(strategies, finder_context, options) dict
  let launcher = self.lookup('launcher')
  let launchable = launcher.run(a:strategies, a:finder_context, a:options)
  if launchable.is_launchable
    return self.to_rel_path(launchable.get_filepath())
  else
    return a:options.get_args()[0]
  endif
endfunction

function! <SID>s:GetFileCommand_to_rel_path(filepath) dict
  let root = self.get_current_root()
  let abs_path = root . a:filepath
  let rel_path = fnamemodify(abs_path, ':.')
  return rel_path
endfunction

" included: 'portkey_runner_command.riml'
function! s:PortkeyRunnerCommandConstructor(container)
  let portkeyRunnerCommandObj = {}
  let switchFileCommandObj = s:SwitchFileCommandConstructor(a:container)
  call extend(portkeyRunnerCommandObj, switchFileCommandObj)
  let portkeyRunnerCommandObj.get_name = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_name')
  let portkeyRunnerCommandObj.get_aliases = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_aliases')
  let portkeyRunnerCommandObj.get_nargs = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_nargs')
  let portkeyRunnerCommandObj.get_bang = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_bang')
  let portkeyRunnerCommandObj.has_ctrlp_mode = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_has_ctrlp_mode')
  let portkeyRunnerCommandObj.get_completer = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_completer')
  let portkeyRunnerCommandObj.get_finder_context = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_finder_context')
  let portkeyRunnerCommandObj.get_launcher_strategies = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_get_launcher_strategies')
  let portkeyRunnerCommandObj.launch = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_launch')
  let portkeyRunnerCommandObj.make = function('<SNR>' . s:SID() . '_s:PortkeyRunnerCommand_make')
  return portkeyRunnerCommandObj
endfunction

function! <SID>s:PortkeyRunnerCommand_get_name() dict
  return 'PortkeyRunner'
endfunction

function! <SID>s:PortkeyRunnerCommand_get_aliases() dict
  return ['Run']
endfunction

function! <SID>s:PortkeyRunnerCommand_get_nargs() dict
  return '0'
endfunction

function! <SID>s:PortkeyRunnerCommand_get_bang() dict
  return 1
endfunction

function! <SID>s:PortkeyRunnerCommand_has_ctrlp_mode() dict
  return 0
endfunction

function! <SID>s:PortkeyRunnerCommand_get_completer() dict
  return 0
endfunction

function! <SID>s:PortkeyRunnerCommand_get_finder_context() dict
  return 'test_finder_context'
endfunction

function! <SID>s:PortkeyRunnerCommand_get_launcher_strategies() dict
  return ['test_file_strategy']
endfunction

function! <SID>s:PortkeyRunnerCommand_launch(strategies, finder_context, options) dict
  let launcher = self.lookup('launcher')
  let launchable = launcher.run(a:strategies, a:finder_context, a:options)
  let projection = self.get_current_projection()
  if !projection.has_compiler()
    call s:echo_error("No compiler found for: " . self.get_current_buffer_path())
  elseif launchable.is_launchable
    let compiler = projection.get_compiler()
    call self.make(launchable.get_filepath(), compiler, a:options)
  else
    call s:echo_error("No test found for: " . self.get_current_buffer_path())
  endif
endfunction

function! <SID>s:PortkeyRunnerCommand_make(file, compiler, options) dict
  let root = self.get_current_root()
  let make = self.lookup('make')
  call make.set_compiler(a:compiler)
  call make.set_dir(root)
  call make.set_bang(a:options.get_bang())
  let abs_file = root . a:file
  call make.make(abs_file)
endfunction

" included: 'controller.riml'
function! s:ControllerConstructor()
  let controllerObj = {}
  let controllerObj.process = function('<SNR>' . s:SID() . '_s:Controller_process')
  let controllerObj.load = function('<SNR>' . s:SID() . '_s:Controller_load')
  let controllerObj.configure_container = function('<SNR>' . s:SID() . '_s:Controller_configure_container')
  let controllerObj.load_commands = function('<SNR>' . s:SID() . '_s:Controller_load_commands')
  let controllerObj.load_core_extension = function('<SNR>' . s:SID() . '_s:Controller_load_core_extension')
  return controllerObj
endfunction

function! <SID>s:Controller_process(...) dict
  let registry = self.container.lookup('registry')
  return call(registry['run_action'], a:000, registry)
endfunction

function! <SID>s:Controller_load() dict
  call self.configure_container()
  call self.load_commands()
  call self.load_core_extension()
endfunction

function! <SID>s:Controller_configure_container() dict
  let c = s:ContainerConstructor({})
  let self.container = c
  call c.register('extensions', 'ExtensionCollection', 1)
  call c.register('contexts', 'ContextCollection', 1)
  call c.register('buffers', 'BufferCollection', 1)
  call c.register('file_opener', 'FileOpener', 1)
  call c.register('env', 'Environment', 1)
  call c.register('registry', 'CommandRegistry', 1)
  call c.register('matcher', 'FinderMatcher', 1)
  call c.register('context', 'Context')
  call c.register('command_options', 'CommandOptions')
endfunction

function! <SID>s:Controller_load_commands() dict
  let c = self.container
  let r = c.lookup('registry')
  call r.add(s:ConfigureBufferCommandConstructor(c))
  call r.add(s:ChangeCurrentBufferCommandConstructor(c))
  call r.add(s:LoadBufferExCmdsCommandConstructor(c))
  call r.add(s:LoadBufferMappingsCommandConstructor(c))
  call r.add(s:LoadGetFileCommandConstructor(c))
  call r.add(s:LoadSyntaxCommandConstructor(c))
  call r.add(s:ShowVersionCommandConstructor(c))
  call r.add(s:RefreshCommandConstructor(c))
  call r.add(s:PortkeyRunnerCommandConstructor(c))
  call r.add(s:LoadExtensionCommandConstructor(c))
  call r.add(s:PortkeyMappingsCommandConstructor(c))
  call r.add(s:OpenPortkeyCommandConstructor(c))
  call r.add(s:AlternateFileCommandConstructor(c))
  call r.add(s:RelatedFileCommandConstructor(c))
  call r.add(s:ResourceFileCommandConstructor(c))
  call r.add(s:GetFileCommandConstructor(c))
endfunction

function! <SID>s:Controller_load_core_extension() dict
  call self.process('LoadExtension', s:CoreExtensionConstructor())
endfunction

" included: 'app.riml'
function! s:AppConstructor()
  let appObj = {}
  let appObj.controller = s:ControllerConstructor()
  let appObj.start = function('<SNR>' . s:SID() . '_s:App_start')
  let appObj.on_buffer_open = function('<SNR>' . s:SID() . '_s:App_on_buffer_open')
  let appObj.on_buffer_enter = function('<SNR>' . s:SID() . '_s:App_on_buffer_enter')
  let appObj.on_buffer_leave = function('<SNR>' . s:SID() . '_s:App_on_buffer_leave')
  let appObj.add_extension = function('<SNR>' . s:SID() . '_s:App_add_extension')
  return appObj
endfunction

function! <SID>s:App_start() dict
  call self.controller.load()
endfunction

function! <SID>s:App_on_buffer_open(buffer) dict
  return self.controller.process('ConfigureBuffer', a:buffer)
endfunction

function! <SID>s:App_on_buffer_enter(buffer) dict
  return self.controller.process('ChangeCurrentBuffer', a:buffer)
endfunction

function! <SID>s:App_on_buffer_leave(buffer) dict
endfunction

function! <SID>s:App_add_extension(extension) dict
  call self.controller.process('LoadExtension', a:extension)
endfunction

" included: 'version.riml'
let g:portkey_version = '0.1.10'
" included: 'python_file_writer.riml'
function! s:PythonFileWriterConstructor(sys_path, output_file)
  let pythonFileWriterObj = {}
  let pythonFileWriterObj.output_file = a:output_file
  call mkdir(fnamemodify(a:output_file, ':h'), 'p')
  execute ":python import sys, os"
  execute ":python sys.path.append('" . a:sys_path . "')"
  execute ":python from scripts.file_writer import FileWriter"
  execute ":python file_writer = FileWriter('" . a:output_file . "')"
  let pythonFileWriterObj.write = function('<SNR>' . s:SID() . '_s:PythonFileWriter_write')
  let pythonFileWriterObj.writeln = function('<SNR>' . s:SID() . '_s:PythonFileWriter_writeln')
  let pythonFileWriterObj.flush = function('<SNR>' . s:SID() . '_s:PythonFileWriter_flush')
  let pythonFileWriterObj.flush_line = function('<SNR>' . s:SID() . '_s:PythonFileWriter_flush_line')
  let pythonFileWriterObj.flush = function('<SNR>' . s:SID() . '_s:PythonFileWriter_flush')
  let pythonFileWriterObj.setup_exit_hooks = function('<SNR>' . s:SID() . '_s:PythonFileWriter_setup_exit_hooks')
  return pythonFileWriterObj
endfunction

function! <SID>s:PythonFileWriter_write(line) dict
  execute ':python file_writer.write("' . escape(a:line, '"') . '")'
endfunction

function! <SID>s:PythonFileWriter_writeln(line) dict
  execute ':python file_writer.writeln("' . escape(a:line, '"') . '")'
endfunction

function! <SID>s:PythonFileWriter_flush() dict
  execute ':python file_writer.flush()'
  execute ':python file_writer.close()'
endfunction

function! <SID>s:PythonFileWriter_flush_line() dict
  if !(self.current_line ==# '')
    call add(self.lines, self.current_line)
    let self.current_line = ''
  endif
endfunction

function! <SID>s:PythonFileWriter_flush() dict
  call self.flush_line()
  call writefile(self.lines, self.output_file)
endfunction

function! <SID>s:PythonFileWriter_setup_exit_hooks() dict
  let delegate = s:new_delegate(self, 'flush')
  augroup file_writer_group
  autocmd!
  execute ":autocmd VimLeavePre * :call " . delegate . "()"
  augroup END
endfunction

" included: 'file_log_writer.riml'
function! s:FileLogWriterConstructor()
  let fileLogWriterObj = {}
  let fileLogWriterObj.colorize = 1
  let fileLogWriterObj.set_writer = function('<SNR>' . s:SID() . '_s:FileLogWriter_set_writer')
  let fileLogWriterObj.get_writer = function('<SNR>' . s:SID() . '_s:FileLogWriter_get_writer')
  let fileLogWriterObj.set_log_file = function('<SNR>' . s:SID() . '_s:FileLogWriter_set_log_file')
  let fileLogWriterObj.set_colorize = function('<SNR>' . s:SID() . '_s:FileLogWriter_set_colorize')
  let fileLogWriterObj.get_colorize = function('<SNR>' . s:SID() . '_s:FileLogWriter_get_colorize')
  let fileLogWriterObj.log = function('<SNR>' . s:SID() . '_s:FileLogWriter_log')
  let fileLogWriterObj.flush = function('<SNR>' . s:SID() . '_s:FileLogWriter_flush')
  return fileLogWriterObj
endfunction

function! <SID>s:FileLogWriter_set_writer(writer) dict
  let self.writer = a:writer
endfunction

function! <SID>s:FileLogWriter_get_writer() dict
  return self.writer
endfunction

function! <SID>s:FileLogWriter_set_log_file(log_file) dict
  let self.log_file = a:log_file
endfunction

function! <SID>s:FileLogWriter_set_colorize(colorize) dict
  let self.colorize = a:colorize
endfunction

function! <SID>s:FileLogWriter_get_colorize() dict
  return self.colorize
endfunction

function! <SID>s:FileLogWriter_log(message) dict
  let writer = self.get_writer()
  call writer.writeln(a:message)
endfunction

function! <SID>s:FileLogWriter_flush() dict
  let writer = self.get_writer()
  call writer.flush()
endfunction

" included: 'logger.riml'
function! s:LoggerConstructor()
  let loggerObj = {}
  let loggerObj.messages = []
  let loggerObj.log_writers = []
  let loggerObj.level = 'info'
  let loggerObj.levels = {}
  let loggerObj.levels.all = 0
  let loggerObj.levels.debug = 1
  let loggerObj.levels.info = 2
  let loggerObj.levels.warn = 3
  let loggerObj.levels.error = 4
  let loggerObj.levels.fatal = 5
  let loggerObj.levels.off = 6
  let loggerObj.colors = {}
  let loggerObj.colors.all = 0
  let loggerObj.colors.debug = 0
  let loggerObj.colors.info = 0
  let loggerObj.colors.warn = '31m'
  let loggerObj.colors.error = '31m'
  let loggerObj.colors.fatal = '31m'
  let loggerObj.colors.off = 0
  let loggerObj.add_log_writer = function('<SNR>' . s:SID() . '_s:Logger_add_log_writer')
  let loggerObj.set_level = function('<SNR>' . s:SID() . '_s:Logger_set_level')
  let loggerObj.get_level = function('<SNR>' . s:SID() . '_s:Logger_get_level')
  let loggerObj.get_level_num = function('<SNR>' . s:SID() . '_s:Logger_get_level_num')
  let loggerObj.is_loggable = function('<SNR>' . s:SID() . '_s:Logger_is_loggable')
  let loggerObj.do_log = function('<SNR>' . s:SID() . '_s:Logger_do_log')
  let loggerObj.args_to_message = function('<SNR>' . s:SID() . '_s:Logger_args_to_message')
  let loggerObj.send_log = function('<SNR>' . s:SID() . '_s:Logger_send_log')
  let loggerObj.to_color = function('<SNR>' . s:SID() . '_s:Logger_to_color')
  let loggerObj.debug = function('<SNR>' . s:SID() . '_s:Logger_debug')
  let loggerObj.info = function('<SNR>' . s:SID() . '_s:Logger_info')
  let loggerObj.log = function('<SNR>' . s:SID() . '_s:Logger_log')
  let loggerObj.warn = function('<SNR>' . s:SID() . '_s:Logger_warn')
  let loggerObj.error = function('<SNR>' . s:SID() . '_s:Logger_error')
  let loggerObj.fatal = function('<SNR>' . s:SID() . '_s:Logger_fatal')
  return loggerObj
endfunction

function! <SID>s:Logger_add_log_writer(log_writer) dict
  call add(self.log_writers, a:log_writer)
endfunction

function! <SID>s:Logger_set_level(level) dict
  let self.level = a:level
endfunction

function! <SID>s:Logger_get_level() dict
  return self.level
endfunction

function! <SID>s:Logger_get_level_num(level) dict
  return self.levels[a:level]
endfunction

function! <SID>s:Logger_is_loggable(level) dict
  return self.get_level_num(a:level) >=# self.get_level_num(self.level)
endfunction

function! <SID>s:Logger_do_log(args, level) dict
  if self.is_loggable(a:level)
    let msg = self.args_to_message(a:args)
    call self.send_log(msg, a:level)
  endif
endfunction

function! <SID>s:Logger_args_to_message(args) dict
  return join(a:args, ' ')
endfunction

function! <SID>s:Logger_send_log(msg, level) dict
  let color_msg = self.to_color(a:msg, a:level)
  for log_writer in self.log_writers
    if log_writer.get_colorize()
      call log_writer.log(color_msg)
    else
      call log_writer.log(a:msg)
    endif
  endfor
endfunction

function! <SID>s:Logger_to_color(msg, level) dict
  let color = self.colors[a:level]
  if color !=# 0
    return "[" . color . a:msg . "[0m"
  else
    return a:msg
  endif
endfunction

function! <SID>s:Logger_debug(...) dict
  call self.do_log(a:000, 'debug')
endfunction

function! <SID>s:Logger_info(...) dict
  call self.do_log(a:000, 'info')
endfunction

function! <SID>s:Logger_log(...) dict
  call self.do_log(a:000, 'info')
endfunction

function! <SID>s:Logger_warn(...) dict
  call self.do_log(a:000, 'warn')
endfunction

function! <SID>s:Logger_error(...) dict
  call self.do_log(a:000, 'error')
endfunction

function! <SID>s:Logger_fatal(...) dict
  call self.do_log(a:000, 'fatal')
endfunction

function! s:get_logger()
  if !(exists('g:logger'))
    let g:logger = s:LoggerConstructor()
  endif
  return g:logger
endfunction

let s:logger = s:get_logger()
let s:portkey_app_path = expand('<sfile>:h')
function! portkey#app()
  if !exists('s:app')
    call s:init_logger()
    let s:app = s:AppConstructor()
    call s:app.start()
    let g:portkey_app_loaded = 1
  endif
  return s:app
endfunction

function! portkey#add_extension(extension)
  let app = portkey#app()
  call app.add_extension(a:extension)
endfunction

function! s:init_logger()
  if !(exists('g:portkey_logger') && g:portkey_logger && has('python'))
    return
  endif
  let file_writer = s:PythonFileWriterConstructor(s:get_sys_path(), s:get_log_file())
  let s:logger_writer = s:FileLogWriterConstructor()
  call s:logger_writer.set_writer(file_writer)
  let logger = s:get_logger()
  call logger.add_log_writer(s:logger_writer)
  call logger.log("Portkey: version=" . g:portkey_version)
endfunction

function! s:get_sys_path()
  let current_dir = fnamemodify(s:portkey_app_path, ':h')
  return current_dir
endfunction

function! s:get_log_file()
  let current_dir = fnamemodify(s:portkey_app_path, ':h')
  let log_dir = current_dir . "/logs"
  let log_file = log_dir . "/portkey.log"
  return log_file
endfunction
